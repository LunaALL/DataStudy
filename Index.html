
<!doctype html>
<html data-n-head-ssr><head ><title>Java - 나무위키</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="user-scalable=no, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, width=device-width"><meta data-n-head="ssr" http-equv="x-ua-compatible" content="ie=edge"><meta data-n-head="ssr" name="generator" content="the seed"><meta data-n-head="ssr" name="mobile-web-app-capable" content="yes"><meta data-n-head="ssr" name="application-name" content="나무위키"><meta data-n-head="ssr" name="msapplication-tooltip" content="나무위키"><meta data-n-head="ssr" name="msapplication-starturl" content="/w/%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4:%EB%8C%80%EB%AC%B8"><meta data-n-head="ssr" name="theme-color" content="#008275"><meta data-n-head="ssr" name="googlebot" content="noarchive"><link data-n-head="ssr" rel="canonical" href="https://namu.wiki/w/Java"><link data-n-head="ssr" rel="search" type="application/opensearchdescription+xml" title="나무위키" href="/opensearch.xml"><link data-n-head="ssr" rel="copyright" href="//creativecommons.org/licenses/by-nc-sa/2.0/kr/"><link data-n-head="ssr" rel="icon" href="/favicon.svg"><link data-n-head="ssr" rel="apple-touch-icon" href="/img/apple_icon.png"><script data-n-head="ssr" async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script><link rel="preload" href="/skins/senkawa/manifest.f912fa1fc68aea9c8bcf.js" as="script"><link rel="preload" href="/skins/senkawa/4.eef37a8375da62ac81c7.css" as="style"><link rel="preload" href="/skins/senkawa/vendor.eef37a8375da62ac81c7.js" as="script"><link rel="preload" href="/skins/senkawa/2.1960bf2496955164048f.css" as="style"><link rel="preload" href="/skins/senkawa/main.1960bf2496955164048f.js" as="script"><link rel="stylesheet" href="/skins/senkawa/4.eef37a8375da62ac81c7.css"><link rel="stylesheet" href="/skins/senkawa/2.1960bf2496955164048f.css"></head><body ><div id="app" data-server-rendered="true"><!----><div class="app senkawa-fixed-size senkawa-fixed-1300" data-v-832c58d0><div data-v-4c6f7db9 data-v-832c58d0><nav data-v-3674418a data-v-832c58d0><a href="/" data-v-decdc61a data-v-832c58d0></a> <ul data-v-97145b5e data-v-832c58d0><li data-v-ac9432bc data-v-832c58d0><a href="/RecentChanges" title="최근 변경" data-v-ac9432bc><span class="i ion-md-compass" data-v-ac9432bc></span> <span class="t" data-v-ac9432bc>최근 변경</span></a></li> <li data-v-ac9432bc data-v-832c58d0><a href="/RecentDiscuss" title="최근 토론" data-v-ac9432bc><span class="i ion-md-text" data-v-ac9432bc></span> <span class="t" data-v-ac9432bc>최근 토론</span></a></li> <li data-v-6d889646 data-v-832c58d0><a href="#" title="특수 기능" data-v-6d889646><span class="i ion-ios-cube" data-v-6d889646></span> <span class="t" data-v-6d889646>특수 기능</span></a> <div data-v-6d889646><a href="//board.namu.wiki/" title="게시판" data-v-193fc2b2 data-v-832c58d0><span class="i ion-ios-clipboard" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>게시판</span></a> <div data-v-12e4a4c3 data-v-832c58d0></div> <a href="/NeededPages" title="작성이 필요한 문서" data-v-193fc2b2 data-v-832c58d0><span class="i ion-md-alert" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>작성이 필요한 문서</span></a> <a href="/OrphanedPages" title="고립된 문서" data-v-193fc2b2 data-v-832c58d0><span class="i ion-ios-link" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>고립된 문서</span></a> <a href="/UncategorizedPages" title="분류가 되지 않은 문서" data-v-193fc2b2 data-v-832c58d0><span class="i ion-md-help" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>분류가 되지 않은 문서</span></a> <a href="/OldPages" title="편집된 지 오래된 문서" data-v-193fc2b2 data-v-832c58d0><span class="i ion-ios-pause" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>편집된 지 오래된 문서</span></a> <a href="/ShortestPages" title="내용이 짧은 문서" data-v-193fc2b2 data-v-832c58d0><span class="i ion-md-create" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>내용이 짧은 문서</span></a> <a href="/LongestPages" title="내용이 긴 문서" data-v-193fc2b2 data-v-832c58d0><span class="i ion-md-heart" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>내용이 긴 문서</span></a> <a href="/BlockHistory" title="차단 내역" data-v-193fc2b2 data-v-832c58d0><span class="i ion-md-heart-dislike" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>차단 내역</span></a> <a href="/RandomPage" title="RandomPage" data-v-193fc2b2 data-v-832c58d0><span class="i ion-ios-shuffle" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>RandomPage</span></a> <a href="/Upload" title="파일 올리기" data-v-193fc2b2 data-v-832c58d0><span class="i ion-ios-cloud-upload" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>파일 올리기</span></a> <a href="/License" title="라이선스" data-v-193fc2b2 data-v-832c58d0><span class="i ion-ios-pricetag" data-v-193fc2b2></span> <span class="t" data-v-193fc2b2>라이선스</span></a> <!----></div></li> <li data-v-ac9432bc data-v-832c58d0><a href="//arca.live/" title="아카" data-v-ac9432bc><span class="i arcalive" data-v-ac9432bc></span> <span class="t" data-v-ac9432bc>아카</span></a></li></ul> <ul class="r" data-v-97145b5e data-v-832c58d0><li data-v-2379e7ac data-v-832c58d0><a href="#" title="Member menu" data-v-2379e7ac><span class="ion-ios-person" data-v-2379e7ac></span></a> <div data-v-2379e7ac><div id="tchika430e2ccb" data-v-2379e7ac data-v-832c58d0><div data-v-2379e7ac data-v-832c58d0>183.101.101.52</div> <div data-v-2379e7ac data-v-832c58d0>Please login!</div></div> <div data-v-12e4a4c3 data-v-832c58d0></div> <a href="#" title="설정" data-v-193fc2b2 data-v-832c58d0>설정</a> <!----> <div data-v-12e4a4c3 data-v-832c58d0></div> <a href="/contribution/ip/183.101.101.52/document" title="내 문서 기여 목록" data-v-193fc2b2 data-v-832c58d0>내 문서 기여 목록</a> <a href="/contribution/ip/183.101.101.52/discuss" title="내 토론 기여 목록" data-v-193fc2b2 data-v-832c58d0>내 토론 기여 목록</a> <div data-v-12e4a4c3 data-v-832c58d0></div> <a href="/member/login?redirect=%2Fw%2FJava" title="로그인" data-v-193fc2b2 data-v-832c58d0>로그인</a></div></li></ul> <form data-v-7cc84fd7 data-v-832c58d0><div id="tchikae5cf49dd" data-v-7cc84fd7><span class="l" data-v-7cc84fd7><a href="/random" data-v-7cc84fd7><span class="ion-ios-shuffle" data-v-7cc84fd7></span></a></span> <div id="tchika157caaf9" data-v-7cc84fd7><input type="search" placeholder="Search" tabindex="1" autocomplete="off" value="" data-v-7cc84fd7> <!----></div> <span class="r" data-v-7cc84fd7><button type="button" data-v-7cc84fd7><span class="ion-ios-search" data-v-7cc84fd7></span></button> <button type="button" data-v-7cc84fd7><span class="ion-ios-arrow-round-forward" data-v-7cc84fd7></span></button></span></div></form></nav></div> <div data-v-4b836aff data-v-832c58d0><aside data-v-f154f7f4 data-v-832c58d0><div id="tchika06a11d88" class="c" data-v-0c30ccab data-v-832c58d0><h5 data-v-0c30ccab>최근 변경</h5> <div data-v-0c30ccab><a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> <a data-v-0c30ccab><span data-v-0c30ccab>00:00</span>갱신중...</a> </div> <a href="/RecentChanges" data-v-0c30ccab>[더 보기]</a></div> <div class="c" data-v-32a946f2 data-v-832c58d0><div id="tchika64f2a62c" data-v-32a946f2></div></div> <div class="c" data-v-396ac112 data-v-832c58d0><h5 data-v-396ac112>나무뉴스</h5> <div data-v-396ac112><a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> <a data-v-396ac112>갱신중...</a> </div> <a href="//namu.news/" rel="noopener" target="_blank" data-v-396ac112>[더 보기]</a></div> <div class="c" data-v-19dc98dc data-v-832c58d0><div id="tchika99261776" data-v-19dc98dc></div></div></aside> <article data-v-21f1cc50 data-v-832c58d0><!----> <!----> <div class="r" data-v-5058474b data-v-21f1cc50><div class="g" data-v-5058474b><a href="/member/star/Java" data-v-21f1cc50><span class="icon ion-ios-star-outline" data-v-21f1cc50></span> 17</a> <!----> <a href="/backlink/Java" data-v-21f1cc50>역링크</a> <a href="/discuss/Java" data-v-21f1cc50>토론</a> <a href="/edit/Java" rel="nofollow" data-v-21f1cc50>편집</a> <a href="/history/Java" data-v-21f1cc50>역사</a> <!----> <a href="/acl/Java" rel="nofollow" data-v-21f1cc50>ACL</a> <!----></div></div> <h1 data-v-21f1cc50><a href="/w/Java" data-v-21f1cc50><!---->Java</a> <!----></h1> <p data-v-21f1cc50>최근 수정 시각: <time datetime="2020-09-01T05:37:14.000Z" data-v-21f1cc50>2020-09-01 05:37:14</time></p> <!----> <div id="tchikaa9d2f644" class="c" data-v-21f1cc50><div id="tchika05b215ab" data-v-21f1cc50></div></div> <!----> <div data-v-0e28be7a data-v-832c58d0><!----> <!----> <div data-v-b1ee5ece data-v-0e28be7a><h2 data-v-b1ee5ece>분류</h2> <ul data-v-b1ee5ece><li data-v-b1ee5ece><a href="/w/%EB%B6%84%EB%A5%98:%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4" data-v-b1ee5ece>프로그래밍 언어</a></li><li data-v-b1ee5ece><a href="/w/%EB%B6%84%EB%A5%98:%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%EC%96%B8%EC%96%B4" data-v-b1ee5ece>객체 지향 언어</a></li></ul></div> <!----> <div data-v-0e28be7a><!----> <!----> <div data-v-b83f675c data-v-0e28be7a><div class="w" data-v-b83f675c><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%2B%EC%9C%A0%EB%8F%84.png' title='파일:나무위키+유도.png' rel='nofollow'><span class='wiki-image-align-left' style='width:21px;'><span class='wiki-image-wrapper' style='width: 100%;'><img class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='><img class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='36499' data-src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'><noscript><img class='wiki-image' width='100%' src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'></noscript></span></span></a>   <div style="display:inline;display:none"><strong></strong>은(는) 여기로 연결됩니다. </div>동음이의어에 대한 내용은 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94' title='자바'>자바</a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94#s-' title='자바'></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94' title='자바'></a> 부분을</div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i1-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div> 참조하십시오.</div><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%2B%EC%9C%A0%EB%8F%84.png' title='파일:나무위키+유도.png' rel='nofollow'><span class='wiki-image-align-left' style='width:21px;'><span class='wiki-image-wrapper' style='width: 100%;'><img class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='><img class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='36499' data-src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'><noscript><img class='wiki-image' width='100%' src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'></noscript></span></span></a>   <div style="display:inline;display:none"><strong></strong>은(는) 여기로 연결됩니다. </div>인간어에 대한 내용은 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%EC%96%B4' title='자바어'>자바어</a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%EC%96%B4#s-' title='자바어'></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%EC%96%B4' title='자바어'></a> 부분을</div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div><div style="display:inline;display:none">, 에 대한 내용은 <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='#i2-s-' title=''></a> 문단을</div><div style="display:inline;display:none">의 <a class='wiki-self-link' href='' title=''></a> 부분을</div></div> 참조하십시오.</div><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%2B%ED%95%98%EC%9C%84%EB%AC%B8%EC%84%9C.png' title='파일:나무위키+하위문서.png' rel='nofollow'><span class='wiki-image-align-left' style='width:21px;'><span class='wiki-image-wrapper' style='width: 100%;'><img class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='><img class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='11402' data-src='//w.namu.la/s/e7fa4fff2b0926b0190ccc1cdfd51123f98b2c5fdf7524ee5057f1b216a33084a71f9dabcb4c0e17daada6747a0acb61e6ba8993f66acfb7a77148109599828648f22881abe596ac0f39910306ffd1a830d21287861456f90b0ff8f99bc1c669' alt='파일:나무위키+하위문서.png'><noscript><img class='wiki-image' width='100%' src='//w.namu.la/s/e7fa4fff2b0926b0190ccc1cdfd51123f98b2c5fdf7524ee5057f1b216a33084a71f9dabcb4c0e17daada6747a0acb61e6ba8993f66acfb7a77148109599828648f22881abe596ac0f39910306ffd1a830d21287861456f90b0ff8f99bc1c669' alt='파일:나무위키+하위문서.png'></noscript></span></span></a>   하위 문서: <a class='wiki-link-internal' href='/w/Java/%EB%B2%84%EC%A0%84%20%EC%A0%95%EB%B3%B4' title='Java/버전 정보'>Java/버전 정보</a><div style="display:inline">, <a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'>Java/문법</a><a class='wiki-self-link' href='' title=''></a></div><div style="display:inline;display:none">, <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a></div><div style="display:inline;display:none">, <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a></div><div style="display:inline;display:none">, <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a></div><div style="display:inline;display:none">, <a class='wiki-self-link' href='' title=''></a><a class='wiki-self-link' href='' title=''></a></div></div><div class='wiki-paragraph'></div><div class='wiki-paragraph'><div style="word-break:keep-all"><div class='wiki-table-wrap table-center' style='width:100%'><table class='wiki-table' style='background-color:white; width:100%; border:2px solid deepskyblue;' data-dark-style='background-color:#222;'><tbody><tr><td colspan='10' style='background-color:deepskyblue; text-align:center;'><div class='wiki-paragraph'><strong><span class='wiki-color' style='color:white'><a class='wiki-link-external' href='http://www.tiobe.com/tiobe_index' target='_blank' rel='nofollow noopener' title='http://www.tiobe.com/tiobe_index'><span class='wiki-color' style='color:#FFF'>TIOBE</span></a>에서 선정한 2020년 8월 기준 검색어 점유율 상위 20개 <a class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'><span class='wiki-color' style='color:white'>프로그래밍 언어</span></a></span></strong></div></td></tr><tr><td style='width:5%; text-align:center;'><div class='wiki-paragraph'><strong>1</strong></div></td><td style='width:15%; text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/C%EC%96%B8%EC%96%B4' title='C언어'>C</a></div></td><td style='width:5%; text-align:center;'><div class='wiki-paragraph'><strong>2</strong></div></td><td style='width:15%; text-align:center;'><div class='wiki-paragraph'><a class='wiki-self-link' href='/w/Java' title='Java'>Java</a></div></td><td style='width:5%; text-align:center;'><div class='wiki-paragraph'><strong>3</strong></div></td><td style='width:15%; text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a></div></td><td style='width:5%; text-align:center;'><div class='wiki-paragraph'><strong>4</strong></div></td><td style='width:15%; text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a></div></td><td style='width:5%; text-align:center;'><div class='wiki-paragraph'><strong>5</strong></div></td><td style='width:15%; text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/C%23' title='C#'>C#</a></div></td></tr><tr><td style='text-align:center;'><div class='wiki-paragraph'><strong>6</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Visual%20Basic%20.NET' title='Visual Basic .NET'>Visual Basic .NET</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>7</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>8</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/R(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='R(프로그래밍 언어)'>R</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>9</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/PHP' title='PHP'>PHP</a> </div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>10</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Structured%20Query%20Language' title='Structured Query Language'>SQL</a></div></td></tr><tr><td style='text-align:center;'><div class='wiki-paragraph'><strong>11</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Go(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Go(프로그래밍 언어)'>Go</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>12</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Swift(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Swift(프로그래밍 언어)'>Swift</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>13</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Perl' title='Perl'>Perl</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>14</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4' title='어셈블리어'>어셈블리어</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>15</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Ruby' title='Ruby'>Ruby</a></div></td></tr><tr><td style='text-align:center;'><div class='wiki-paragraph'><strong>16</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/MATLAB' title='MATLAB'>MATLAB</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>17</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Visual%20Basic' title='Visual Basic'>Visual Basic</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>18</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Groovy' title='Groovy'>Groovy</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>19</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Objective-C' title='Objective-C'>Objective-C</a></div></td><td style='text-align:center;'><div class='wiki-paragraph'><strong>20</strong></div></td><td style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Rust' title='Rust'>Rust</a></div></td></tr></tbody></table></div></div><br></div><div class='wiki-paragraph'></div><div class='wiki-table-wrap table-right' style='width:400px'><table class='wiki-table' style='width:100%;'><tbody><tr><td colspan='2' style='text-align:center;'><div class='wiki-paragraph'><strong><span class='wiki-size size-up-1'>자바</span></strong><br>Java</div></td></tr><tr><td colspan='2' style='text-align:center;'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:java%20%EB%A1%9C%EA%B3%A0.png' title='파일:java 로고.png' rel='nofollow'><span class='wiki-image-align-normal' style='width:25%;'><span class='wiki-image-wrapper' style='width: 100%;'><img class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjYyIiBoZWlnaHQ9IjQ4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='><img class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjYyIiBoZWlnaHQ9IjQ4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='15934' data-src='//w.namu.la/s/d307e68a02cda1962f70371be5ba91c330d1ea6a281c20c89ec4af389f4652a65376506adf9cc76b4c3810632469645ff3a71b7e9202809da711adf1d7d89478e7cc47530e38520a3a321ef22822f57ebc6420d7cc89d79e7b4d7d1840500081' alt='파일:java 로고.png'><noscript><img class='wiki-image' width='100%' src='//w.namu.la/s/d307e68a02cda1962f70371be5ba91c330d1ea6a281c20c89ec4af389f4652a65376506adf9cc76b4c3810632469645ff3a71b7e9202809da711adf1d7d89478e7cc47530e38520a3a321ef22822f57ebc6420d7cc89d79e7b4d7d1840500081' alt='파일:java 로고.png'></noscript></span></span></a></div></td></tr><tr><td style='text-align:center;'><div class='wiki-paragraph'>개발</div></td><td style='text-align:left;'><div class='wiki-paragraph'>오라클</div></td></tr><tr><td style='text-align:center;'><div class='wiki-paragraph'>버전</div></td><td style='text-align:left;'><div class='wiki-paragraph'><span class='wiki-size size-up-1'><strong>14</strong></span><br><a class='wiki-link-external' href='http://www.aitimes.kr/news/articleView.html?idxno=15716' target='_blank' rel='nofollow noopener' title='http://www.aitimes.kr/news/articleView.html?idxno=15716'>2020년 3월 18일 업데이트</a><br><span class='wiki-size size-up-1'>15</span><br>2020년 9월 출시 예정</div></td></tr><tr><td style='text-align:center;'><div class='wiki-paragraph'>웹사이트</div></td><td style='text-align:left;'><div class='wiki-paragraph'><a class='wiki-link-external' href='https://www.oracle.com/java/' target='_blank' rel='nofollow noopener' title='https://www.oracle.com/java/'>홈페이지</a></div></td></tr></tbody></table></div><div class='wiki-paragraph'><br><br><div class='wiki-macro-toc' id='toc'><div class='toc-indent'><span class='toc-item'><a href='#s-1'>1</a>. 개요</span><span class='toc-item'><a href='#s-2'>2</a>. 어원</span><span class='toc-item'><a href='#s-3'>3</a>. 분류</span><span class='toc-item'><a href='#s-4'>4</a>. 역사</span><div class='toc-indent'><span class='toc-item'><a href='#s-4.1'>4.1</a>. JDK 1.0a</span><span class='toc-item'><a href='#s-4.2'>4.2</a>. JDK 1.0a2</span><span class='toc-item'><a href='#s-4.3'>4.3</a>. JDK 1.0</span><span class='toc-item'><a href='#s-4.4'>4.4</a>. JDK 1.1</span><span class='toc-item'><a href='#s-4.5'>4.5</a>. J2SE 1.2</span><span class='toc-item'><a href='#s-4.6'>4.6</a>. J2SE 1.3</span><span class='toc-item'><a href='#s-4.7'>4.7</a>. J2SE 1.4</span><span class='toc-item'><a href='#s-4.8'>4.8</a>. J2SE 5</span><span class='toc-item'><a href='#s-4.9'>4.9</a>. Java SE 6</span><span class='toc-item'><a href='#s-4.10'>4.10</a>. Java SE 7</span><span class='toc-item'><a href='#s-4.11'>4.11</a>. Java SE 8</span><span class='toc-item'><a href='#s-4.12'>4.12</a>. Java SE 9</span><span class='toc-item'><a href='#s-4.13'>4.13</a>. Java SE 10</span><span class='toc-item'><a href='#s-4.14'>4.14</a>. Java SE 11</span><span class='toc-item'><a href='#s-4.15'>4.15</a>. Java SE 12</span><span class='toc-item'><a href='#s-4.16'>4.16</a>. Java SE 13</span><span class='toc-item'><a href='#s-4.17'>4.17</a>. Java SE 14</span><span class='toc-item'><a href='#s-4.18'>4.18</a>. Java SE 15</span></div><span class='toc-item'><a href='#s-5'>5</a>. <a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'>문법</a></span><span class='toc-item'><a href='#s-6'>6</a>. C, C++와의 비교</span><span class='toc-item'><a href='#s-7'>7</a>. 특징</span><div class='toc-indent'><span class='toc-item'><a href='#s-7.1'>7.1</a>. 장점</span><div class='toc-indent'><span class='toc-item'><a href='#s-7.1.1'>7.1.1</a>. 수많은 개발자와 레퍼런스</span><span class='toc-item'><a href='#s-7.1.2'>7.1.2</a>. 비교적 높은 생산성</span><span class='toc-item'><a href='#s-7.1.3'>7.1.3</a>. 기기 호환성</span><span class='toc-item'><a href='#s-7.1.4'>7.1.4</a>. 안정성</span><span class='toc-item'><a href='#s-7.1.5'>7.1.5</a>. 소스 코드 가독성</span></div><span class='toc-item'><a href='#s-7.2'>7.2</a>. 단점</span><div class='toc-indent'><span class='toc-item'><a href='#s-7.2.1'>7.2.1</a>. 속도 문제</span><div class='toc-indent'><span class='toc-item'><a href='#s-7.2.1.1'>7.2.1.1</a>. JVM 로딩 속도 문제</span><span class='toc-item'><a href='#s-7.2.1.2'>7.2.1.2</a>. 가상 머신 바이트코드 실행 속도 문제</span><span class='toc-item'><a href='#s-7.2.1.3'>7.2.1.3</a>. 가비지 컬렉션에 의한 실행 지연 문제</span></div><span class='toc-item'><a href='#s-7.2.2'>7.2.2</a>. 불편한 <a class='wiki-link-internal' href='/w/%EC%98%88%EC%99%B8%20%EC%B2%98%EB%A6%AC' title='예외 처리'>예외 처리</a></span><span class='toc-item'><a href='#s-7.2.3'>7.2.3</a>. 소스 코드 길이</span><span class='toc-item'><a href='#s-7.2.4'>7.2.4</a>. 언어적 불편함</span><div class='toc-indent'><span class='toc-item'><a href='#s-7.2.4.1'>7.2.4.1</a>. 명사형 사고를 강제</span><span class='toc-item'><a href='#s-7.2.4.2'>7.2.4.2</a>. <a class='wiki-link-internal' href='/w/%ED%81%B4%EB%A1%9C%EC%A0%80' title='클로저'>클로저</a> 미지원</span></div></div></div><span class='toc-item'><a href='#s-8'>8</a>. 개발환경, JVM 언어</span><div class='toc-indent'><span class='toc-item'><a href='#s-8.1'>8.1</a>. 개발환경</span><span class='toc-item'><a href='#s-8.2'>8.2</a>. <a class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'>JVM</a> 언어</span><div class='toc-indent'><span class='toc-item'><a href='#s-8.2.1'>8.2.1</a>. 유명한 JVM 언어 목록</span></div><span class='toc-item'><a href='#s-8.3'>8.3</a>. 혼동하기 쉬운 것들</span></div><span class='toc-item'><a href='#s-9'>9</a>. 구글 vs. 오라클: Java 저작권 분쟁</span><span class='toc-item'><a href='#s-10'>10</a>. 점유율</span><span class='toc-item'><a href='#s-11'>11</a>. 불투명한 미래?</span><span class='toc-item'><a href='#s-12'>12</a>. 도서</span><span class='toc-item'><a href='#s-13'>13</a>. 여담</span><span class='toc-item'><a href='#s-14'>14</a>. 관련 문서</span></div></div><br><div style='clear:both'></div></div><h2 class='wiki-heading'><a id='s-1' href='#toc'>1.</a> <span id='개요'>개요<span class='wiki-edit-section'><a href='/edit/Java?section=1' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'><pre><code class="syntax" data-language="java"><span class="syntax-keyword">package</span> wiki.namu.test;

<span class="syntax-keyword">public</span> <span class="syntax-keyword">class</span> HelloWorld {
    <span class="syntax-keyword">public</span> <span class="syntax-keyword">static</span> <span class="syntax-keyword">void</span> main(String[] args) {
        System.out.println(<span class="syntax-literal">"Hello, world!"</span>);
    }
}</code></pre><br><a class='wiki-link-internal' href='/w/%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88' title='썬 마이크로시스템즈'>썬 마이크로시스템즈</a>에서 1995년에 개발한 <a class='wiki-link-internal' href='/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D' title='객체 지향 프로그래밍'>객체 지향</a> <a class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'>프로그래밍 언어</a>. 창시자는 <a class='wiki-link-internal' href='/w/%EC%A0%9C%EC%9E%84%EC%8A%A4%20%EA%B3%A0%EC%8A%AC%EB%A7%81' title='제임스 고슬링'>제임스 고슬링</a>이다. 2010년에 <a class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'>오라클</a>이 <a class='wiki-link-internal' href='/w/%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88' title='썬 마이크로시스템즈'>썬 마이크로시스템즈</a>을 인수하면서 Java의 저작권을 소유하였다. 현재는 OpenJDK는 GPL2이나 <a class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'>오라클</a>이 배포하는 Oracle JDK는 상업라이선스로 <del>오라클이 돈독 올랐는지</del> 2019년 1월부터 유료화정책을 강화하고 있다. Java EE는 <a class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'>이클립스</a> 재단의 소유이다. Java 언어는 J2SE 1.4부터는 Java Community Process (JCP)에서 개발을 주도하고 있다.<br><br><a class='wiki-link-internal' href='/w/C%23' title='C#'>C#</a>과 문법적 성향이 굉장히 비슷하며<a class='wiki-fn-content' title='당장 저기서 package문을 using문으로 System.out.println를 Console.WriteLine으로 바꾸기만 해도 완벽한 C# 코드가 된다.(...)' href='#fn-1'><span class='target' id='rfn-1'></span>&#91;1&#93;</a><a class='wiki-fn-content' title='그도 그럴 것이, 원래 C#이 MS에서 Java의 기본적인 성질은 가져가지만, 각종 문제들을 해결한 언어이기 때문이다.' href='#fn-2'><span class='target' id='rfn-2'></span>&#91;2&#93;</a>, 그에 비해 2019년 Q3에서 가장 많이 이용하는 언어로 뽑혔다. <strong>Javascript와는 다르다.</strong></div></div><h2 class='wiki-heading'><a id='s-2' href='#toc'>2.</a> <span id='어원'>어원<span class='wiki-edit-section'><a href='/edit/Java?section=2' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>처음엔 고슬링 사무실 앞에 있는 <a class='wiki-link-internal' href='/w/%EC%B0%B8%EB%82%98%EB%AC%B4' title='참나무'>참나무</a>에서 따와 OAK로 지었다가 그대로 <a class='wiki-link-internal' href='/w/%EC%83%81%ED%91%9C%EA%B6%8C' title='상표권'>상표로 등록</a>하기엔 문제가 생겨서<a class='wiki-fn-content' title='일반명사나 이미 널리 알려진 표현 등은 상표로 등록 못한다. 물론 상표 등록을 못해도 제품이나 서비스 이름으로 못 쓰는 건 아니지만 해당 이름에 대해 배타적·독점적 권리를 확보하지 못한 상태가 돼서, 남들이 따라 해도 거기에 법적으로 태클을 걸 수가 없다.' href='#fn-3'><span class='target' id='rfn-3'></span>&#91;3&#93;</a> 컨설턴트가 극단적인 방법을 도입, 오후에 개발진들을 회의실에 <a class='wiki-link-internal' href='/w/%ED%86%B5%EC%A1%B0%EB%A6%BC(%EC%9D%80%EC%96%B4)' title='통조림(은어)'>가둬서</a>(...) <a class='wiki-link-internal' href='/w/%EB%B8%8C%EB%A0%88%EC%9D%B8%EC%8A%A4%ED%86%A0%EB%B0%8D' title='브레인스토밍'>브레인스토밍</a>을 시켰다. &quot;기분이 어떤가요&quot;(Excited!), &quot;무엇이 당신 기분을 좋게 만드나요?&quot;(Java coffee!) 같은 연상적인 작용을 거쳐 여러가지 이름을 정하고, 그 중에서 <a class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%20%EC%84%AC' title='자바 섬'>자바</a> <a class='wiki-link-internal' href='/w/%EC%BB%A4%ED%94%BC' title='커피'>커피</a>의 Java를 선택했다. Java는 랭킹 중 네 번째. 리스트의 첫 번째 이름은 Silk였고 고슬링이 가장 좋아했던 이름은 Lyrics, 세 번째에 올라왔던 이름이라고.<br><br>개발진이 자바산 커피를 좋아해서 그랬다는 설도 있다. 아이콘도 커피잔 모양. 또는 개발자의 이름인 <strong>J</strong>ames Gosling, <strong>A</strong>rthur <strong>V</strong>an Hoff, <strong>A</strong>ndy Bechtolsheim의 머릿글자를 따온 것이라는 설도 있고, 그냥 사전을 펼쳤는데 눈에 들어온 이름이었다는 설도 있다. 그런데 막 지은 것 치고는 크게 흥하여 썬이 자사의 <a class='wiki-link-internal' href='/w/%EB%82%98%EC%8A%A4%EB%8B%A5' title='나스닥'>나스닥</a> 코드를 SUNW에서 JAVA로 바꾸었을 정도로 이제는 썬의 상징이자, <del>근데 그 썬이 <a class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'>오라클</a>에 인수돼서 사라진 건 함정</del> 세계적으로도 널리 알려진 단어가 되었다. <a class='wiki-link-external' href='http://www.javaworld.com/community/node/6242' target='_blank' rel='nofollow noopener' title='http://www.javaworld.com/community/node/6242'>출처</a></div></div><h2 class='wiki-heading'><a id='s-3' href='#toc'>3.</a> <span id='분류'>분류<span class='wiki-edit-section'><a href='/edit/Java?section=3' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>Java는 크게 다음과 같은 4가지 에디션으로 나뉜다.<br></div><ul class='wiki-list'><li><div class='wiki-paragraph'>Java SE(Java Standard Edition / J2SE)<br>대부분의 사람들이 가장 많이 접하는 표준 에디션. Java의 핵심 API와 기능들을 제공한다. <a class='wiki-link-internal' href='/w/JDK' title='JDK'>JDK</a> 항목도 참고.</div></li><li><div class='wiki-paragraph'>Jakarta EE, 구 Java EE(Java Enterprise Edition / J2EE)<br>기업에서 운영하는 서버 페이지에 특화된 에디션이다. <a class='wiki-link-internal' href='/w/JSP' title='JSP'>JSP</a>와 서블릿을 비롯한 웹 애플리케이션 서버에 관련된 기술들이 포함되어 있다.</div></li><li><div class='wiki-paragraph'>Java ME(Java Micro Edition / J2ME)<br>PDA나 셋톱박스, 센서 등의 <a class='wiki-link-internal' href='/w/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%EC%8B%9C%EC%8A%A4%ED%85%9C' title='임베디드 시스템'>임베디드 시스템</a> 환경에 특화된 에디션이다.</div></li><li><div class='wiki-paragraph'>JavaFX<br>데스크톱 애플리케이션 개발 및 배포를 위한 에디션으로, 크로스플랫폼 이식과 <a class='wiki-link-internal' href='/w/GUI' title='GUI'>GUI</a> 라이브러리를 제공한다.</div></li></ul></div><h2 class='wiki-heading'><a id='s-4' href='#toc'>4.</a> <span id='역사'>역사<span class='wiki-edit-section'><a href='/edit/Java?section=4' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>버전 정보와 날짜만 확인한다면, <a class='wiki-link-internal' href='/w/Java/%EB%B2%84%EC%A0%84%20%EC%A0%95%EB%B3%B4' title='Java/버전 정보'>Java/버전 정보</a> 문서 참조.<br></div></div><h3 class='wiki-heading'><a id='s-4.1' href='#toc'>4.1.</a> <span id='JDK 1.0a'>JDK 1.0a<span class='wiki-edit-section'><a href='/edit/Java?section=5' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>1994년 발표.</div></div><h3 class='wiki-heading'><a id='s-4.2' href='#toc'>4.2.</a> <span id='JDK 1.0a2'>JDK 1.0a2<span class='wiki-edit-section'><a href='/edit/Java?section=6' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>1995년 5월 23일 발표. 언어 자체가 정식으로 발표된 날이기도 하다.</div></div><h3 class='wiki-heading'><a id='s-4.3' href='#toc'>4.3.</a> <span id='JDK 1.0'>JDK 1.0<span class='wiki-edit-section'><a href='/edit/Java?section=7' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>1996년 1월 23일 발표. 발표 이전에 불렸던 이름은 Oak였으며, 안정화 작업을 거친 1.0.2 버전에서 Java로 이름이 바뀌었다.</div></div><h3 class='wiki-heading'><a id='s-4.4' href='#toc'>4.4.</a> <span id='JDK 1.1'>JDK 1.1<span class='wiki-edit-section'><a href='/edit/Java?section=8' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>1997년 2월 19일 발표. 이너 클래스, JavaBeans, RMI, 리플렉션, <a class='wiki-link-internal' href='/w/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C' title='유니코드'>유니코드</a> 지원, 국제화(Internationalization) 등이 추가되었다.</div></div><h3 class='wiki-heading'><a id='s-4.5' href='#toc'>4.5.</a> <span id='J2SE 1.2'>J2SE 1.2<span class='wiki-edit-section'><a href='/edit/Java?section=9' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>1998년 12월 8일 발표. 일반 지원은 2003년 11월에 종료되었다. 새로운 GUI, JIT, CORBA 등의 굵직한 기능이 추가되면서 2 부터 약칭을 J2SE(Java 2 Standard Edition) 로 표기하기 시작했으며, 이 표기는 5 까지 사용된다. strictfp, Swing GUI, <a class='wiki-link-internal' href='/w/JIT' title='JIT'>JIT</a>, <a class='wiki-link-internal' href='/w/Java%20Applet' title='Java Applet'>Java Applet</a>을 구동하는 웹 브라우저 플러그인, CORBA, Collections 등이 추가되었다. 1999년에 업데이트를 통해 HotSpot JVM이 첫 선을 보인다.</div></div><h3 class='wiki-heading'><a id='s-4.6' href='#toc'>4.6.</a> <span id='J2SE 1.3'>J2SE 1.3<span class='wiki-edit-section'><a href='/edit/Java?section=10' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2000년 3월 8일 발표. 일반 지원은 2006년 11월에 종료되었다. HotSpot JVM, JNDI, JPDA, JavaSound 등이 추가되었다. RMI가 CORBA를 지원하도록 변경되었다.</div></div><h3 class='wiki-heading'><a id='s-4.7' href='#toc'>4.7.</a> <span id='J2SE 1.4'>J2SE 1.4<span class='wiki-edit-section'><a href='/edit/Java?section=11' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2002년 2월 6일 발표. 일반 지원<a class='wiki-fn-content' title='Premier Support. 오라클에 비용을 내고 기술 지원을 받는 서비스이다.' href='#fn-4'><span class='target' id='rfn-4'></span>&#91;4&#93;</a>은 2008년 10월, 연장 지원<a class='wiki-fn-content' title='Extended Support. 일반 지원이 종료된 후 추가적인 비용을 지불하여 기술 지원을 더 받을 수 있는 기간이다.' href='#fn-5'><span class='target' id='rfn-5'></span>&#91;5&#93;</a>은 2013년 2월에 종료되었다. assert, <a class='wiki-link-internal' href='/w/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D' title='정규표현식'>정규표현식</a>, <a class='wiki-link-internal' href='/w/IPv6' title='IPv6'>IPv6</a>, Non-Blocking IO, XML API, JCE, JSSE, JAAS, Java Web Start 등이 추가되었다.</div></div><h3 class='wiki-heading'><a id='s-4.8' href='#toc'>4.8.</a> <span id='J2SE 5'>J2SE 5<span class='wiki-edit-section'><a href='/edit/Java?section=12' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2004년 9월 30일 발표. 일반 지원은 2009년 9월, 연장 지원은 2015년 5월에 종료되었다. J2SE 5.0까지 Windows 9x와 Windows NT 4.0이 지원되었다. 이 때부터 버젼 중 앞의 1을 빼버리고 표기하기 시작했다. 그러나 내부적으로는 여전히 1.5, 1.6, 1.7 등으로 데이터가 들어있다. Generics, Annotation, Auto Boxing/Unboxing, Enumeration, 가변 길이 파라미터, Static Import, 새로운 Concurrency API 등이 추가되었다. Java는 표준 입력(stdin) 지원이 시원찮았는데, J2SE 5에 들어서 java.util.Scanner가 추가되면서 이전보다 편하게 표준 입력을 사용할 수 있게 되었다.</div></div><h3 class='wiki-heading'><a id='s-4.9' href='#toc'>4.9.</a> <span id='Java SE 6'>Java SE 6<span class='wiki-edit-section'><a href='/edit/Java?section=13' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2006년 12월 11일 발표. 일반 지원은 2013년 2월에 종료되었으며, 연장 지원은 2018년 12월에 종료되었다. 이 때부터 표기가 J2SE에서 Java SE로 바뀌었다. Scripting Language Support, JDBC 4.0, Java Compiler API, Pluggable Annotation 등이 추가되었다. 스크립팅 언어 지원과 함께 Rhino <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a> 엔진이 기본으로 탑재되었다.</div></div><h3 class='wiki-heading'><a id='s-4.10' href='#toc'>4.10.</a> <span id='Java SE 7'>Java SE 7<span class='wiki-edit-section'><a href='/edit/Java?section=14' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2011년 7월 7일 발표. 일반 지원은 2015년 4월에 종료되었으며, 연장 지원은 2022년 7월에 종료될 예정이다. Dynamic Language 지원, switch문에서 String 사용, try문에서 자동 자원 관리, Diamond Operator &lt;&gt;, 이진수 리터럴, 숫자 리터럴에 _ 지원, 새로운 Concurrency API, 새로운 File NIO 라이브러리, Elliptic Curve Cryptography, Java2D를 위한 XRender, Upstream, Java Deployment Ruleset 등이 추가되었다.</div></div><h3 class='wiki-heading'><a id='s-4.11' href='#toc'>4.11.</a> <span id='Java SE 8'>Java SE 8<span class='wiki-edit-section'><a href='/edit/Java?section=15' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2014년 3월 18일 발표. 일반 지원은 2019년 1월에 종료되었고, 연장 지원은 2023년 9월에 종료될 예정이다. Lambda Expression, Rhino 대신 Nashorn JavaScript 엔진 탑재, Annotation on Java Types, Unsigned Integer 계산, Repeating Annotation, 새로운 날짜와 시간 API(사실상 <a class='wiki-link-external' href='http://www.joda.org/joda-time/' target='_blank' rel='nofollow noopener' title='http://www.joda.org/joda-time/'>JodaTime</a>이라고 보면 된다), Static Link JNI Library, Interface Default Method, PermGen 영역 삭제, Stream API 등이 추가되었다. 본래 일반 지원은 2017년 9월 종료 예정이었으나 Java 9 발표의 지연 때문에 2018년 9월로 연장되었다가, 이후 라이선스 이관 문제로 인해 2019년 1월로 다시 연장되었다.<br><br>32비트를 지원하는 마지막 공식 Java 버전으로, 이후 버전의 32비트 지원은 오직 서드파티를 통해서만 지원된다.</div></div><h3 class='wiki-heading'><a id='s-4.12' href='#toc'>4.12.</a> <span id='Java SE 9'>Java SE 9<span class='wiki-edit-section'><a href='/edit/Java?section=16' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2017년 9월 21일 발표. 일반 지원은 2018년 3월에 종료되었다.<br><br>Project Jigsaw 기반으로 런타임이 모듈화된 것이 가장 큰 특징. 이에 따라 대부분의 콘솔 프로그램 개발에는 더 이상 AWT나 Swing 같은 불필요한 라이브러리를 끌어쓸 필요도 없이, 최상위 모듈인 Base만 사용해도 된다. 더불어 특정 프로그램에 최적화된 최소 런타임을 제작할 수 있게 되면서 패키징 역시 간편해졌다.<br><br>여기에 Java를 인터프리터 언어 셸처럼 사용할 수 있는 JShell이 추가되었으며, Java 바이트코드를 기계어로 미리 번역하는 선행 컴파일(Ahead-Of-Time Compilation) 역시 실험 기능으로 추가되었다.<a class='wiki-fn-content' title='GCC 계열 Java 컴파일러인 GCJ에서는 이미 지원하고 있던 기능이다.(현재는 출시 중단)' href='#fn-6'><span class='target' id='rfn-6'></span>&#91;6&#93;</a> 또한 Deprecated 표시에는 해당 버전과 제거 예정 여부를 표시할 수 있게 되었다. 그 외에 구조적 불변 컬렉션, 통합 로깅, HTTP/2, private 인터페이스 메소드, HTML5 Javadoc 등도 지원되며, 프로퍼티 파일에 <a class='wiki-link-internal' href='/w/UTF-8' title='UTF-8'>UTF-8</a>이 지원됨에 따라 더 이상 인코딩 문제로 삽질할 필요가 없어졌다. 또한 <a class='wiki-link-internal' href='/w/Java%20Applet' title='Java Applet'>Java Applet</a> 기능은 지원이 종료된다.<br><br>새로 적용된 버저닝 정책에 따라 이 버전부터는 더 이상 1.x 버전으로 내놓지 않고, 대신 <strong>9.0</strong>으로 급속한 판올림이 일어났다. 또한 제거 예정인 Deprecated API는 <strong>다음 버전인 Java SE 10부터 완전 삭제 예정</strong>이므로 해당 API를 쓰는 프로그램은 더 이상 이후의 버전에서 컴파일조차 불가능하게 된다. 그리고 Java SE 9부터는 6개월마다 새로운 버전이 업데이트된다.<br><br>본래는 2016년 발표 예정이었으나 2번이나 연기되어 2017년 7월 27일 발표 예정, 그나마도 한번 더 연기되어 9월 21일에 발표되었다. 가장 큰 원인은 역시 Project Jigsaw의 개발 난이도였다. 런타임의 모듈화는 하위 호환성을 어느 정도 포기하고 성능을 추구한 것이기에 아직 현장에서는 Java 9로 넘어가는 것을 꺼리는 분위기다.<br><br>이 버전부터 64비트 버전만 출시되었으며, 32비트 버전은 더 이상 공식적으로 나오지 않는다.</div></div><h3 class='wiki-heading'><a id='s-4.13' href='#toc'>4.13.</a> <span id='Java SE 10'>Java SE 10<span class='wiki-edit-section'><a href='/edit/Java?section=17' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2018년 3월 20일 발표. 일반 지원은 2018년 9월에 종료되었다. var 키워드를 이용한 지역 변수 타입 추론<a class='wiki-fn-content' title='C#의 var와 똑같은 기능이다.' href='#fn-7'><span class='target' id='rfn-7'></span>&#91;7&#93;</a>, 병렬 처리 가비지 컬렉션, 개별 쓰레드로 분리된 Stop-The-World, 루트 CA 목록 등이 추가되었다. 또한 JDK의 레포지토리가 하나로 통합되었으며, JVM 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당할 수 있게 되었다. 실험 기능으로 Java 기반의 JIT 컴파일러가 추가되었고, 이전 버전에서 Deprecated 처리된 API는 Java SE 10에서 모두 삭제되었다.</div></div><h3 class='wiki-heading'><a id='s-4.14' href='#toc'>4.14.</a> <span id='Java SE 11'>Java SE 11<span class='wiki-edit-section'><a href='/edit/Java?section=18' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2018년 9월 25일 발표. 일반 지원은 2023년 9월, 연장 지원은 2026년 9월에 종료될 예정이다. <a class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'>이클립스</a> 재단으로 넘어간 Java EE가 JDK에서 삭제되고, JavaFX도 JDK에서 분리되어 별도의 모듈로 제공된다. <a class='wiki-link-external' href='https://www.infoworld.com/article/3261066/java/javafx-will-be-removed-from-the-java-jdk.html' target='_blank' rel='nofollow noopener' title='https://www.infoworld.com/article/3261066/java/javafx-will-be-removed-from-the-java-jdk.html'>#</a><a class='wiki-fn-content' title='따라서 이전 버전과 호환이 안 될 가능성도 있다. 이전 버전에서는 그냥 내부 메소드 쓰듯이 JavaFX를 갖다 썼다면, 이제는 라이브러리를 따로 인클루드해서 배포해야 하기 때문.' href='#fn-8'><span class='target' id='rfn-8'></span>&#91;8&#93;</a> Gloun이라는 업체가 JavaFX를 유지보수 중이므로 <a class='wiki-link-external' href='https://gluonhq.com/products/javafx/' target='_blank' rel='nofollow noopener' title='https://gluonhq.com/products/javafx/'>이곳</a>에서 다운로드받으면 된다. 람다 파라미터에 대한 지역 변수 문법<a class='wiki-fn-content' title='&#39;@Nonnull var x, @Nullable var y&#39;를 &#39;x.process(y)&#39;로 간략화할 수 있게 되었다.' href='#fn-9'><span class='target' id='rfn-9'></span>&#91;9&#93;</a>, 엡실론 가비지 컬렉터, HTTP 클라이언트 표준화 등의 기능이 추가되었다.<br><br>가장 커다란 변화는 바로 라이선스 부분. Java SE 11부터 Oracle JDK의 독점 기능이 <a class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%20%EC%86%8C%EC%8A%A4' title='오픈 소스'>오픈 소스</a> 버전인 OpenJDK에 이식된다. 이는 다시 말해 Oracle JDK와 OpenJDK가 완전히 <strong>동일</strong>해진다는 뜻이다. Oracle JDK는 Java SE 11부터 LTS(장기 지원) 버전으로 3년마다 출시되는데, 출시 후 5년 동안 오라클의 기술 지원이 제공되고 최대 3년까지 지원 기간을 연장할 수 있다. Oracle JDK는 이제 3년에 한 번 출시되니 Java의 실질적인 버전 업을 담당하는 것은 OpenJDK가 된 셈이다. OpenJDK는 기업들을 위한 기술 지원은 없고, 새로운 버전이 나오면 이전 버전에 대한 마이너 업데이트와 보안 업데이트는 중단된다.<br><br>그리고 Java 11과 함께 발표된 또 다른 소식은 바로 <strong>Oracle JDK가 구독형 유료 모델로 전환된다는 점</strong>이다. <a class='wiki-link-external' href='http://www.ddaily.co.kr/news/article.html?no=171602' target='_blank' rel='nofollow noopener' title='http://www.ddaily.co.kr/news/article.html?no=171602'>#</a> 2019년 1월부터 오라클이 제공하는 모든 Oracle JDK는 유료화되며, 구독권을 구입하지 않으면 Oracle JDK에 접근 자체가 금지된다. 기존의 일반/연장 지원 서비스는 구독권에 포함되므로 별도의 서비스로는 제공되지 않는다. <strong>개인 사용자는 2021년 1월부터 비용을 지불해야 한다.</strong> 이 때문에 많은 기업들이 Oracle JDK에서 발을 빼고 있으며, OpenJDK를 기반으로 한 다른 서드파티 JDK가 대안으로 떠오르고 있다. 대표적인 예로 Azul Systems에서 개발한 <a class='wiki-link-external' href='https://www.azul.com/downloads/zulu/' target='_blank' rel='nofollow noopener' title='https://www.azul.com/downloads/zulu/'>Zulu JDK</a>가 있는데, Zulu JDK는 오라클의 TCK(Technology Certification Kit) 인증을 받은 구현체이다. 개인과 기업 모두 무료로 사용할 수 있고, 기술 지원에 한해서만 유료 서비스가 제공된다. 또 다른 대안으로는 <a class='wiki-link-external' href='https://adoptopenjdk.net/' target='_blank' rel='nofollow noopener' title='https://adoptopenjdk.net/'>AdoptOpenJDK</a>가 있는데, AdoptOpenJDK는 HotSpot VM 대신 Eclipse OpenJ9을 탑재한 버전도 같이 제공하고 있다. 다만 아직 TCK 인증을 받지 않았기에 주의가 필요하다.</div></div><h3 class='wiki-heading'><a id='s-4.15' href='#toc'>4.15.</a> <span id='Java SE 12'>Java SE 12<span class='wiki-edit-section'><a href='/edit/Java?section=19' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2019년 3월 19일 공개. 특징 중 하나로 문법적으로 Switch문을 확장한 것이 있다.(<a class='wiki-link-external' href='https://openjdk.java.net/jeps/325' target='_blank' rel='nofollow noopener' title='https://openjdk.java.net/jeps/325'>출처</a>)</div><div class='wiki-indent'><div class='wiki-paragraph'><pre><code class="syntax" data-language="java"><span class="syntax-keyword">switch</span> (day) {
    <span class="syntax-keyword">case</span> MONDAY:
    <span class="syntax-keyword">case</span> FRIDAY:
    <span class="syntax-keyword">case</span> SUNDAY:
        System.out.println(<span class="syntax-literal">6</span>);
        <span class="syntax-keyword">break</span>;
    <span class="syntax-keyword">case</span> TUESDAY:
        System.out.println(<span class="syntax-literal">7</span>);
        <span class="syntax-keyword">break</span>;
    <span class="syntax-keyword">case</span> THURSDAY:
    <span class="syntax-keyword">case</span> SATURDAY:
        System.out.println(<span class="syntax-literal">8</span>);
        <span class="syntax-keyword">break</span>;
    <span class="syntax-keyword">case</span> WEDNESDAY:
        System.out.println(<span class="syntax-literal">9</span>);
        <span class="syntax-keyword">break</span>;
}</code></pre><br>예전에는 이렇게 써야 했던 Switch문을 아래와 같은 형식으로도 쓸 수 있게 되었다.<br><pre><code class="syntax" data-language="java"><span class="syntax-keyword">switch</span> (day) {
    <span class="syntax-keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="syntax-literal">6</span>);
    <span class="syntax-keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="syntax-literal">7</span>);
    <span class="syntax-keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="syntax-literal">8</span>);
    <span class="syntax-keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="syntax-literal">9</span>);
}</code></pre></div></div><div class='wiki-paragraph'>이외에 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선의 변경점이 있다.</div></div><h3 class='wiki-heading'><a id='s-4.16' href='#toc'>4.16.</a> <span id='Java SE 13'>Java SE 13<span class='wiki-edit-section'><a href='/edit/Java?section=20' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2019년 9월 17일 공개. java 12에서의 스위치 개선을 이어 yield 라는 예약어가 추가되었다.<br><pre><code class="syntax" data-language="java"><span class="syntax-keyword">var</span> a = <span class="syntax-keyword">switch</span> (day) {
    <span class="syntax-keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; yield <span class="syntax-literal">6</span>;
    <span class="syntax-keyword">case</span> TUESDAY                -&gt; yield <span class="syntax-literal">7</span>;
    <span class="syntax-keyword">case</span> THURSDAY, SATURDAY     -&gt; yield <span class="syntax-literal">8</span>;
    <span class="syntax-keyword">case</span> WEDNESDAY              -&gt; yield <span class="syntax-literal">9</span>;
};</code></pre></div></div><h3 class='wiki-heading'><a id='s-4.17' href='#toc'>4.17.</a> <span id='Java SE 14'>Java SE 14<span class='wiki-edit-section'><a href='/edit/Java?section=21' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2020년 3월 18일 공개. 프리뷰 기능으로 instanceof의 패턴 매칭과 record라는 데이터 오브젝트 선언이 추가되었다. 그 외에 인큐베이터라는 패키징 툴(OS에 맞춘 실행파일 생성기능) 추가 등이 있다.<br><br>instanceof 패턴 매칭<br><pre><code class="syntax" data-language="java"><span class="syntax-keyword">if</span> (!(obj <span class="syntax-keyword">instanceof</span> String s)) {
    .. s.contains(..) ..
} <span class="syntax-keyword">else</span> {
    .. s.contains(..) ..
}</code></pre><br><br>record<br><pre><code class="syntax" data-language="java">record Point(<span class="syntax-keyword">int</span> x, <span class="syntax-keyword">int</span> y) { }</code></pre></div></div><h3 class='wiki-heading'><a id='s-4.18' href='#toc'>4.18.</a> <span id='Java SE 15'>Java SE 15<span class='wiki-edit-section'><a href='/edit/Java?section=22' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>2020년 9월 공개 예정.</div></div><h2 class='wiki-heading'><a id='s-5' href='#toc'>5.</a> <span id='문법'><a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'>문법</a><span class='wiki-edit-section'><a href='/edit/Java?section=23' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%EC%83%81%EC%84%B8%EB%82%B4%EC%9A%A9.png' title='파일:나무위키상세내용.png' rel='nofollow'><span class='wiki-image-align-left' style='width:21px;'><span class='wiki-image-wrapper' style='width: 100%;'><img class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='><img class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='50826' data-src='//w.namu.la/s/7ada8e25f0e5a43b01ab96c3a2c3bb02c994664e3fd7da42de7482f13ef25356afcdf908e8312492cc5230ce8e38b0eeb434abf222bab4c4ad68ecd8c9ee2c90c163a0b9ce63ed49e1b7f0942e8efef2aafa70bdd0315e2ae2db231690ecd21e' alt='파일:나무위키상세내용.png'><noscript><img class='wiki-image' width='100%' src='//w.namu.la/s/7ada8e25f0e5a43b01ab96c3a2c3bb02c994664e3fd7da42de7482f13ef25356afcdf908e8312492cc5230ce8e38b0eeb434abf222bab4c4ad68ecd8c9ee2c90c163a0b9ce63ed49e1b7f0942e8efef2aafa70bdd0315e2ae2db231690ecd21e' alt='파일:나무위키상세내용.png'></noscript></span></span></a>  자세한 내용은 <a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'>Java/문법</a> 문서<div style="display:none;display:inline">를</div><div style="display:none;display:inline;display:none">의 <a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95#s-' title='Java/문법'>번째 문단</a>을</div><div style="display:inline;display:none">의 <a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'></a><a class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'></a> 부분을</div> 참고하십시오.</div></div><h2 class='wiki-heading'><a id='s-6' href='#toc'>6.</a> <span id='C, C++와의 비교'>C, C++와의 비교<span class='wiki-edit-section'><a href='/edit/Java?section=24' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>기존의 <a class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'>C</a>에 객체지향 기능을 추가하다 보니, 언어의 사용에 있어 저수준과 고수준의 개념이 충돌하는 부분이 많았던 <a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a>과는 다르게 아예 처음부터 <a class='wiki-link-internal' href='/w/OOP' title='OOP'>객체지향</a> 언어로 개발되었다. 다만 많은 사람들이 착각하는 부분인데, Java는 엄밀히 말하면 완벽한 객체지향 언어가 아니다. 원시(Primitive) 타입은 객체로 취급하지 않기 때문. 모든 것을 객체로 취급하는 언어를 순수 객체지향(Pure object-oriented)이라 하며, 이를 지원하는 언어로는 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a>, <a class='wiki-link-internal' href='/w/Ruby' title='Ruby'>Ruby</a>, <a class='wiki-link-internal' href='/w/Smalltalk' title='Smalltalk'>Smalltalk</a>등이 있다.<br><br>C, C++, Java의 차이점을 말하자면, C는 포인터 등을 활용한 저수준 시스템 프로그래밍에<a class='wiki-fn-content' title='리눅스 커널, 하드웨어 프로그래밍' href='#fn-10'><span class='target' id='rfn-10'></span>&#91;10&#93;</a> 강점을 가지며, C++는 C의 그런 강점을 거의 그대로 가져오면서 거기에 객체 지향이나 일반화 프로그래밍과 같은 멀티 패러다임을 지원하고자 하는 시도<a class='wiki-fn-content' title='3D 게임, 그래픽 프로그래밍' href='#fn-11'><span class='target' id='rfn-11'></span>&#91;11&#93;</a>에서 탄생하였다. 이렇게 고수준과 저수준의 개념을 모두 포함하려다 보니 다른 언어에 비해서 상당히 복잡해졌다. 게다가 최신 프로그래밍 환경을 지원하기 위해 지속적으로 개정되고 있는 모던 C++는 변화의 폭이 커서, 새로운 기능을 전부 제대로 다룰 줄 아는 프로그래머는 비교적 적다는 평이 널리 받아들여지고 있다. 이와는 대조적으로 Java는 C++의 초기 발전 방향과는 달리 안정성을 위해 포인터라는 강력한 로우 레벨 기능을 포기하고 가비지 컬렉터를 내장하며, 고수준의 객체지향 부분을 잘 구현하는 것에 집중하는 방식으로 언어가 복잡해지는 것을 방지하였다.<br><br>수많은 <a class='wiki-link-external' href='https://en.wikipedia.org/wiki/List_of_C-family_programming_languages' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/List_of_C-family_programming_languages'>C계열 프로그래밍 언어</a>가 그렇듯이, C/C++와 비슷한 문법 구조를 가지고 있다. 그러면서도 Java가 C/C++보다 훨씬 더 널리 쓰이는 분야가 많이 존재한다. 웹 애플리케이션 백엔드와 <a class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'>안드로이드</a> 앱이 대표적인 사례. 또한 <a class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'>아파치 소프트웨어 재단</a>에서 개발하는 수많은 <a class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%20%EC%86%8C%EC%8A%A4' title='오픈 소스'>오픈 소스</a> 소프트웨어들이 Java로 만들어졌다. 하지만 Java 프로그램에서 속도가 매우 중요시되는 부분은 따로 떼어서 C/C++로 개발하기도 한다. 제작하고자 하는 프로그램의 생산성과 성능을 적절히 고려하여 선택하는 것이 현명하다.</div></div><h2 class='wiki-heading'><a id='s-7' href='#toc'>7.</a> <span id='특징'>특징<span class='wiki-edit-section'><a href='/edit/Java?section=25' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>Java의 가장 큰 특징은 플랫폼에 독립적인 언어라는 점이다. 소스 코드를 기계어로 직접 컴파일하여 링크하는 C/C++의 컴파일러와 달리 자바 컴파일러는 바이트코드인 클래스 파일(.class)을 생성하고, 이 파일의 바이트코드를 읽은 뒤 기계어로 바꾸어 실행하는 것은 <a class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'>Java Virtual Machine</a>(JVM)이다.<br><br>예를 들어 C 계열 언어들은 <a class='wiki-link-internal' href='/w/Microsoft%20Windows' title='Microsoft Windows'>윈도우</a>에서 빌드한 프로그램을 그대로 <a class='wiki-link-internal' href='/w/%EB%A6%AC%EB%88%85%EC%8A%A4' title='리눅스'>리눅스</a>나 <a class='wiki-link-internal' href='/w/macOS' title='macOS'>macOS</a>에서 실행하려 하면 일반적으로 오류가 나지만 Java로 작성 된 프로그램은 플랫폼에 맞는 JVM만 설치되어 있다면 문제 없이 동작한다. 이는 Java 코드 자체가 플랫폼이 아닌 <a class='wiki-link-internal' href='/w/%EA%B0%80%EC%83%81%EB%A8%B8%EC%8B%A0' title='가상머신'>가상머신</a>에 종속적이라는 점, 그리고 프로그램 실행의 주체가 운영체제가 아닌 JVM이라는 점 때문이며 이러한 점을 통틀어 Java는 플랫폼 종속성이 낮은 언어라고 표현한다.<br><br>JVM 기반의 프로젝트에서는 하나의 언어만을 고집하지 않는다. 함수형 언어가 유리(최근 유행하는 빅데이터 등)한 부분은 <a class='wiki-link-internal' href='/w/Scala' title='Scala'>Scala</a>로 작업하며, 견고한 인터페이스와 대규모 통합이 필요한 곳은 Java로 작업한 뒤 이들을 서로 합쳐서 운영하는 게 가능하다. (Java에서 만든 객체를 Scala에서 그대로 사용할 수 있다.) <a class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'>안드로이드</a> 쪽에서는 크리티컬하지 않은 부분부터 <a class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'>Kotlin</a>으로 코드를 교체하는 경우도 많아지고 있다.<br><br>실제 현업에서는 Java를 비롯한 여러가지 인기 언어가 자주 사용되므로 장단점을 잘 알아두는게 좋다. 다른 언어에 대해 맹목적으로 찬양/비판하는 태도보다는 환경이나 주어진 작업의 특성에 따라 적합한 언어를 선택할 수 있는 노하우가 필요하다.<br><br>PC에서 자바 런너 업데이트를 할 때 뜨는 창에 &#39;30억개 기기에서 Java 사용&#39;이라는 문구가 나온다.<br></div></div><h3 class='wiki-heading'><a id='s-7.1' href='#toc'>7.1.</a> <span id='장점'>장점<span class='wiki-edit-section'><a href='/edit/Java?section=26' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'></div><h4 class='wiki-heading'><a id='s-7.1.1' href='#toc'>7.1.1.</a> <span id='수많은 개발자와 레퍼런스'>수많은 개발자와 레퍼런스<span class='wiki-edit-section'><a href='/edit/Java?section=27' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>나온지도 오래 되었고, 다른 최신 언어에 비해서 여러가지로 욕을 먹는 Java가 그래도 항상 상위권을 유지하는 이유는 바로 수많은 개발자와 레퍼런스를 보유하고 있다는 점이다. 타 언어를 전문적으로 사용하는 개발자들도 Java 정도는 할 줄 안다고 할 정도로 배우기 쉽고 대중적이다. 대중적인 언어라서 참고 자료나 오픈 소스가 많고, 그러한 자료들을 바탕으로 수많은 대형 프로젝트들이 진행되어왔기 때문에 많은 부분에서 안정성이 입증되었다. 즉, 안정적인 인력풀을 유지하면서, 알려진 위협을 제거하고 운영 노하우를 극대화시킬 수 있는 검증된 언어라는 것.<br><br>하지만 검증되었다는 건 반대로 말하자면 오래되었다는 뜻이기도 하다. 최근에는 Java에 대한 개발자들의 불만이 누적된 탓인지 <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a>나 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a> 같은 다른 언어를 선호하는 경향이 강하다. 국내에서는 <a class='wiki-link-internal' href='/w/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%91%9C%EC%A4%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC' title='전자정부표준프레임워크'>전자정부표준프레임워크</a>의 존재 때문인지 아직도 신규 프로젝트의 주 언어로 Java를 선호하는 경향이 강하지만, 세계적으로는 신규 프로젝트에서 Java를 선호하는 비중은 높지 않은 편이다.<a class='wiki-fn-content' title='특히 웹 개발 분야에서 해외의 경우 Java는 도태되는 추세고, Node.js 덕분에 서버와 프론트엔드 양 쪽에서 쓸 수 있는 JavaScript와 Django를 통하여 쉽고 빠르게 백엔드 구축이 가능한 Python의 사용률이 늘어나고 있다.' href='#fn-12'><span class='target' id='rfn-12'></span>&#91;12&#93;</a><br><br>국내에서의 언어 외적인 장점은 바로 개발자 구인의 용이성이다. 국내에서 Java 개발자의 인력풀이 타 언어보다 더 큰 이유는 앞서 말했던 전자정부표준프레임워크의 존재 때문이기도 하고, 그 때문에 Java 개발자를 정부에서 국비지원으로 대거 양성했기 때문이기도 하다. 상당수의 정부 하청 프로젝트가 Java와 전자정부표준프레임워크로 개발되었다. 이런 이유 때문에 굳이 정부 프로젝트가 아니더라도 Java 개발자를 구인하기 쉬웠고, 더 많은 프로젝트가 Java로 개발되었다. 그리고 그렇게 만들어진 프로젝트를 유지보수하기 위해서 더 많은 Java 개발자가 필요하므로 더 많은 인력이 유입되는 일종의 선순환 효과가 있다. 취업 사이트를 확인해보면 다른 분야보다 Java 개발자를 구인하는 경우가 많은 건 이 때문이다. 사람을 구하기도 쉽고, 직장을 구하기도 쉽다. 영어권 국가에 비해 공유되는 자료가 비교적 부족한 국내에서도 <a class='wiki-link-internal' href='/w/JSP' title='JSP'>JSP</a>, <a class='wiki-link-internal' href='/w/Spring(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)' title='Spring(프레임워크)'>Spring</a>에 관한 자료만큼은 높은 퀄리티를 보여주는 경우가 많다. 그러나 반대로 할 줄 아는 사람들이 너무 많아 경쟁력이 떨어지는 면도 있다. <a class='wiki-link-internal' href='/w/SI' title='SI'>몇몇 회사</a>에서는 Java 개발자에 대한 보수나 기타 대우가 좋지 않은 경우도 많다. 개발자가 많다는 것은 취업이나 구인 면에서는 장점이지만, 다른 측면에서는 단점이 될 수도 있다. <del>버스 기사는 어디에서나 써먹을수 있으며 각계각층에 필요하고 수요와 공급 모두 많고 구직도 쉽고 구인도 쉽고 어쨌든 실업자는 안 되고 어찌됐든 밥벌이는 할 수 있지만 많은 사람들이 하지 않으려는 이유와 대강 비슷하다.</del><br><br>기존의 Java로 만들어진 프로젝트를 재사용하기 위해 Java가 쓰인 대표적인 사례는 카카오뱅크가 있다. 한정된 시간 때문에 Java 코드를 재사용해야 했던 경우다.<a class='wiki-link-external' href='https://byline.network/2017/08/8-2/' target='_blank' rel='nofollow noopener' title='https://byline.network/2017/08/8-2/'>#</a></div></div><h4 class='wiki-heading'><a id='s-7.1.2' href='#toc'>7.1.2.</a> <span id='비교적 높은 생산성'>비교적 높은 생산성<span class='wiki-edit-section'><a href='/edit/Java?section=28' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>오늘날 프로그램의 덩치와 다루는 것들이 크고 복잡해지면서 생산성과 퍼포먼스 문제가 생기게 되었는데, <a class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'>C</a>/<a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a> 같은 언어는 생산성이 너무 떨어지고 관리도 힘들어서 프로그램이 커지면 커질수록 작업이 힘들어지게 된다. 그리고 아무리 컴퓨터 하드웨어가 발달한다고 해도 성능이 더 좋아지면 점점 더 복잡한 것을 다루고, 그것이 새로운 표준이 되면서 하드웨어의 속도 향상이 무색해지기 때문이다.<br><br>그런데, 그 와중에 나타난 게 바로 Java다. C/C++와 비슷한 문법으로 진입 장벽도 낮고, 객체 지향을 적극적으로 사용하며, 로우 레벨 작업들을 자동으로 처리해 주는 하이 레벨 언어이면서, 퍼포먼스도 다른 하이 레벨 언어들에 비해 빠른 편이다. 거기에 호환성까지! 등장하자마자 순식간에 대세가 된 것도 무리는 아니다. 객체지향 등이 일반화되면서 프로그래밍 환경도 점차 중요한 개념을 언어 안으로 숨기고 사용자에겐 그것을 간편히 다룰 수 있는 인터페이스만 제공하는 추세로 흘러가고 있는데, Java는 여기에 정확하게 부합하는 언어였던 것. 다만 최근 인기를 끌고 있는 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a>이나 <a class='wiki-link-internal' href='/w/Go(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Go(프로그래밍 언어)'>Go</a> 같은 언어에 비하면 Java의 생산성은 상대적으로 낮은 편이다.</div></div><h4 class='wiki-heading'><a id='s-7.1.3' href='#toc'>7.1.3.</a> <span id='기기 호환성'>기기 호환성<span class='wiki-edit-section'><a href='/edit/Java?section=29' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>장점으로는, 해당 <a class='wiki-link-internal' href='/w/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C' title='운영체제'>운영체제</a>에 <a class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'>Java Virtual Machine(JVM)</a>을 설치하면 Java로 만든 프로그램은 어떤 컴퓨터에서도 완벽히 똑같이 동작한다. <a class='wiki-link-internal' href='/w/%EA%B0%80%EC%83%81%EB%A8%B8%EC%8B%A0' title='가상머신'>가상머신</a>이 각각의 운영체제에 맞춰서 결과적으로 완벽히 똑같이 돌아갈 수 있도록 제작되는 덕. 가상머신 없는 운영체제라면 아예 Java 프로그램을 사용하지 못하겠지만, 썬 마이크로시스템즈는 주요 OS용의 가상 머신을 발표하고 있고, <a class='wiki-link-internal' href='/w/IBM(%EA%B8%B0%EC%97%85)' title='IBM(기업)'>IBM</a>, <a class='wiki-link-internal' href='/w/%ED%9C%B4%EB%A0%9B%ED%8C%A9%EC%BB%A4%EB%93%9C' title='휴렛팩커드'>휴렛팩커드</a> 등의 회사는 직접 자사 운영체제용 JDK/JVM을 제작하여 발표하며, 이들과 상관없이 독립적으로 특화된 성능향상 기능을 가진 JVM을 만들어서 발표하는 회사도 존재한다. 그래서 이 부분은 보통 단점으로 꼽히지 않는다. 오히려 여러 운영체제에 발 벌리는 업체라면 윈도우용, 맥용 등을 따로 제작할 필요 따위가 없이 &quot;그냥 하나 만들면 끝!&quot;이라고 Java 초창기에 홍보되었다.<br><br>그러나 다른 크로스 플랫폼 언어들과 마찬가지로 각 플랫폼마다 미묘하게 기능이나 작동에 차이가 있는 부분이 결국은 존재하기 때문에, 이러한 부분을 고려하지 않고 작성된 프로그램을 그대로 다른 데에서 돌릴 때에 문제가 발생할 가능성이 존재한다. JVM의 장점은 그나마 이런 부분들이 다른 언어에 비해서 매우 적은 편이라는 점이다. 이런 경우, 대부분 크로스 플랫폼으로 작성된 코드가 그러하듯 타겟 플랫폼을 인지하여 특정 플랫폼에서는 다르게 동작하게 하는 식으로 코딩을 하게 된다. 주로 java.nio 패키지에 속한 API 에서 이러한 경우를 발견할 수 있으며, <a class='wiki-link-internal' href='/w/OS%20X' title='OS X'>OS X</a> 에서만 일부 특이하게 동작하는 MIDI 관련 API 또한 이러한 경우에 속한다. Java의 모토는 Write once, run  everywhere(한 번 짜서, 어디서나 실행하라)인데 프로그래머들은 이를 비꼬아 Write once, <strong>test everywhere</strong>(한 번 짜서, 모든 플랫폼에서 테스트하라)라고 말하곤 한다.<br><br>C나 C++에서도 크로스 플랫폼 형태로 소스코드를 작성하는 것이 가능하기는 했지만, 개발자가 타겟 플랫폼과 해당 플랫폼용 바이너리 코드를 생성하는 컴파일러에 대해서 잘 이해하고 나서 #define, #if 등 전처리기를 써서 각 타겟 플랫폼에 맞게 동작하도록 코드를 직접 작성해줘야 했다. 이와 달리, Java는 단일 소스코드를 컴파일하여 생성된 바이트코드 클래스 파일을 JVM이 존재하는 환경이라면 어디서나 (대부분은) 추가 컴파일이나 수정작업 없이 그대로 똑같이 실행할 수 있다는 점이 차이점이다. 기업 입장에서 컴파일된 <strong>바이너리</strong>가 크로스 플랫폼을 보장해주는 Java는 매력적인 언어였다.<br><br>JVM 위에서 구동 가능한 언어는 Java 외에도 존재하는데, 이 언어들을 사용하면 Java와 동일한 수준의 호환성을 구현할 수 있다.<a class='wiki-fn-content' title='JVM 위에서 구동 가능한 언어에 대해서는 영문 위키피디아의 List of JVM languages 참고.' href='#fn-13'><span class='target' id='rfn-13'></span>&#91;13&#93;</a> 구글에서 안드로이드 개발의 차세대 언어로 밀어주는 <a class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'>Kotlin</a>이 대표적인 케이스다. Java의 개발 주체인 Oracle에서 개발하는 GraalVM이라는 <del><a class='wiki-link-internal' href='/w/%ED%95%9C%EA%B5%AD%EC%96%B4' title='한국어'>한국어</a>에서 자주 쓰이는 <a class='wiki-link-internal' href='/w/%EC%A7%80%EB%9E%84' title='지랄'>어떤 욕설</a>과 관계 없다</del> 프레임워크도 있다. 이 프레임워크에서는 <a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a>도 JVM 위에서 실행하는 것이 가능하다.<br><br>요즘은 하드웨어와 밀접하게 연동되어야 하는 프로그램이 아니라면, 또는 메인 로직은 서버에서 돌아가고 클라이언트에서는 인터페이스만 제공해주면 되는 경우라면 JVM보다는 웹 기술을 이용한 방식이 더 주목받고 있다. 아예 어디에서나 동일한 동작을 보증하는 웹 사이트의 형식으로 서비스를 하거나, 네이티브 앱의 UI가 필요한 경우에는 <a class='wiki-link-internal' href='/w/React(%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)' title='React(라이브러리)'>React Native</a> 또는 <a class='wiki-link-internal' href='/w/Flutter(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)' title='Flutter(프레임워크)'>Flutter</a> 등의 프레임워크를 이용하는 경우가 많다. 전자는 웹 개발에서 주로 쓰이는 <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a>를 이용하고, 후자는 구글에서 웹 프로그래밍의 용도로 만든 <a class='wiki-link-internal' href='/w/Dart(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Dart(프로그래밍 언어)'>Dart</a>라는 언어를 이용한다. 이 외에 게임이나 3D 렌더링이 필요한 앱의 경우 <a class='wiki-link-internal' href='/w/%EA%B2%8C%EC%9E%84%20%EC%97%94%EC%A7%84' title='게임 엔진'>게임 엔진</a>을 이용한다.</div></div><h4 class='wiki-heading'><a id='s-7.1.4' href='#toc'>7.1.4.</a> <span id='안정성'>안정성<span class='wiki-edit-section'><a href='/edit/Java?section=30' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>다른 언어에 비해 높은 안정성을 꼽고 있다. 우선 C나 C++에 안정성 문제가 제기되는 포인터 연산자<a class='wiki-fn-content' title='정말로 포인터를 써야 할 경우 Unsafe 클래스를 쓰면 된다. 다만 팩토리 메소드가 막혀있어 리플렉션을 사용해야만 이용할 수 있다.' href='#fn-14'><span class='target' id='rfn-14'></span>&#91;14&#93;</a> 및 메모리 직접접근 함수들을 지원하지 않는다. 여기에 C++과는 다르게 다중 <a class='wiki-link-internal' href='/w/%EC%83%81%EC%86%8D(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)' title='상속(프로그래밍)'>상속</a>을 허용하지 않는다. 이는 객체지향의 특성 중 하나인 &#39;상속&#39;의 자유도를 확 떨어트리는 것이기에 언뜻 보기에는 객체지향적 관점에 위배되는 것처럼 보일 수 있으나, 반대로 오히려 이게 더 객체지향적이라고 볼 수도 있다. 객체지향의 목적 자체가 재사용을 통한 생산성의 향상과 관리 상의 이점인데, 다중 상속은 잘못 사용할 시 극도로 복잡하게 꼬인 프로그램을 만들 위험성을 갖고 있다. 물론 코드 관리의 측면에서도 다중상속에 의해 발생하는 문제는 좋지 않다. 수준 높은 프로그래머라면 이 문제도 잘 해결할 수 있지만, Java는 아예 미연에 방지하기 위해 다중상속을 언어 스펙에서 제거하는 방법을 택했다.<a class='wiki-fn-content' title='어차피 Java에서는 다중 상속을 포기함으로써 생기는 문제를 interface를 다중 구현할 수 있도록 하여 어느 정도 해결하기도 했다.' href='#fn-15'><span class='target' id='rfn-15'></span>&#91;15&#93;</a><br><br>메모리를 대용량으로 사용하는 프로그램에서 상대적으로 C/C++보다 안정적인 모습을 보일 때도 있는데, 이런 경우에 <a class='wiki-link-internal' href='/w/JVM' title='JVM'>JVM</a>이 시작될 때 필요한 메모리를 먼저 통으로 잡아버리기 때문이다. 메모리를 자주 할당하거나 해제하는 C/C++ 프로그램은 오히려 Java보다 성능이 느릴 수 있다. 다만 이는 메모리 할당자 없이 매번 힙 영역 메모리를 운영체제로부터 할당받는 경우에 해당하는 말이고<a class='wiki-fn-content' title='쉽게 생각하면 배열 1000개를 할당받기 위해 운영체제에 1번 호출하여 한꺼번에 할당받지 않고, 1000번 호출하여 각각 할당받는 것이다. 기본적으로, 동적 메모리 할당은 운영체제에서 처리하기 때문에 속도가 느리다. 어떤 언어에서라도, 운영체제의 메모리 할당 횟수를 줄이는 것이 성능에 도움이 된다.' href='#fn-16'><span class='target' id='rfn-16'></span>&#91;16&#93;</a>, 실제 C/C++ 프로젝트에서는 jemalloc 등 메모리 할당자 라이브러리를 사용하거나 메모리 할당자를 직접 구현하여 이런 문제를 해결하는 것이 일반적이다.</div></div><h4 class='wiki-heading'><a id='s-7.1.5' href='#toc'>7.1.5.</a> <span id='소스 코드 가독성'>소스 코드 가독성<span class='wiki-edit-section'><a href='/edit/Java?section=31' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>고급 프로그래밍 언어가 만들어진 첫째 목적은 &#39;좀 더 인간 친화적인&#39; 코드의 작성을 돕는 데 있다. <a class='wiki-link-internal' href='/w/%EA%B8%B0%EA%B3%84%EC%96%B4' title='기계어'>기계어</a>가 <a class='wiki-link-internal' href='/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4' title='어셈블리어'>어셈블리어</a>로 진화하고 그것이 <a class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'>C언어</a>로 진화한 배경에는 &#39;사람이 더 쉽게 읽고 이해할 수 있는 코드&#39;가 있다. Java는 동시기에 발표된 다른 언어에 비해 코드가 명료하고 가독성이 뛰어났다. <a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a>은 어려운 문법으로 인해 코드가 이리저리 꼬이는 경우가 많고, 특히 연산자 오버로딩과 <a class='wiki-link-internal' href='/w/%ED%85%9C%ED%94%8C%EB%A6%BF' title='템플릿'>템플릿</a> 기반의 <a class='wiki-link-internal' href='/w/C%2B%2B#s-4' title='C++'>일반화 프로그래밍(Generic Programming)</a> 개념이 코드 난독화에 결정타를 날렸는데 Java는 연산자 오버로딩을 배제하고 오로지 <strong><a class='wiki-link-internal' href='/w/%EB%A9%94%EC%86%8C%EB%93%9C' title='메소드'>메소드</a></strong>를 통해서만 객체의 조작을 허용함으로써 코드의 일관성을 지켜냈다.<a class='wiki-fn-content' title='하지만 연산자 오버로딩은 분명 제네릭 프로그래밍에 도움을 준다. 가령 제네릭 클래스 내에서 주어진 타입의 변수 두 개를 더하는 연산을 하고 싶다면? 더하는 연산 등 여러 일반적인 작업들은 Java의 primitive 타입에만 필요한 것은 아니다. 행렬 등이 그런 대표적인 예다. 이러한 측면에서 본다면 프로그래머의 작업에 있어서의 일관성은 훼손됐다고 볼 수도 있다.' href='#fn-17'><span class='target' id='rfn-17'></span>&#91;17&#93;</a><br><br><a class='wiki-link-internal' href='/w/%ED%85%9C%ED%94%8C%EB%A6%BF#s-6' title='템플릿'>C++ 템플릿</a> 프로그래밍의 주 사용 용도인 일반화 프로그래밍도 <strong>제네릭</strong>이라는 더 쉬운 개념을 도입해서(Java 5부터 지원) 코드의 가독성을 해치지 않고 일반화 프로그래밍을 성공적으로 도입했다.<a class='wiki-fn-content' title='다만 제네릭은 Type Erasure를 사용하기 때문에 개념적으로 C++의 템플릿과 다르며, 할 수 있는 일도 거의 일반화 프로그래밍 자체로만 한정돼 있다.' href='#fn-18'><span class='target' id='rfn-18'></span>&#91;18&#93;</a><a class='wiki-fn-content' title='기존에 앞 문단 서술에 사용되었던 용어인 &quot;템플릿 메타 프로그래밍&quot;은 개념을 오해하여 사용한 것이므로 &quot;일반화 프로그래밍&quot;으로 대체하였다. 일반화 프로그래밍(Generic Programming)은 Java나 C#에도 &quot;제네릭&quot;이라는 형태로 구현되어 있다. 그러나 템플릿 메타 프로그래밍(Template Meta-Programming)은 Java나 C#에서 전혀 구현되지 않는 별도의 개념이다. 아마도 C++에서 쓰는 &quot;템플릿&quot;이라는 용어와 Java의 &quot;제네릭&quot;이라는 용어가 같은 것을 지칭한다고 착각해서 나온 결과로 추정된다. C++ 템플릿 프로그래밍 = &quot;일반화 프로그래밍 + 템플릿 메타 프로그래밍&quot;, Java/C# 제네릭 = &quot;일반화 프로그래밍&quot;으로 이해하면 쉽다. &quot;템플릿 메타 프로그래밍&quot;은 C++, D 등 극소수의 언어만 지원한다.' href='#fn-19'><span class='target' id='rfn-19'></span>&#91;19&#93;</a> 키워드에 약어 사용을 자제한 점도 코드 가독성 상승에 기여했다.<br><br>하지만 Java가 로우레벨 언어인 C나 C++보다 읽기 쉽다고 해서<a class='wiki-fn-content' title='이 부분은 주관적인 것으로 C/C++가 Java보다 가독성이 좋지 않다는 것에 대해 동의하지 않는 시각도 많다는 점을 알려둔다.' href='#fn-20'><span class='target' id='rfn-20'></span>&#91;20&#93;</a> 일반적인 시각에서 보기에 가독성이 좋은 언어는 아닌데, 그 이유는 단점 항목에서 언급된 소스 코드의 길이 문제 때문이다. 일반적으로 개발자들 사이에서 Java가 가독성이 좋은 언어로 통용되지는 않는다. <a class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'>Kotlin</a>이 구글에 의해 Java의 대체 언어로 선정된 이유는 오라클과의 저작권 관련 분쟁 때문도 있지만, Java 문법의 장황함과 가독성의 불편함에서 기인한 것이기도 하다. 비유를 하자면 Java는 입문 장벽을 낮춘 대신 이런저런 제약을 울타리처럼 둘러친 언어이고, C/C++는 프로그래머에게 자유도를 부여한 대신 입문 장벽을 높여버린 언어라고 할 수 있다.</div></div><h3 class='wiki-heading'><a id='s-7.2' href='#toc'>7.2.</a> <span id='단점'>단점<span class='wiki-edit-section'><a href='/edit/Java?section=32' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'></div></div><h4 class='wiki-heading'><a id='s-7.2.1' href='#toc'>7.2.1.</a> <span id='속도 문제'>속도 문제<span class='wiki-edit-section'><a href='/edit/Java?section=33' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>여기서 잠시 유의할 점은, 느리다는 내용은 대부분 C/C++, Pascal, Fortran 같은 네이티브 바이너리 코드를 만드는 언어와 비교했을 때의 이야기이다. Java가 C/C++보다 2~3배 느리다고 하지만 다른 고수준 언어들에 비해서는 그리 떨어지지 않는다.<a class='wiki-fn-content' title='Java는 JIT 컴파일을 기본적으로 사용하기 때문이다. C#이나 PHP 7와 같은 고수준 언어도 해당사항이다. ' href='#fn-21'><span class='target' id='rfn-21'></span>&#91;21&#93;</a> 특히 인터프리터/스크립트 언어는 구조적으로 Java에 비해서도 훨씬 느리다는 것을 기억하자. 예를 들어 요즘 인기있는 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a>은 C보다 수십 배 느리다. 그나마 빠르다고 하는 <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a>도 Java에 비해서 2배 정도 느리다.<br><br>또한 속도 관련 문제는 하드웨어의 성능이 점점 좋아지고 메모리 가격이 떨어지면서 희석되고 있다. 처음 Java가 나왔을 때인 1995년만 하더라도, 느린 성능 때문에 그다지 많이 쓰이지는 않을 것이라고 예상했지만 현재 Java가 가장 많이 사용되는 곳 중 하나는 안정성과 일정 수준 이상의 성능이 요구되는 서버다. Java가 네이티브 코드보다 느리지만 대부분의 상황에서는 큰 문제가 되지 않는다.<br></div></div><h5 class='wiki-heading'><a id='s-7.2.1.1' href='#toc'>7.2.1.1.</a> <span id='JVM 로딩 속도 문제'>JVM 로딩 속도 문제<span class='wiki-edit-section'><a href='/edit/Java?section=34' rel='nofollow'>&#91;편집&#93;</a></span></span></h5><div class='wiki-heading-content'><div class='wiki-paragraph'>Java의 심각한 단점 중 하나는, 실행하는 과정에서 <a class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'>Java Virtual Machine</a>이 <strong>반드시</strong> 완벽하게 로딩되어야 하기 때문에 프로그램의 초기 시작 시간이 완전한 이진 코드로 컴파일된 프로그램을 실행하는 것에 비해 오래 걸리는 것이다.  단적인 예로, 아무것도 안하고 콘솔 화면에 달랑 &quot;Hello, World!&quot; 라고 찍기만 하는 프로그램이 실행되는 데에도 thread가 10개 쯤 뜬다. 특히 그 프로그램에 AWT, Swing, SQL 같이 불필요한 기능을 끌어들이는 것은 매우 심각한 문제이다. 이 문제는 런타임 자체가 아직 모듈화되지 않았다는 점에서 기인한다.<br><br>하지만 요즘 같은 고사양 컴퓨터에서는 아주 많은 라이브러리를 끌어오는 것이 아니라면 체감상 차이는 크게 나지 않는다. 또한 Java 9부터는 드디어 <strong>런타임 라이브러리를 모듈화</strong>하고 있으므로, 필요한 모듈만 끌어서 프로그램을 짤 수 있다.</div></div><h5 class='wiki-heading'><a id='s-7.2.1.2' href='#toc'>7.2.1.2.</a> <span id='가상 머신 바이트코드 실행 속도 문제'>가상 머신 바이트코드 실행 속도 문제<span class='wiki-edit-section'><a href='/edit/Java?section=35' rel='nofollow'>&#91;편집&#93;</a></span></span></h5><div class='wiki-heading-content'><div class='wiki-paragraph'>C/C++, Pascal, Fortran과 같은 언어와 달리, Java는 <a class='wiki-link-internal' href='/w/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C' title='바이트코드'>바이트코드</a>로 된 프로그램을 실행하기 위해 운영체제와 프로그램 사이에 <a class='wiki-link-internal' href='/w/JVM' title='JVM'>JVM</a>이라는 두꺼운 계층이 하나 더 자리잡게 된다. 그리고 바이트코드는 실시간으로 각 타겟 플랫폼용 기계어로 번역되어 실행된다. 이로 인해 네이티브 바이너리 코드를 출력하는 언어와 비교하여 실행속도와 성능에 일정 부분 손실이 발생할 수밖에 없다. AWT, Swing 같은 GUI 라이브러리를 사용할 때도 심각하게 느린 것을 체감할 수 있다. 이런 문제점을 썬 마이크로시스템즈도 곧 깨달았고, 최초 발표에서 2년 후인 1998년부터 <a class='wiki-link-internal' href='/w/JIT' title='JIT'>JIT</a> 컴파일러를 JVM에 내장하여 성능이 상당 부분 개선되었다. 하지만, 그만큼 <a class='wiki-link-internal' href='/w/%EB%A9%94%EB%AA%A8%EB%A6%AC' title='메모리'>메모리</a>가 뒷받침해줘야 한다. 현재는 보통 같은 기능/알고리즘을 실행하는 데 C++보다 2~3배 정도의 시간이 더 필요하다고 알려져 있다. 이 부분은 꽤 초기부터 지속적으로 개선되어 왔기 때문에 현재 실행속도 자체에 대한 이슈는 예전에 비해 많이 줄어든 편이다.<br><br>이 문제는 Java 9에서 &#39;선행 컴파일&#39;이라는 이름으로 개선될 예정이다. JIT 컴파일로 실행과 동시에 컴파일을 하는 게 아니라 기존의 정적 컴파일처럼 바이트코드를 미리 기계어로 번역하면, 컴파일 속도는 다소 느려지지만 실행 속도는 빨라지게 된다. 물론 컴파일 한 번으로 여러 플랫폼에서 동일하게 실행시키는 건 불가능해진다.</div></div><h5 class='wiki-heading'><a id='s-7.2.1.3' href='#toc'>7.2.1.3.</a> <span id='가비지 컬렉션에 의한 실행 지연 문제'>가비지 컬렉션에 의한 실행 지연 문제<span class='wiki-edit-section'><a href='/edit/Java?section=36' rel='nofollow'>&#91;편집&#93;</a></span></span></h5><div class='wiki-heading-content'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EC%93%B0%EB%A0%88%EA%B8%B0%20%EC%88%98%EC%A7%91' title='쓰레기 수집'>가비지 컬렉션</a>에 의한 메모리 프리징 현상<a class='wiki-fn-content' title='메모리를 훑으면서 순간적으로 프로그램이 얼어붙어 멈추는 현상.' href='#fn-22'><span class='target' id='rfn-22'></span>&#91;22&#93;</a>이 초반부터 지속적으로 Java를 괴롭혔다. 멀쩡하게 동작해야 할 프로그램이 순간적으로 뚝 뚝 끊기는 듯한 현상이 발생하는 것. 오늘날 Java의 문제는 바이트코드 변환으로 인한 속도 저하보다 이 가비지 컬렉션의 영향이 더 크다고 할 수 있다. 이러한 문제점은 가비지 컬렉션을 지원하는 다른 프로그래밍 언어들도 마찬가지이긴 하지만 실행속도와 함께 Java 초기부터 꾸준히 문제로 꼽혀온 것으로, 버전이 올라갈 때마다 다양하게 개선되어 왔다.<br><br>Java 8부터는 메모리 누수를 일으키던 메소드 영역의 PermGen Area를 제거하여 static 인스턴스와 리터럴 문자열도 GC의 대상이 되도록 바뀌었으며, 클래스, 메소드, 배열의 메타 정보는 동적 리사이징이 가능한 Metaspace로 이동시켜 시스템 힙 영역에 저장된다. 덕분에 JVM 힙 영역의 공간이 늘어나고 PermGen Area를 스캔/삭제할 필요가 없어져 GC의 성능이 대폭 향상되었다.</div></div><h4 class='wiki-heading'><a id='s-7.2.2' href='#toc'>7.2.2.</a> <span id='불편한 예외 처리'>불편한 <a class='wiki-link-internal' href='/w/%EC%98%88%EC%99%B8%20%EC%B2%98%EB%A6%AC' title='예외 처리'>예외 처리</a><span class='wiki-edit-section'><a href='/edit/Java?section=37' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>다른 객체지향 언어들처럼, Java 역시 try~catch문으로 대표되는 예외 처리를 할 수 있다. 대부분의 언어에서 차용하고 있는 좋은 기능이지만... 유독 Java는 다른 언어와는 달리 프로그래머의 검사가 필요한 예외(Exception을 직접 상속하는 예외 클래스)가 등장한다면 무조건 프로그래머가 선언을 해줘야 한다. 그렇지 않으면 <strong>컴파일조차 거부한다.</strong> 원래 의도는 철저한 예외 처리를 하니까 만약에 발생할 수 있는 모든 상황에 안정성을 확보할 수 있겠지...였으나, 결국 대부분의 경우엔 <strong>귀찮다</strong>는 이유로, 가장 일반적인 예외인 Exception <del>더 막나가면 Throwable</del> 하나만 써서 넘어가버리고<a class='wiki-fn-content' title='이를 gotta catch &#39;em all 패턴이라고 한다.' href='#fn-23'><span class='target' id='rfn-23'></span>&#91;23&#93;</a> 폭탄 돌리듯 넘기기만 하거나(예외 던지기만 하고 try~catch 안하면 메소드를 돌고 돌다가 콰광!), 예외 나든 말든 무시해 버리는 경우가 가장 흔하다.<a class='wiki-fn-content' title='물론 이렇게 짜면 안되지만 구조적으로 강요받는 형편.' href='#fn-24'><span class='target' id='rfn-24'></span>&#91;24&#93;</a> 이런 코드가 너무 흔해 빠진 나머지 이딴 식으로 쓸 거면 왜 넣었냐고 까는 사람도 많다. 그런데 선언이 필요없는, <strong>검사 안하는</strong> 예외도 Java에 많다(...).<a class='wiki-fn-content' title='이쪽은 RuntimeException 계열의 예외로, 이것을 던지는 메소드가 throws에 명시적으로 던진다고 선언하지 않았을 경우 검사를 하지 않아도 된다.' href='#fn-25'><span class='target' id='rfn-25'></span>&#91;25&#93;</a> 그리고 C++이나 C# 같이 예외가 있는 언어라도 Java처럼 예외를 쓰는 경우는 별로 없다. 두 언어는 모든 예외가 <strong>검사 안하는</strong> 예외이다. 사실 예외 처리를 한다는 것은 귀차니즘과 견고함을 맞바꾸는 일인데, <a class='wiki-link-internal' href='/w/%EB%82%B4%EB%A0%A4%EA%B0%88%20%ED%8C%80%EC%9D%80%20%EB%82%B4%EB%A0%A4%EA%B0%84%EB%8B%A4' title='내려갈 팀은 내려간다'>안할 사람은 문법으로 강제해도 안한다</a>는 것을 보여준다.<br><br>대부분의 다른 언어에서는 원하는 에러만 try-catch문으로 뽑아내고 그렇지 않은 경우에는 그냥 아무 처리를 해주지 않아도 된다. 이러한 언어를 접하던 사람이 Java를 접하면 그 특유의 경직된 예외처리에 불편해하기도 한다. 오히려 명시적으로 예외처리를 할 수 없는 경우도 존재하는데, 인터페이스를 상속받을 때 인터페이스에 선언된 예외가 아니면 구현 클래스에서 그 예외를 던질 수 없다! 특히, Java에서 제공하는 Iterator 인터페이스에는 throws 선언 따위는 없기 때문에 Iterator를 구현받았을 때 명시적으로 예외를 던질 수 없다. 이 상황을 해결하려면 RuntimeException 계열을 쓸 수밖에 없는 상황이 펼쳐진다.<br><br>다만, 상기의 내용은 실무적 접근에 의한 내용이고, 실제로는 이는 장점으로도 취급되기도 한다. Assert문을 자유자재로 쓰면서 예외처리를 하거나 코딩과 동시에 발생할 수 있는 각종 예외들을 인지하고 처리해주는 걸 잊어먹는 경우에 대한 대처가 가능하다.<a class='wiki-fn-content' title='대한민국에 국한되는 경향이 강하긴 하지만 현재 한국에서 이러한 예외처리를 코딩하는 순간에 인지하는 개발자는 드물다. 국비지원 학원을 막 졸업한 신입들은 말 할 것도 없으며 현업 몇년 한 초중급 경력자들 역시 이를 인지하지 못하는 경우가 허다하기 때문에, 어찌보면 대한민국 IT계의 버그처리와 예외처리에 있어서만큼은 장점으로 볼 수도 있다.' href='#fn-26'><span class='target' id='rfn-26'></span>&#91;26&#93;</a></div></div><h4 class='wiki-heading'><a id='s-7.2.3' href='#toc'>7.2.3.</a> <span id='소스 코드 길이'>소스 코드 길이<span class='wiki-edit-section'><a href='/edit/Java?section=38' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>Java는 소스 코드의 길이가 다른 언어에 비해 상당히 긴 편이다. 같은 기능을 하는 코드를 짠다고 했을 때 다른 언어에 비해 타이핑해야 할 양이 많다. 구체적으로 말하자면 일명 Boilerplate라고 부르는, 기본적인 구조를 짜기 위해서 무조건 의무적으로 작성해 주어야만 하는 서식과 코드의 분량이 많다.<br><br>인터프리터 언어에서는 puts(&quot;Hello&quot;) 정도로 끝났을 일을 Java에서는<br><pre><code class="syntax" data-language="java"><span class="syntax-keyword">package</span> wiki.namu.test;

<span class="syntax-keyword">public</span> <span class="syntax-keyword">class</span> HelloWorld {
    <span class="syntax-keyword">public</span> <span class="syntax-keyword">static</span> <span class="syntax-keyword">void</span> main(String[] args) {
        System.out.println(<span class="syntax-literal">"Hello"</span>);
    }
}</code></pre><br>이만큼을 써야 한다. 같은 일을 하는 <a class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'>C</a>언어 코드는<br><pre><code class="syntax" data-language="cpp">#include &lt;stdio.h&gt;

<span class="syntax-keyword">int</span> main() { 
    puts(<span class="syntax-literal">"Hello"</span>);
}</code></pre><a class='wiki-fn-content' title='사실 C(C++이 아니다)는 C99기준 stdio.h를 포함하지 않아도 puts, printf 등을 사용할 수 있다. C, C++ 공통으로는(C++11기준) main에 int를 붙이지 않아도 콤파일이 된다. 따라서 더 짧게 쓴다면 main() {　　puts(&quot;Hello&quot;);}이 된다.' href='#fn-27'><span class='target' id='rfn-27'></span>&#91;27&#93;</a><br>파이썬의 경우<br><pre><code class="syntax" data-language="python">print(<span class="syntax-literal">"Hello"</span>)</code></pre><br><del>이걸 브라우저 콘솔에 치면 인쇄 창이 나온다</del><br><del><a class='wiki-link-internal' href='/w/HQ9%2B' title='HQ9+'>HQ9+</a>의 경우 H</del><br>위키책에 있는 Hello World 프로그램의 <a class='wiki-link-external' href='https://en.wikibooks.org/wiki/Computer_Programming/Hello_world' target='_blank' rel='nofollow noopener' title='https://en.wikibooks.org/wiki/Computer_Programming/Hello_world'>목록</a>이나, 나무위키 내의 <a class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4/%EC%98%88%EC%A0%9C' title='프로그래밍 언어/예제'>프로그래밍 언어/예제</a> 문서를 보면 하이레벨 언어 중에서는 코드량이 긴 편인 걸 알 수 있다.<br><br>오죽하면 <a class='wiki-link-external' href='https://medium.com/@webseanhickey/the-evolution-of-a-software-engineer-db854689243' target='_blank' rel='nofollow noopener' title='https://medium.com/@webseanhickey/the-evolution-of-a-software-engineer-db854689243'>이런</a> 포스트가 만들어질까. 물론 이건 Java의 문제가 아니고 마세라티 문제<a class='wiki-fn-content' title='그 마세라티가 맞다. 자신이 탈수나 있을지도 모르는 마세라티를 타면 어떻게 해야 될까... 라는 쓸데없는 고민을 하는 것을 비유하는 문제로, 당장에 쓸데없는 기능을 위해 과도하게 투자하는 것을 의미한다.' href='#fn-28'><span class='target' id='rfn-28'></span>&#91;28&#93;</a>라고 알려진 프로그래머의 과욕이 부른 참상이지만 코드에 유연성을 조금 추가하기 위해 써 넣어야 할 코드의 길이가 기하급수로 증가한다는 하나의 예시로 볼 수 있다. 참고로 저 포스트의 5년차 코드는 <a class='wiki-link-internal' href='/w/Spring(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)' title='Spring(프레임워크)'>Spring</a>의 패러디다. Java 이후에 나온 차세대 언어들은 같은 수준의 유연성을 확보하기 위해 들여야 할 노력의 양이 훨씬 적다.<br><br>이렇게 의도적인 장황함(verbosity)을 추구하는 언어 설계와 커뮤니티의 문화가 아이러니하게도 위에서 언급한 장점이 무색하게 가독성을 저해하는 요인이 되기도 한다. 같은 기능을 하더라도 수십 줄의 보일러플레이트 코드를 가지는 Java 코드보다 다른 언어의 코드가 보통은 더 읽기 쉽기 때문. <br><br>게다가 다른 하이레벨 언어(C#, Python, Ruby 등)에 비해 문법적 설탕(Syntactic sugar)<a class='wiki-fn-content' title='프로그래밍 언어를 좀 더 쉽게 표현할 수 있도록 하는 보조문법. C에서 구조체 포인터를 쓸 때 (*ptr).num은 ptr-&gt;num으로도 표현 가능하므로, -&gt;는 문법적 설탕이라고 할 수 있다.' href='#fn-29'><span class='target' id='rfn-29'></span>&#91;29&#93;</a>이 적어 이쪽에서 넘어오면 꽤 불편해하는 편. 하지만 최근 Java 8로 넘어오면서 람다 표현식, 스트림<a class='wiki-fn-content' title='컬렉션(Collection)의 이터레이터를 확장해서 처리할 수 있는 개념으로, 이터레이터의 원소를 필터링해서 원하는 원소만 뽑거나, 원소갯수를 줄여버리고, 이렇게 다시 뽑혀진 원소들로 갖가지 처리를 만드는 등 &#39;함수적인(functional)&#39; 기능을 제공한다.' href='#fn-30'><span class='target' id='rfn-30'></span>&#91;30&#93;</a> 등을 지원하는 식으로 문법적 편리함을 늘려가는 추세다. 이 흐름은 다음 Java 9에서 더욱 강화될 것으로 보는 추세.<a class='wiki-fn-content' title='정작 람다 표현식의 추가는 Java 진영 내에서 논란이 있다. 람다 식이 뒤늦게 추가된 것도 코드 리딩이 어려워진다고 싫어하는 개발자가 많아서였다.' href='#fn-31'><span class='target' id='rfn-31'></span>&#91;31&#93;</a><br><br>그러나 무조건 타이핑의 양이 많다고 해서 나쁜 것만 있는 것이 아니다. 일단 Java는 명색이 클래스 지향적이기 때문에 어쩔 수 없는 부분이고, 커다란 프로젝트 단위에서 봤을 땐 오히려 클래스와 메소드, 변수의 소속이 확실하기 때문에 코드를 금방 파악할 수 있다. 축약어의 사용을 최대한 자제하는 방향으로 만들었기 때문에 그렇다.<a class='wiki-fn-content' title='멀리 갈 것 없이, C언어의 stdio.h와 자바의 System.out을 비교해보자. Java는 직관적으로 &#39;시스템&#39;에서 뭔가가 &#39;나온다&#39;는 것을 쉽게 인식할 수 있지만, stdio.h를 봤을 때 직관적으로 뭘 떠올릴까? 저걸 처음 보고 STanDard Input and Output을 떠올릴 사람이 얼마나 있을까? 물론 C를 하다 보면 언어 기능 자체가 적어 파악하기가 쉬운 건 함정이다 ' href='#fn-32'><span class='target' id='rfn-32'></span>&#91;32&#93;</a> Python이나 JavaScript 같은 동적 타입 언어들은 소규모 프로젝트에는 좋겠지만 대형 프로젝트에서는 불편할 수도 있다.<br><br>JetBrains에서 개발한 <a class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'>Kotlin</a>은 바로 이 Java의 언어적 불편함을 최소화하려고 나온 새 프로그래밍 언어이며, <a class='wiki-link-internal' href='/w/%EC%B9%B4%EC%B9%B4%EC%98%A4(%EA%B8%B0%EC%97%85)' title='카카오(기업)'>카카오</a>에서도 카카오톡 메시징 서버에 Kotlin을 도입하는 등(<a class='wiki-link-external' href='https://byline.network/2018/09/5-20/' target='_blank' rel='nofollow noopener' title='https://byline.network/2018/09/5-20/'>#</a>) Java를 Kotlin으로 대체하려는 움직임이 조금씩 나타나고 있다.</div></div><h4 class='wiki-heading'><a id='s-7.2.4' href='#toc'>7.2.4.</a> <span id='언어적 불편함'>언어적 불편함<span class='wiki-edit-section'><a href='/edit/Java?section=39' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'></div><h5 class='wiki-heading'><a id='s-7.2.4.1' href='#toc'>7.2.4.1.</a> <span id='명사형 사고를 강제'>명사형 사고를 강제<span class='wiki-edit-section'><a href='/edit/Java?section=40' rel='nofollow'>&#91;편집&#93;</a></span></span></h5><div class='wiki-heading-content'><div class='wiki-paragraph'>Java는 모든 동작이 객체 상위에서 이루어지게 함으로써 명사형으로 생각하는 것을 강제한다. 그 결과로 Java에는 전역 함수가 없고 모든 함수는 어떤 클래스에 종속되어있다. 이 때문에 기능적인 부분을 작성하는데 자잘한 클래스들을 작성해야 한다는 불편함이 있다.<br><br>이런 명사 중심적 생각은 확실히 많은 경우 편리하나 동사 중심으로 생각해야 하는 상황도 생각보다 흔하다는 게 문제. 예를 들어서, 퀵소트를 Java에서 엄격하게 의도된 대로 짜려면 quickSort(array)라는 함수 대신 QuickSorter라는 객체의 생성자에 배열을 넣고, 그 생성자를 참조하는 참조변수를 이용해 run()을 호출하여 동작시켜야 하는 것이다.<a class='wiki-fn-content' title='실제로 Java에서 기본 제공하는 정렬 기능은 Collections 클래스의 정적 메소드인 sort(array)를 호출하도록 작성되어 있다.' href='#fn-33'><span class='target' id='rfn-33'></span>&#91;33&#93;</a><br><br><a class='wiki-link-internal' href='/w/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4' title='디자인 패턴'>디자인 패턴</a>을 사용해서 어느 정도 동사형 사고방식으로 코드를 작성할 수 있긴 하다. 디자인 패턴에서 핵심적 지위를 차지하는 <strong>인터페이스</strong>라는 놈을 사용하면 상당히 동사적인 관점으로 객체를 다룰 수 있다. Java의 리플렉션 API를 사용하는 방법도 있고. 하지만 애초에 언어가 생겨먹은 것 자체가 명사 기준으로 생각하게 디자인된 건 사실이다. Java의 근간을 이루는 표준 java.lang 클래스와 java.util 클래스를 동사형 사고방식으로 재작성하기 전에는 힘들다. 이 재작성 삽질은 이미 <a class='wiki-link-internal' href='/w/Scala' title='Scala'>Scala</a>에서 해 놨으므로 Java의 이러한 특징이 싫다면 Scala를 쓰면 된다.</div></div><h5 class='wiki-heading'><a id='s-7.2.4.2' href='#toc'>7.2.4.2.</a> <span id='클로저 미지원'><a class='wiki-link-internal' href='/w/%ED%81%B4%EB%A1%9C%EC%A0%80' title='클로저'>클로저</a> 미지원<span class='wiki-edit-section'><a href='/edit/Java?section=41' rel='nofollow'>&#91;편집&#93;</a></span></span></h5><div class='wiki-heading-content'><div class='wiki-paragraph'>명사형 생각을 강제한다는 것의 연장선. 버전 7 이하의 Java는 함수를 일급 객체로 취급하지 않는다. 어떤 &#39;동작&#39;을 넘겨야 할 때는 그 동작을 추상화한 인터페이스를 만들고, 그것을 클래스로 구현한 뒤, 객체를 파라미터로 넘겨야 한다. 반면에 클로저를 지원하는 언어는 그냥 함수를 파라미터로 넘기면 된다.<br><br>Java의 수많은 디자인 패턴들은 이 클로저 미지원 문제 때문에 만들어졌다. Java라는 언어가 설계될 당시에는 클로저라는 개념 자체가 <a class='wiki-link-internal' href='/w/LISP' title='LISP'>LISP</a>, <a class='wiki-link-internal' href='/w/Haskell' title='Haskell'>Haskell</a>, ML 등의 언어을 사용하거나 프로그래밍 언어를 연구하는 사람들이나 아는 몹시 마이너한 개념이었기 때문에 동시기에 만들어진 다른 많은 프로그래밍 언어들도 클로저를 지원하고 있지는 않았다. 따라서 설계 결함이라고 부를 수는 없고 현대에 들어서 단점으로 부각되기 시작했다는 편이 더 적절하다.<br><br>Java 8에서는 람다 표현식을 지원함과 더불어 메소드 참조라는 방식(this::add)을 통해 함수를 다른 함수의 파라미터로 넘길 수 있게 되었다. 이러한 함수 파라미터는 Functional Interface를 이용하여 선언하는데, Functional Interface는 수십여 종이 있으며 인자가 복수개인 것도 당연히 있고, 하나의 추상 메소드를 가진 인터페이스를 새로 만들어서 써도 된다. 다만 자바의 람다식은 바깥에 있는 변수를 참조하려면 그 변수가 final이거나 final을 붙여도 문제가 없는 변수들 뿐이다. 따라서 람다식이 주위에 있는 변수를 &#39;저장&#39;할 수는 있으나 그것의 값을 바꿀수는 없다.<br><br>java.util.function에 있는 대표적인 함수형 인터페이스 (Functional Interface)와 그에 대응하는 추상 메소드 몇개를 나열하자면 다음과 같다.<br></div><ul class='wiki-list'><li><div class='wiki-paragraph'>Predicate&lt;T&gt; ⇒ boolean test(T)</div></li><li><div class='wiki-paragraph'>Consumer&lt;T&gt; ⇒ void accept(T)</div></li><li><div class='wiki-paragraph'>Supplier&lt;T&gt; ⇒ T get() </div></li><li><div class='wiki-paragraph'>Function&lt;T, U&gt; ⇒ U apply(T)</div></li><li><div class='wiki-paragraph'>BiFunction&lt;T, U, R&gt; ⇒ R apply(T, U)</div></li></ul></div><h2 class='wiki-heading'><a id='s-8' href='#toc'>8.</a> <span id='개발환경, JVM 언어'>개발환경, JVM 언어<span class='wiki-edit-section'><a href='/edit/Java?section=42' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'></div><h3 class='wiki-heading'><a id='s-8.1' href='#toc'>8.1.</a> <span id='개발환경'>개발환경<span class='wiki-edit-section'><a href='/edit/Java?section=43' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>Java에 특정한 라이브러리를 가미해서 웹에서 돌릴 수 있게 한 것이 <a class='wiki-link-internal' href='/w/Java%20Applet' title='Java Applet'>Java Applet</a>이다. 애플릿 특유의 제약으로 인해 <a class='wiki-link-internal' href='/w/ActiveX' title='ActiveX'>ActiveX</a>보다는 훨씬 안전하다는 이유로 물 건너에서는 인터넷 뱅킹이나 결제용도로 사용하기도 한다. 근데 상대적으로 안전하다는 것일 뿐, 애플릿을 사용한 결제시스템도 툭하면 뚫려서 문제가 발생하곤 한다(…). 더군다나 <a class='wiki-link-internal' href='/w/%EC%95%84%EC%9D%B4%ED%8F%B0' title='아이폰'>아이폰</a>과 <a class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C' title='안드로이드'>안드로이드</a>에서는 되지 않는다. 게다가 크롬과 파이어폭스 등의 브라우저들이 NPAPI 지원 중단 선언을 하고, Java 9부터 애플릿의 개발이 중단되면서 결국 수명이 끝나게 되었다. 이 문제들은 자바 애플릿만이 아닌 다른 대부분의 리치 인터넷 애플리케이션들의 문제점이기도 하다.<br><br>웹 애플리케이션 제작을 위해 Java 언어를 사용하는 규격으로 Java 서블릿과 <a class='wiki-link-internal' href='/w/JSP' title='JSP'>JSP</a>(Java 서버 페이지)가 있다.<a class='wiki-fn-content' title='JSP의 목적이 HTML 페이지를 동적으로 만들어내는 것이다. JSP 소스는 Java 서블릿 코드로 변환되어 서버에서 실행되고, 서버는 이 HTML 결과를 브라우저에 보여준다. JSP 페이지는 HTML 페이지에 Java 코드가 포함되어 있는 식으로 되어 있는 경우가 많고, 이 점은 PHP, ASP.NET 등과 비슷한 편이다. 반면 Java 서블릿은 서버 쪽에서 하는 일에 관심이 많지만 출력에 대한 관심은 적다. 필요하다면 브라우저에 출력을 전혀 안 보낼 수도 있다. 최근에는 Server side script language로 HTML 페이지를 동적으로 만드는 식으로는 프로그래밍을 하지 않는다. JSP, PHP와 같은 Server side script language로는 서버에 있는 자원의 접근을 주로 하고(DB 연산, File 연산 등등) 화면에 보여주는 UI는 HTML/CSS/JavaScript로만 한다. 따라서 Client side와 Server side 간에 통신이 필요한데 이는 XHR(XML HTTP Request)를 이용한다. 이러한 프로그래밍 기법을 나타내는 표현이 REST 내지는 Open API이다.' href='#fn-34'><span class='target' id='rfn-34'></span>&#91;34&#93;</a> 주로 기업에서 사용한다. 개인 웹호스팅에서는 이를 지원하는 경우는 많지 않다. 그러나 최근 Java를 지원하는 여러 <a class='wiki-link-internal' href='/w/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EC%BB%B4%ED%93%A8%ED%8C%85' title='클라우드 컴퓨팅'>클라우드 컴퓨팅</a> 서비스가 싼 가격에 등장하고 있고, Java 뿐만이 아닌 JVM 언어를 이러한 환경에서 구동하는 사례가 늘고 있다.<br><br>Java Development Kit(Java 개발 도구)을 설치하면 javac라는 컴파일러가 제공된다. 하지만 <a class='wiki-link-internal' href='/w/%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD' title='통합 개발 환경'>통합 개발 환경</a>은 제공해 주지 않기 때문에, 반드시 별도의 개발용 프로그램을 써야 한다. 대표적으로 <a class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'>이클립스</a>, <a class='wiki-link-internal' href='/w/%EB%84%B7%EB%B9%88%EC%A6%88' title='넷빈즈'>넷빈즈</a>, <a class='wiki-link-internal' href='/w/IntelliJ%20IDEA' title='IntelliJ IDEA'>IntelliJ IDEA</a> 등이 있다. 만약 이것들을 안 쓰겠다고 한다면, 당신에게는 메모장과 javac.exe가 있을 뿐이다. 그리고 Java는 <a class='wiki-link-internal' href='/w/%EB%82%A0%EC%BD%94%EB%94%A9' title='날코딩'>IDE 없이 타이핑만으로 짜기엔</a> 굉장히 불편한 언어라는 것을 명심하자.<a class='wiki-fn-content' title='Java는 현용 프로그래밍 언어 중에서는 가장 Verbose한(장황한) 언어로 꼽힌다. 즉, 같은 의미인데 많은 타이핑이 필요하다.' href='#fn-35'><span class='target' id='rfn-35'></span>&#91;35&#93;</a> 실전 Java 개발을 할 때 프로젝트에 필요한 라이브러리 관리나 프로젝트 결과물 배포 등 프로젝트 빌드 관리를 위한 도구로는 <a class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'>아파치 소프트웨어 재단</a>에서 만든 Ant와 <a class='wiki-link-internal' href='/w/Maven' title='Maven'>Maven</a>, 그 중에서도 Maven이 많이 사용되고 있다. 최근에는 이 두 가지의 단점을 보완한 Gradle이 각광을 받고 있으나 아직 Maven보다 많이 쓰이지는 않고 있다.<br><br><a class='wiki-link-internal' href='/w/%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A3%BC%EB%8F%84%20%EA%B0%9C%EB%B0%9C' title='테스트 주도 개발'>TDD</a> 개발을 위한 방법으로는 <a class='wiki-link-internal' href='/w/Jenkins' title='Jenkins'>Jenkins</a>를 통한 CI 관리, SonarQube를 통한 코드 분석, <a class='wiki-link-internal' href='/w/Maven' title='Maven'>Maven</a>을 통한 빌드 관리, <a class='wiki-link-internal' href='/w/JaCoCo' title='JaCoCo'>JaCoCo</a>를 통한 Code Coverage 관리 등이 있다.</div></div><h3 class='wiki-heading'><a id='s-8.2' href='#toc'>8.2.</a> <span id='JVM 언어'><a class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'>JVM</a> 언어<span class='wiki-edit-section'><a href='/edit/Java?section=44' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><div class='wiki-paragraph'>이외에 Java와 똑같이 Java 바이트 코드를 생성하지만 언어 규격이 다른 <a class='wiki-link-internal' href='/w/Scala' title='Scala'>Scala</a>와 <a class='wiki-link-internal' href='/w/Clojure' title='Clojure'>Clojure</a>라는 언어들도 있다. <a class='wiki-link-internal' href='/w/Scala' title='Scala'>Scala</a>는 &#39;Scalable Language&#39;에서 따왔는데, Java와 비슷한 부분이 많으며 Java API를 그대로 가져다 쓸 수도 있다. 또한, syntactic sugar가 많고 함수형 프로그래밍의 여러 가지 요소들을 가져와서 Java에 비해 생산성도 높다. 일례로 일일히 타입을 명시하지 않고 var x === 1.5와 같이 넣으면 알아서 float 형으로 추론해준다.<a class='wiki-fn-content' title='Java는 버전 10에서 와서야 이와 같은 타입 추론 기능이 가능해졌다.' href='#fn-36'><span class='target' id='rfn-36'></span>&#91;36&#93;</a> 또, switch-case의 확장판이라 할 수 있는 패턴 매칭을 지원하며 클로저도 지원된다. 단점으로는 이런 고수준-고생산성의 언어에서 많이 볼 수 있듯이 같은 Java 코드에 비해 약간 느리다. <a class='wiki-link-internal' href='/w/Clojure' title='Clojure'>Clojure</a>는 Java 플랫폼에서 동작하는 <a class='wiki-link-internal' href='/w/LISP' title='LISP'>LISP</a>의 방언으로 설계되었으며 Common Lisp와 Scheme과 함께 주요 LISP 방언 중 하나로 꼽힌다. 이 언어도 마찬가지로 Java API를 가져다 쓸 수 있다.<br><br>Java 6부터 Scripting API라는 것이 추가되었다. JVM 언어 구현체에서 javax.scripting 관련 API를 제공하면 Java 코드에서 동적으로 인터프리터를 생성하고 연동하여 사용할 수 있게 해주는 표준 API이다.<br></div></div><h4 class='wiki-heading'><a id='s-8.2.1' href='#toc'>8.2.1.</a> <span id='유명한 JVM 언어 목록'>유명한 JVM 언어 목록<span class='wiki-edit-section'><a href='/edit/Java?section=45' rel='nofollow'>&#91;편집&#93;</a></span></span></h4><div class='wiki-heading-content'><div class='wiki-paragraph'>아래에 나열된 언어들이 유명하며, Common <a class='wiki-link-internal' href='/w/LISP' title='LISP'>LISP</a>, <a class='wiki-link-internal' href='/w/Scheme' title='Scheme'>Scheme</a>, <a class='wiki-link-internal' href='/w/Pascal' title='Pascal'>Pascal</a> 등 여러 다양한 언어들이 구현되어 있다.<br></div><ul class='wiki-list'><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Clojure' title='Clojure'>Clojure</a></div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Groovy' title='Groovy'>Groovy</a>: Java에 Python, Ruby, SmallTalk 등의 특징을 버무린 동적 타입 언어. 2003년에 등장했다.</div></li><li><div class='wiki-paragraph'>JRuby: <a class='wiki-link-internal' href='/w/Ruby' title='Ruby'>Ruby</a>의 대부분을 Java로 구현한 언어 구현체. 역시 Java와 호환된다.</div></li><li><div class='wiki-paragraph'>Jython: 파이썬의 Java 구현체. JVM 위에서 동작하며, 따라서 Python 모듈과 함께 Java 클래스, JAR 사용이 가능하다. 참고로 로고는 Java의 커피 컨셉과 Python의 뱀 컨셉을 섞어서 커피잔에서 <a class='wiki-link-internal' href='/w/%EB%B1%80' title='뱀'>뱀</a>이 연기처럼 피어나오는 로고다(...)</div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'>Kotlin</a> : <a class='wiki-link-internal' href='/w/IntelliJ%20IDEA' title='IntelliJ IDEA'>IntelliJ IDEA</a>를 만든 <a class='wiki-link-internal' href='/w/JetBrains' title='JetBrains'>JetBrains</a>에서 개발한 JVM 언어. Google I/O 2017에서 <a class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'>안드로이드</a>의 공식 언어로 지정되었다.<a class='wiki-fn-content' title='안드로이드의 Java 라이선스 무단 사용으로 구글이 오라클과 법정 싸움을 한 여파로 보인다.' href='#fn-37'><span class='target' id='rfn-37'></span>&#91;37&#93;</a></div></li><li><div class='wiki-paragraph'>Rhino: JVM으로 돌아가는 JavaScript 엔진으로, 모질라 재단이 100% Java로 개발했다. JavaScript와 Java의 API를 동시에 사용해 개발할 수 있다. Java 7 에 내장되어 있다.</div></li><li><div class='wiki-paragraph'>Nashorn: 또 다른 JVM 위에서 돌아가는 JavaScript 엔진이다. Java 8과 함께 등장했다. 참고로 Nashorn 은 Rhino(코뿔소)의 독일어다.</div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/Scala' title='Scala'>Scala</a></div></li></ul></div><h3 class='wiki-heading'><a id='s-8.3' href='#toc'>8.3.</a> <span id='혼동하기 쉬운 것들'>혼동하기 쉬운 것들<span class='wiki-edit-section'><a href='/edit/Java?section=46' rel='nofollow'>&#91;편집&#93;</a></span></span></h3><div class='wiki-heading-content'><ul class='wiki-list'><li><div class='wiki-paragraph'><strong><a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>자바스크립트(JavaScript)</a></strong><br>JavaScript는 Java와는 <strong>아무</strong> 상관도 없다. 넷스케이프사에서 Mocha, LiveScript로 개발하던 스크립트 언어를 1996년 전후 열풍이던 Java의 유명세에 묻어가기위해 Sun에서 상표권을 라이선스해 JavaScript라고 이름붙였을 뿐이다. 이름 하나 생각없이 잘못 붙여서 여러 사람을 지금도 헷갈리게 만드는 대표적인 케이스.<br>이름을 제외한 연관성은 희박한 편이여서 공통점이 아닌 차이점을 나열하는게 훨씬 빠를 정도다. 같은 C-족 언어이긴 하지만 문법조차 별로 비슷하지도 않으며<a class='wiki-fn-content' title='기초적인 C-문법의 일부인 if문, while문 등을 제외하면 공통점이 많지 않다.' href='#fn-38'><span class='target' id='rfn-38'></span>&#91;38&#93;</a>, 사용되는 라이브러리나 개념 또한 많이 다르다. 기초 패러다임상 당연한 요소들을 제외하고 나면 둘의 유사점은 오직 객체지향 뿐인데 그 마저도 JavaScript는 프로토타입 베이스라 클래스를 쓰는 Java와 많이 다르다 <a class='wiki-fn-content' title='ECMAScript 6에서 Class가 생겼다! 그래도 여전히 Java의 클래스와는 겉보기에만 비슷할 뿐 열어보면 다르다. ES6에서 나온 클래스는 기존에 있던 prototype 객체지향 프로그래밍을 조금 더 쉽게 하게 해주는 문법적 설탕이다.' href='#fn-ES6'><span class='target' id='rfn-39'></span>&#91;ES6&#93;</a>. 또한 Java는 정적 타입 언어인데 반해 JavaScript는 동적 타입 언어다. <a class='wiki-link-internal' href='/w/%EC%9B%B9%20%EC%84%9C%EB%B2%84' title='웹 서버'>웹 서버</a>용 파생 규격 역시 <a class='wiki-link-internal' href='/w/JSP' title='JSP'>JSP</a>와 <a class='wiki-link-internal' href='/w/Node.js' title='Node.js'>Node.js</a>로 다르다.<br>떠도는 말로 &#39;Java와 <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a>의 차이는 <a class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84' title='인도'>인도</a>와 <a class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84%EB%84%A4%EC%8B%9C%EC%95%84' title='인도네시아'>인도네시아</a>의 차이와 같다&#39;라고도 한다. 왜냐하면 <a class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84' title='인도'>인도</a>와 <a class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84%EB%84%A4%EC%8B%9C%EC%95%84' title='인도네시아'>인도네시아</a>가 이름만 비슷하고 서로 다른 국가이듯이<a class='wiki-fn-content' title='다만 인도네시아의 어원은 인도와 관련이 있다. 인도네시아라는 이름은 &#39;인도양의 섬&#39;들이라는 그리스어·라틴어식 표현이기 때문. 이런 인도네시아와 인도의 관계는, JavaScript가 Java와 별 관련은 없어도 그 이름을 빌려 왔다는 점에서 왠지 흡사하다.' href='#fn-40'><span class='target' id='rfn-40'></span>&#91;40&#93;</a> Java와 <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a>도 다른 프로그래밍 언어이기 때문이다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'><strong>Visual J++/Visual J#</strong><br>Visual J++은 <a class='wiki-link-internal' href='/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8' title='마이크로소프트'>마이크로소프트</a>에서 Java를 변형하여 윈도우 전용으로 만든 언어. 위의 JavaScript는 이름만 바꿨지만 이건 Java 자체를 윈도우에 맞도록 변형한 것이다. 이 때문에 Java 가상머신 없이 윈도우에서 네이티브로 돌아가지만, 다른 플랫폼에서는 전혀 돌아가지 않는다. 거기다 썬 마이크로시스템즈의 허락없이 마구 변형해서 썼기 때문에 소송크리를 먹고 개발이 <a class='wiki-link-internal' href='/w/%EB%A7%9D%ED%96%88%EC%96%B4%EC%9A%94' title='망했어요'>중단되었다</a>.<br>이후 윈도우의 프로그램이 <a class='wiki-link-internal' href='/w/.NET%20Framework' title='.NET Framework'>닷넷</a>으로 넘어가면서 닷넷 기반의 Visual J#도 만들었다. Visual Studio 2005에 포함되었지만 이것도 개발이 중단되었다. 이때는 썬이 소송하지도 않았는데 중단된 것을 보면 시장성이 없었던 듯 하다. 이미 이 때는 C#이 어느 정도 자리를 잡았기 때문일 수도 있고.</div></li></ul></div><h2 class='wiki-heading'><a id='s-9' href='#toc'>9.</a> <span id='구글 vs. 오라클: Java 저작권 분쟁'>구글 vs. 오라클: Java 저작권 분쟁<span class='wiki-edit-section'><a href='/edit/Java?section=47' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>Java를 처음 개발한 <a class='wiki-link-internal' href='/w/%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88' title='썬 마이크로시스템즈'>썬 마이크로시스템즈</a>는 <a class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'>오라클</a>에게 인수되었고, 2010년에 오라클은 <a class='wiki-link-internal' href='/w/%EA%B5%AC%EA%B8%80' title='구글'>구글</a>이 <a class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'>안드로이드</a>를 개발하면서 Java <a class='wiki-link-internal' href='/w/API' title='API'>API</a> 37개의 소스 코드를 무단 복제하여 사용했다는 이유로 소송을 제기했다. 오라클은 구글이 Java를 이용해 OS를 개발하려는 상업적 목적을 가지고 있었으므로 사전에 허가를 받았어야 했다는 주장이고, 구글은 Java API가 저작권자의 허락 없이 이용할 수 있는 공정 이용(Fair Use)의 대상이라며 맞섰다. 그리고 2018년, 장시간에 걸친 소송전은 오라클의 승리로 결론났다. <a class='wiki-link-external' href='http://www.zdnet.co.kr/news/news_view.asp?artice_id=20180328141031' target='_blank' rel='nofollow noopener' title='http://www.zdnet.co.kr/news/news_view.asp?artice_id=20180328141031'>#</a><br><br>재판의 흐름을 정리하자면 이렇다. 2012년에 이루어진 &#39;저작권 침해&#39;에 관한 재판 1심에서는 구글이 승소하였고, 2014년 항소심에서는 오라클이 승소하였으며 2015년에는 구글의 상고가 기각되었다. 이후 2016년 &#39;공정 이용&#39;에 관한 재판 1심에서는 구글 측의 주장이 받아들여지며 구글이 승소했지만, 결국 2018년 항소심에서 다시 오라클이 승소하게 된 것이다. <a class='wiki-link-external' href='http://news.joins.com/article/22482858' target='_blank' rel='nofollow noopener' title='http://news.joins.com/article/22482858'>#</a><br><br>항소심 재판부의 결론은 Java API 역시 저작권이 존재하는 엄연한 저작물이라는 것이다. 재판부는 구글이 Java API를 수정 없이 그대로 긁어다가 안드로이드를 만들어 모바일 OS 시장을 점령하였으며, 단순히 어떤 애플리케이션을 개발한 게 아닌 별도의 운영체제와 플랫폼을 무기로 향후 오라클이 Java를 이용하여 모바일 시장에 진출할 가능성을 꺾어버렸기 때문에 Java의 무단 이용은 불공정한 행위라고 판결했다. 현재 구글이 오라클에게 배상해야 할 금액은 약 90억 달러에 달할 것으로 예상되고 있다.<br><br>이 판결이 가져다 줄 여파에 대해 안드로이드 생태계가 큰 위기를 맞이했다는 시각이 있지만, 사실 소송기간 동안 안드로이드는 이미 모바일 OS 시장을 <a class='wiki-link-internal' href='/w/iOS' title='iOS'>iOS</a>와 함께 5:5로 양분하고 있을 만큼 거대하게 성장했기 때문에 이번 일로 안드로이드가 휘청거릴 일은 단연코 없다. 90억 달러가 작은 돈은 아니지만, 구글은 한창 성장하던 시절인 2006년에 이미 <a class='wiki-link-internal' href='/w/%EC%9C%A0%ED%8A%9C%EB%B8%8C' title='유튜브'>유튜브</a> 인수금액으로 16억 5,000만 달러를 한번에 지불해낼 정도였고, 2007년에는 광고 회사인 더블클릭을 31억 달러에 샀을 정도로 현금 창출력이 상당한 기업이다. 그리고 안드로이드는 직접적인 로열티 수입은 없지만 구글 검색과 광고, 구글 플레이와 유튜브 같은 구글 앱에서 나오는 수익만 해도 매년 수백억 달러에 달한다는 평가를 받고 있는데, 모바일 OS 시장 양분 댓가로 90억 달러를 낸다면 구글 입장에선 거저 먹는 것이나 다름없다.<br><br>일단 구글은 연방대법원에 상고할 것이라는 의사를 밝혔다. <a class='wiki-link-external' href='https://news.v.daum.net/v/20180829100830547' target='_blank' rel='nofollow noopener' title='https://news.v.daum.net/v/20180829100830547'>#</a> 다만 실제로 상고를 신청할지, 신청하더라도 대법원에서 그걸 받아들일지는 나중 문제이다.<br><br>구글이 대법원에 오라클의 승소에 대해 다시 검토해줄 것을 요청했고 이와 관련한 첫번째 심리가 오는 2020년 3월 열릴 예정이라고 한다. 최종 판결은 이르면 6월께 나올 것이라고 한다. <a class='wiki-link-external' href='https://n.news.naver.com/article/293/0000026250' target='_blank' rel='nofollow noopener' title='https://n.news.naver.com/article/293/0000026250'>#</a><br><br>하지만 2020년을 강타한 <a class='wiki-link-internal' href='/w/COVID-19' title='COVID-19'>COVID-19</a>의 여파로 2020년도에 예정된 재판들이 줄줄이 2021년도로 연기되면서 첫 변론도 3월에서 9월로 밀렸다.<a class='wiki-link-external' href='https://www.scotusblog.com/2020/03/justices-postpone-march-argument-session/' target='_blank' rel='nofollow noopener' title='https://www.scotusblog.com/2020/03/justices-postpone-march-argument-session/'>#</a><a class='wiki-link-external' href='https://www.scotusblog.com/case-files/cases/google-llc-v-oracle-america-inc/' target='_blank' rel='nofollow noopener' title='https://www.scotusblog.com/case-files/cases/google-llc-v-oracle-america-inc/'>#</a></div></div><h2 class='wiki-heading'><a id='s-10' href='#toc'>10.</a> <span id='점유율'>점유율<span class='wiki-edit-section'><a href='/edit/Java?section=48' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>세계 <a class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'>프로그래밍 언어</a> 중에서 점유율 1위를 <a class='wiki-link-internal' href='/w/2000%EB%85%84' title='2000년'>2000년</a>부터 무려 19년 째 1위를 질주중인 <strong><a class='wiki-link-internal' href='/w/%EB%8F%85%EC%9E%AC%EC%9E%90' title='독재자'>독재자</a></strong>(...)이다. <a class='wiki-link-internal' href='/w/2007%EB%85%84' title='2007년'>2007년</a>까지만 해도 전 세계 프로그래밍 언어 점유율 중에 Java 점유율이 <strong>35%</strong>까지도 차지했다. 그러나 <a class='wiki-link-internal' href='/w/2010%EB%85%84%EB%8C%80' title='2010년대'>2010년대</a> 들어서 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a>, <a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a> 등의 점유율이 급상승하면서 Java의 점유율은 점차 하락하는 추세이다. 1위는 수성하고 있지만 점유율은 급격하게 떨어지고 있다. <a class='wiki-link-internal' href='/w/2019%EB%85%84' title='2019년'>2019년</a> 지금은 <a class='wiki-link-internal' href='/w/C%EC%96%B8%EC%96%B4' title='C언어'>C언어</a>보다 약간 더 많은 수준으로 17~18% 정도를 차지하고 있다. Java 점유율이 하락한 만큼 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a> 비율이 크게 올랐다.</div></div><h2 class='wiki-heading'><a id='s-11' href='#toc'>11.</a> <span id='불투명한 미래?'>불투명한 미래?<span class='wiki-edit-section'><a href='/edit/Java?section=49' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'>이러한 분쟁과는 별도로, <strong>오라클이 Java를 포기하려고 한다</strong>는 주장이 있다. <a class='wiki-link-external' href='http://news.softpedia.com/news/oracle-mysteriously-fires-almost-all-of-its-top-java-evangelists-491355.shtml' target='_blank' rel='nofollow noopener' title='http://news.softpedia.com/news/oracle-mysteriously-fires-almost-all-of-its-top-java-evangelists-491355.shtml'>&quot;Oracle Mysteriously Fires Almost All of Its Top Java Evangelists&quot;(Softpedia News)</a> <a class='wiki-link-external' href='http://m.zdnet.co.kr/news_view.asp?article_id=20160316170411' target='_blank' rel='nofollow noopener' title='http://m.zdnet.co.kr/news_view.asp?article_id=20160316170411'>자바 에반젤리스트, 오라클 퇴사의 변 &quot;자바 구하려&quot;(ZDNet Korea)</a><br><br>자바 에반젤리스트는 Java의 전체적인 업계 내에서의 분위기를 결정지을 수 있는, 비교하자면 <a class='wiki-link-internal' href='/w/%EB%A6%AC%EB%88%85%EC%8A%A4' title='리눅스'>리눅스</a>계의 <a class='wiki-link-internal' href='/w/%EB%A6%AC%EB%88%84%EC%8A%A4%20%ED%86%A0%EB%A5%B4%EB%B0%9C%EC%8A%A4' title='리누스 토르발스'>리누스 토르발스</a> 같은 사람들인데, <a class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'>오라클</a>이 이 사람들을 꾸준히 해고하고 있다는 것이다. 장사를 독하게 하기로 유명한 오라클인지라, Java 자체가 지금은 물론이고 미래에도 그다지 수익성이 좋다고 할 수 없기에 망설임 없이 포기하려는 것이 아니냐라는 관측이 있다.  <a class='wiki-link-external' href='https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fjames.gosling.96%2Fposts%2F10154181433121328' target='_blank' rel='nofollow noopener' title='https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fjames.gosling.96%2Fposts%2F10154181433121328'>제임스 고슬링도 한마디 했다.</a><br><br>다만 이 부분은 사람에 따라 극단적으로 반응할 수도 있는 문제이므로<a class='wiki-fn-content' title='각 언어 프로그래머들의 자신의 언어에 대한 자부심은 가히 종교의 신앙과 비견할 만한 것이다.' href='#fn-41'><span class='target' id='rfn-41'></span>&#91;41&#93;</a> 업계 분위기에 대한 판단은 스스로 하도록 하자. 위에서도 언급했지만 Oracle JDK를 유료로 전환한 걸 보면 포기할 생각은 없는 듯하다.<br><br>2017년 8월 17일, 오라클이 Java EE를 포기한다고 발표했다. <a class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%EC%98%A4%ED%94%BC%EC%8A%A4' title='오픈오피스'>오픈오피스</a>, <a class='wiki-link-internal' href='/w/%EB%84%B7%EB%B9%88%EC%A6%88' title='넷빈즈'>넷빈즈</a> 때와 같이 <a class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%20%EC%86%8C%EC%8A%A4' title='오픈 소스'>오픈 소스</a> 생태계로 보내려 하고 있으며, <a class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'>아파치 소프트웨어 재단</a>과 <a class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'>이클립스</a> 재단이 Java EE를 넘겨받을 유력한 후보로 알려져 있다. <a class='wiki-link-external' href='https://blogs.oracle.com/theaquarium/opening-up-java-ee' target='_blank' rel='nofollow noopener' title='https://blogs.oracle.com/theaquarium/opening-up-java-ee'>Opening Up Java EE</a> 결국 이클립스 재단이 맡는 것으로 확정되었으며, Java EE의 오픈 소스화를 위한 9개 프로젝트를 추진한다고 밝혔다. <a class='wiki-link-external' href='http://www.ciokorea.com/news/35563' target='_blank' rel='nofollow noopener' title='http://www.ciokorea.com/news/35563'>#</a><a class='wiki-link-external' href='http://www.ciokorea.com/news/36380' target='_blank' rel='nofollow noopener' title='http://www.ciokorea.com/news/36380'>#</a> 다만 오라클이 Java EE라는 상표권까지 넘긴 것은 아니기 때문에, 새로운 이름을 공모하였고 이후 <strong>자카르타 EE(Jakarta EE)</strong>라는 새 명칭이 결정되었다. <a class='wiki-link-external' href='http://www.itworld.co.kr/news/108348' target='_blank' rel='nofollow noopener' title='http://www.itworld.co.kr/news/108348'>엔터프라이즈 자바의 새 이름 ‘자카르타 EE&#39;</a><a class='wiki-fn-content' title='원래 아파치 소프트웨어 재단이 &#39;자카르타&#39;라는 이름의 Java 오픈 소스 프로젝트(현재는 종료)를 소유하고 있었으나, 해당 명칭을 사용해도 된다고 허가하였다.' href='#fn-42'><span class='target' id='rfn-42'></span>&#91;42&#93;</a></div></div><h2 class='wiki-heading'><a id='s-12' href='#toc'>12.</a> <span id='도서'>도서<span class='wiki-edit-section'><a href='/edit/Java?section=50' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EC%84%9C%EC%A0%90' title='서점'>서점</a>에 가면 Java <a class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D' title='프로그래밍'>프로그래밍</a> 책이 무궁무진하게 많다. <u>Python, Java, C, SQL 4개는 <a class='wiki-link-internal' href='/w/%EC%84%9C%EC%A0%90' title='서점'>서점</a>에 가면 <a class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'>프로그래밍 언어</a> 분야에 별도의 카테고리를 차지</u>하고 있다.</div></div><h2 class='wiki-heading'><a id='s-13' href='#toc'>13.</a> <span id='여담'>여담<span class='wiki-edit-section'><a href='/edit/Java?section=51' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><ul class='wiki-list'><li><div class='wiki-paragraph'>Java의 창시자인 <a class='wiki-link-internal' href='/w/%EC%A0%9C%EC%9E%84%EC%8A%A4%20%EA%B3%A0%EC%8A%AC%EB%A7%81' title='제임스 고슬링'>제임스 고슬링</a> 옹은 진성 <a class='wiki-link-internal' href='/w/%EC%95%B1%EB%93%B1%EC%9D%B4' title='앱등이'>앱등이</a>다.<a class='wiki-fn-content' title='Java가 안드로이드의 기반이 되는 언어라는 점을 생각하면 아이러니...' href='#fn-43'><span class='target' id='rfn-43'></span>&#91;43&#93;</a> 집에서 쓰는 IT 기기에 대해 묻는 질문에 폰, 태블릿, 데스크탑, 랩탑 등 거의 모든 IT 기기를 애플사 제품으로 도배해놨음이 밝혀졌다. 가족들도 마찬가지. 정작 <a class='wiki-link-internal' href='/w/Apple' title='Apple'>애플</a>은 OS X 레오파드 업데이트 때 Java를 찬밥 취급했지만...<a class='wiki-fn-content' title='사실 애플은 독자적인 JDK를 제공하는지라 Java 개발자들을 매우 피곤하게 하는 회사이기도 하다.' href='#fn-44'><span class='target' id='rfn-44'></span>&#91;44&#93;</a></div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>제임스 고슬링과 Java를 창시할 때 같이 일했던 패트릭 노튼은 1999년 <a class='wiki-link-internal' href='/w/FBI' title='FBI'>FBI</a>의 <a class='wiki-link-internal' href='/w/%EC%95%84%EB%8F%99%ED%8F%AC%EB%A5%B4%EB%85%B8' title='아동포르노'>아동포르노</a> 함정수사로 인해 체포되었다.<a class='wiki-fn-content' title='단지 징역을 살지는 않고 FBI에서 1년 근무하는 것으로 퉁쳤다.' href='#fn-45'><span class='target' id='rfn-45'></span>&#91;45&#93;</a> 덤으로 IT 관계자들은 노튼이 <a class='wiki-link-internal' href='/w/%ED%8F%AC%EB%A5%B4%EB%85%B8' title='포르노'>기업 방화벽을 통과할 수 있는 통신도구를 만드는 일에 관심을 보인 이유</a>를 일찌감치 짐작했었다고...</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>조엘온 블로그로 유명한 조엘이 엄청나게 싫어하는 언어. 조엘 스폴스키가 Java를 싫어하는 이유로는 성능상의 문제나 문법상 너무 쉽다(...)<a class='wiki-fn-content' title='이 부분은 대학의 교육용 언어로서의 이야기다. 산업용으로서는 같은 기능을 개발하기 위한 언어는 쉬우면 쉬울수록 좋은 것이 당연하다. 물론 성능과 생산성 사이에서 적절한 균형을 잡아야 하겠지만.' href='#fn-46'><span class='target' id='rfn-46'></span>&#91;46&#93;</a>는 이유도 있지만, Java 자체가 &quot;위원회 기술&quot;이라는 이유도 큰 몫을 차지한다.<a class='wiki-fn-content' title='Java 상임 위원회에는 인텔, 오라클, JetBrains, 레드햇, ARM Holdings 등이 속해 있다. 모두 각자의 분야에서 내로라하는 기업들이다.' href='#fn-47'><span class='target' id='rfn-47'></span>&#91;47&#93;</a> 사실 이는 Java가 가진 태생적 문제인데 Java라는 언어가 <a class='wiki-link-internal' href='/w/C%23' title='C#'>C#</a>처럼 어느 특정 단체나 회사가 주도적으로 끌고가는 물건이 아니다 보니 위원회를 구성하는 각 기업들의 파워게임에 따라 중요한 문제의 해결방안이 빨리 처리되지 않는 경우도 있고 배가 산으로 가는 경우도 있다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>Java를 설치하고 환경변수를 설정할 때 CLASSPATH의 디렉토리를 보통 %JAVA_HOME%\lib로 설정하는데, 이렇게 하면 파일 실행 시 JVM이 무조건 \lib 경로에서 클래스 파일을 찾기 때문에 해당 파일을 찾거나 로드할 수 없다는 오류 메시지를 뿜게 된다. 매번 실행할 때마다 -classpath . 옵션을 주거나 CLASSPATH 환경변수의 디렉토리 끝에 ;.을 붙이면 해결할 수 있다.<a class='wiki-fn-content' title='&#39;.&#39;은 Java 클래스 파일이 위치한 해당 디렉토리를 의미한다.' href='#fn-48'><span class='target' id='rfn-48'></span>&#91;48&#93;</a> 물론 대부분의 IDE는 클래스 패스 설정을 자동으로 처리해 주지만, 역으로 그렇기에 클래스 패스에 대한 이해를 제대로 하지 않고 넘어가 버리는 경우가 많다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>Java에서 UI를 만들 때도 고려를 해야할 게, Java는 UI를 만들 때 AWT나 Swing 둘 중 하나 혹은 둘 다 선택하여 UI를 만드는 게 가능하다. 조심해야 할 점은, AWT로 생성한 UI는 Swing UI에 가려져버린다. 그래서 멀쩡히 잘 돌아가는 코드인데도 불구하고 배경이 컨트롤(콤보박스라거나)을 가려버리는 일이 있을 수 있다. <del>어차피 요즘은 둘 다 안 쓴다</del> 참고로 JetBrains의 <a class='wiki-link-internal' href='/w/%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD' title='통합 개발 환경'>IDE</a> 제품들은 이 Swing UI를 거의 마개조에 가깝게 뜯어고쳐서 쓰고 있다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>Java 클래스 바이트코드 매직넘버가 <code>#xca 0xFE 0xBA 0xBE</code>다. 이것을 붙이면 CAFEBABE다. CAFEBABE인 이유는, 제임스 고슬링과 다른 연구원들이 St. Michael&#39;s Alley라는 곳에 <a class='wiki-link-internal' href='/w/%EC%A0%90%EC%8B%AC' title='점심'>점심</a>을 먹으러 가곤 했다고 한다. 그 지방 전설에 의하면 그곳에서 <a class='wiki-link-internal' href='/w/%EB%8D%94%20%EA%B7%B8%EB%A0%88%EC%9D%B4%ED%8A%B8%ED%92%80%20%EB%8D%B0%EB%93%9C' title='더 그레이트풀 데드'>더 그레이트풀 데드</a>라는 <a class='wiki-link-internal' href='/w/%EB%B0%B4%EB%93%9C' title='밴드'>밴드</a>가 크게 성장하기 전에 연주하던 곳이라고 했다. 그리고 제임스 고슬링과 연구원들은 그곳을 Cafe Dead라고 불렀다. 그러다 CAFE DEAD가 헥스 넘버인 것을 알아냈다고 한다.<a class='wiki-fn-content' title='CAFEDEAD를 0xCA 0xFE 0xDE 0xAD로 바꿨을 때의 얘기인 듯하다.' href='#fn-49'><span class='target' id='rfn-49'></span>&#91;49&#93;</a> 그 때 마침 그는 파일 포맷 소스와 매직넘버를 개편하고 있었다.<a class='wiki-fn-content' title='그때 필요한 매직넘버는 2개였다. 하나는 오브젝트 파일이고, 또 다른 하나는 클래스 파일 매직넘버였다.' href='#fn-50'><span class='target' id='rfn-50'></span>&#91;50&#93;</a> 결국 Object 파일의 매직 넘버는 CAFEDEAD가 되었다. 나머지 하나, 클래스 파일의 매직넘버는 CAFE 다음에 맞을 만한 번호를 정하는 것인데, 그 때 적은 것이 BABE다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>2012년 말에는 Java에 보안 취약점이 발견되어 오라클에서 긴급 보안 패치를 발표했지만 또 다른 취약점이 발견돼버리는 바람에 Java를 계속 써야 하나 말아야 하는 논쟁이 벌어지기도 했다. 지금은 잠잠해진 상태.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>기존의 32bit용은 64bit 웹 브라우저에 사용할 수 없기에 64bit용 Java가 공개되어 있다. 그러나 32bit 웹 브라우저와 64bit 웹 브라우저를 각각 돌아가며 사용해야 할 필요가 있을 경우 둘 다 설치해야 제대로 돌아가기 때문에 번거로운 편이다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'>2018년 초부터 자바 설치파일로 위장한 <a class='wiki-link-internal' href='/w/%EB%9E%9C%EC%84%AC%EC%9B%A8%EC%96%B4' title='랜섬웨어'>랜섬웨어</a>가 기승을 부리고 있다. 어느날 갑자기 직접 설치파일을 다운받거나 하지도 않았는데 설치파일이 저절로 실행되며, 대부분의 감염자들은 이를 자동 업데이트로 인지하고 그대로 업데이트 해버려서 감염된다고 한다. 심지어 사용하는 운영체제의 언어를 인지하여 해당 언어의 자바 설치파일에 있는 문장과 이미지까지 철저하게 재현되어서 의심할 여지가 없다고 한다.</div></li></ul><div class='wiki-paragraph'></div><ul class='wiki-list'><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EB%A7%88%EC%9D%B8%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8' title='마인크래프트'>마인크래프트</a>는 원래 Java로 개발되었는데, 속도 문제 때문인지 <a class='wiki-link-internal' href='/w/%EB%A7%88%EC%9D%B8%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8/%EB%B2%A0%EB%93%9C%EB%9D%BD%20%EC%97%90%EB%94%94%EC%85%98' title='마인크래프트/베드락 에디션'>게임을 통째로 C++로 다시 짰다.</a> 그리고 실제로 속도가 10배 가까이 빨라졌다. 다만 기존의 Java 에디션으로 개발된 애드온들이 워낙 많고, 그것들이 베드락 에디션과 호환이 안 돼서 여전히 Java 에디션을 사용하는 유저들이 많다.</div></li></ul></div><h2 class='wiki-heading'><a id='s-14' href='#toc'>14.</a> <span id='관련 문서'>관련 문서<span class='wiki-edit-section'><a href='/edit/Java?section=52' rel='nofollow'>&#91;편집&#93;</a></span></span></h2><div class='wiki-heading-content'><ul class='wiki-list'><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/OCJP' title='OCJP'>OCJP</a></div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%91%9C%EC%A4%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC' title='전자정부표준프레임워크'>전자정부표준프레임워크</a></div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D' title='객체 지향 프로그래밍'>객체 지향 프로그래밍</a></div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/IntelliJ%20IDEA' title='IntelliJ IDEA'>IntelliJ IDEA</a></div></li><li><div class='wiki-paragraph'><a class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'>이클립스(통합 개발 환경)</a></div></li></ul><div class='wiki-paragraph'><br></div></div><div class='wiki-macro-footnote'><span class='footnote-list'><span class='target' id='fn-1'></span><a href='#rfn-1'>&#91;1&#93;</a> 당장 저기서 package문을 using문으로 System.out.println를 Console.WriteLine으로 바꾸기만 해도 완벽한 <a class='wiki-link-internal' href='/w/C%23' title='C#'>C#</a> 코드가 된다.(...)</span><span class='footnote-list'><span class='target' id='fn-2'></span><a href='#rfn-2'>&#91;2&#93;</a> 그도 그럴 것이, 원래 C#이 <a class='wiki-link-internal' href='/w/MS' title='MS'>MS</a>에서 Java의 기본적인 성질은 가져가지만, 각종 문제들을 해결한 언어이기 때문이다.</span><span class='footnote-list'><span class='target' id='fn-3'></span><a href='#rfn-3'>&#91;3&#93;</a> <a class='wiki-link-internal' href='/w/%EC%9D%BC%EB%B0%98%EB%AA%85%EC%82%AC' title='일반명사'>일반명사</a>나 이미 널리 알려진 표현 등은 상표로 등록 못한다. 물론 상표 등록을 못해도 제품이나 서비스 이름으로 못 쓰는 건 아니지만 해당 이름에 대해 배타적·독점적 권리를 확보하지 못한 상태가 돼서, 남들이 따라 해도 거기에 법적으로 태클을 걸 수가 없다.</span><span class='footnote-list'><span class='target' id='fn-4'></span><a href='#rfn-4'>&#91;4&#93;</a> Premier Support. 오라클에 비용을 내고 기술 지원을 받는 서비스이다.</span><span class='footnote-list'><span class='target' id='fn-5'></span><a href='#rfn-5'>&#91;5&#93;</a> Extended Support. 일반 지원이 종료된 후 추가적인 비용을 지불하여 기술 지원을 더 받을 수 있는 기간이다.</span><span class='footnote-list'><span class='target' id='fn-6'></span><a href='#rfn-6'>&#91;6&#93;</a> <a class='wiki-link-internal' href='/w/GCC' title='GCC'>GCC</a> 계열 Java 컴파일러인 GCJ에서는 이미 지원하고 있던 기능이다.(현재는 출시 중단)</span><span class='footnote-list'><span class='target' id='fn-7'></span><a href='#rfn-7'>&#91;7&#93;</a> <a class='wiki-link-internal' href='/w/C%23' title='C#'>C#</a>의 var와 똑같은 기능이다.</span><span class='footnote-list'><span class='target' id='fn-8'></span><a href='#rfn-8'>&#91;8&#93;</a> 따라서 이전 버전과 호환이 안 될 가능성도 있다. 이전 버전에서는 그냥 내부 메소드 쓰듯이 JavaFX를 갖다 썼다면, 이제는 라이브러리를 따로 인클루드해서 배포해야 하기 때문.</span><span class='footnote-list'><span class='target' id='fn-9'></span><a href='#rfn-9'>&#91;9&#93;</a> &#39;@Nonnull var x, @Nullable var y&#39;를 &#39;x.process(y)&#39;로 간략화할 수 있게 되었다.</span><span class='footnote-list'><span class='target' id='fn-10'></span><a href='#rfn-10'>&#91;10&#93;</a> 리눅스 커널, 하드웨어 프로그래밍</span><span class='footnote-list'><span class='target' id='fn-11'></span><a href='#rfn-11'>&#91;11&#93;</a> 3D 게임, 그래픽 프로그래밍</span><span class='footnote-list'><span class='target' id='fn-12'></span><a href='#rfn-12'>&#91;12&#93;</a> 특히 웹 개발 분야에서 해외의 경우 Java는 도태되는 추세고, <a class='wiki-link-internal' href='/w/Node.js' title='Node.js'>Node.js</a> 덕분에 서버와 프론트엔드 양 쪽에서 쓸 수 있는 <a class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'>JavaScript</a>와 <a class='wiki-link-internal' href='/w/Django' title='Django'>Django</a>를 통하여 쉽고 빠르게 백엔드 구축이 가능한 <a class='wiki-link-internal' href='/w/Python' title='Python'>Python</a>의 사용률이 늘어나고 있다.</span><span class='footnote-list'><span class='target' id='fn-13'></span><a href='#rfn-13'>&#91;13&#93;</a> JVM 위에서 구동 가능한 언어에 대해서는 영문 위키피디아의 <a class='wiki-link-external' href='https://en.wikipedia.org/wiki/List_of_JVM_languages' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/List_of_JVM_languages'>List of JVM languages</a> 참고.</span><span class='footnote-list'><span class='target' id='fn-14'></span><a href='#rfn-14'>&#91;14&#93;</a> 정말로 포인터를 써야 할 경우 Unsafe 클래스를 쓰면 된다. 다만 팩토리 메소드가 막혀있어 리플렉션을 사용해야만 이용할 수 있다.</span><span class='footnote-list'><span class='target' id='fn-15'></span><a href='#rfn-15'>&#91;15&#93;</a> 어차피 Java에서는 다중 상속을 포기함으로써 생기는 문제를 interface를 다중 구현할 수 있도록 하여 어느 정도 해결하기도 했다.</span><span class='footnote-list'><span class='target' id='fn-16'></span><a href='#rfn-16'>&#91;16&#93;</a> 쉽게 생각하면 배열 1000개를 할당받기 위해 운영체제에 1번 호출하여 한꺼번에 할당받지 않고, 1000번 호출하여 각각 할당받는 것이다. 기본적으로, 동적 메모리 할당은 운영체제에서 처리하기 때문에 속도가 느리다. 어떤 언어에서라도, 운영체제의 메모리 할당 횟수를 줄이는 것이 성능에 도움이 된다.</span><span class='footnote-list'><span class='target' id='fn-17'></span><a href='#rfn-17'>&#91;17&#93;</a> 하지만 연산자 오버로딩은 분명 제네릭 프로그래밍에 도움을 준다. 가령 제네릭 클래스 내에서 주어진 타입의 변수 두 개를 더하는 연산을 하고 싶다면? 더하는 연산 등 여러 일반적인 작업들은 Java의 primitive 타입에만 필요한 것은 아니다. 행렬 등이 그런 대표적인 예다. 이러한 측면에서 본다면 프로그래머의 작업에 있어서의 일관성은 훼손됐다고 볼 수도 있다.</span><span class='footnote-list'><span class='target' id='fn-18'></span><a href='#rfn-18'>&#91;18&#93;</a> 다만 제네릭은 Type Erasure를 사용하기 때문에 개념적으로 C++의 템플릿과 다르며, 할 수 있는 일도 거의 일반화 프로그래밍 자체로만 한정돼 있다.</span><span class='footnote-list'><span class='target' id='fn-19'></span><a href='#rfn-19'>&#91;19&#93;</a> 기존에 앞 문단 서술에 사용되었던 용어인 &quot;<a class='wiki-link-internal' href='/w/C%2B%2B#s-4.1' title='C++'>템플릿 메타 프로그래밍</a>&quot;은 개념을 오해하여 사용한 것이므로 &quot;<a class='wiki-link-internal' href='/w/C%2B%2B#s-4' title='C++'>일반화 프로그래밍</a>&quot;으로 대체하였다. 일반화 프로그래밍(<a class='wiki-link-external' href='https://en.wikipedia.org/wiki/Generic_programming' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/Generic_programming'>Generic Programming</a>)은 Java나 C#에도 &quot;제네릭&quot;이라는 형태로 구현되어 있다. 그러나 템플릿 메타 프로그래밍(<a class='wiki-link-external' href='https://en.wikipedia.org/wiki/Template_metaprogramming' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/Template_metaprogramming'>Template Meta-Programming</a>)은 Java나 C#에서 전혀 구현되지 않는 별도의 개념이다. 아마도 C++에서 쓰는 &quot;<a class='wiki-link-internal' href='/w/%ED%85%9C%ED%94%8C%EB%A6%BF#s-6' title='템플릿'>템플릿</a>&quot;이라는 용어와 Java의 &quot;제네릭&quot;이라는 용어가 같은 것을 지칭한다고 착각해서 나온 결과로 추정된다. C++ 템플릿 프로그래밍 = &quot;<a class='wiki-link-internal' href='/w/C%2B%2B#s-4' title='C++'>일반화 프로그래밍</a> + <a class='wiki-link-internal' href='/w/C%2B%2B#s-4.1' title='C++'>템플릿 메타 프로그래밍</a>&quot;, Java/C# 제네릭 = &quot;일반화 프로그래밍&quot;으로 이해하면 쉽다. &quot;템플릿 메타 프로그래밍&quot;은 <a class='wiki-link-internal' href='/w/C%2B%2B' title='C++'>C++</a>, <a class='wiki-link-internal' href='/w/D%EC%96%B8%EC%96%B4' title='D언어'>D</a> 등 극소수의 언어만 지원한다.</span><span class='footnote-list'><span class='target' id='fn-20'></span><a href='#rfn-20'>&#91;20&#93;</a> 이 부분은 주관적인 것으로 C/C++가 Java보다 가독성이 좋지 않다는 것에 대해 동의하지 않는 시각도 많다는 점을 알려둔다.</span><span class='footnote-list'><span class='target' id='fn-21'></span><a href='#rfn-21'>&#91;21&#93;</a> Java는 <a class='wiki-link-internal' href='/w/JIT' title='JIT'>JIT</a> 컴파일을 기본적으로 사용하기 때문이다. C#이나 PHP 7와 같은 고수준 언어도 해당사항이다. </span><span class='footnote-list'><span class='target' id='fn-22'></span><a href='#rfn-22'>&#91;22&#93;</a> 메모리를 훑으면서 순간적으로 프로그램이 얼어붙어 멈추는 현상.</span><span class='footnote-list'><span class='target' id='fn-23'></span><a href='#rfn-23'>&#91;23&#93;</a> 이를 <a class='wiki-link-internal' href='/w/%ED%95%9C%EC%A7%80%EC%9A%B0' title='한지우'>gotta catch &#39;em all</a> 패턴이라고 한다.</span><span class='footnote-list'><span class='target' id='fn-24'></span><a href='#rfn-24'>&#91;24&#93;</a> 물론 이렇게 짜면 안되지만 구조적으로 강요받는 형편.</span><span class='footnote-list'><span class='target' id='fn-25'></span><a href='#rfn-25'>&#91;25&#93;</a> 이쪽은 RuntimeException 계열의 예외로, 이것을 던지는 메소드가 throws에 명시적으로 던진다고 선언하지 않았을 경우 검사를 하지 않아도 된다.</span><span class='footnote-list'><span class='target' id='fn-26'></span><a href='#rfn-26'>&#91;26&#93;</a> 대한민국에 국한되는 경향이 강하긴 하지만 현재 한국에서 이러한 예외처리를 <strong>코딩하는 순간에</strong> 인지하는 개발자는 드물다. 국비지원 학원을 막 졸업한 신입들은 말 할 것도 없으며 현업 몇년 한 초중급 경력자들 역시 이를 인지하지 못하는 경우가 허다하기 때문에, 어찌보면 대한민국 IT계의 버그처리와 예외처리에 있어서만큼은 장점으로 볼 수도 있다.</span><span class='footnote-list'><span class='target' id='fn-27'></span><a href='#rfn-27'>&#91;27&#93;</a> 사실 C(C++이 아니다)는 C99기준 stdio.h를 포함하지 않아도 puts, printf 등을 사용할 수 있다. C, C++ 공통으로는(C++11기준) main에 int를 붙이지 않아도 콤파일이 된다. 따라서 더 짧게 쓴다면 <br>main() {<br>　　puts(&quot;Hello&quot;);<br>}<br>이 된다.</span><span class='footnote-list'><span class='target' id='fn-28'></span><a href='#rfn-28'>&#91;28&#93;</a> 그 <a class='wiki-link-internal' href='/w/%EB%A7%88%EC%84%B8%EB%9D%BC%ED%8B%B0' title='마세라티'>마세라티</a>가 맞다. 자신이 탈수나 있을지도 모르는 마세라티를 타면 어떻게 해야 될까... 라는 쓸데없는 고민을 하는 것을 비유하는 문제로, 당장에 쓸데없는 기능을 위해 과도하게 투자하는 것을 의미한다.</span><span class='footnote-list'><span class='target' id='fn-29'></span><a href='#rfn-29'>&#91;29&#93;</a> 프로그래밍 언어를 좀 더 쉽게 표현할 수 있도록 하는 보조문법. C에서 구조체 포인터를 쓸 때 (*ptr).num은 ptr-&gt;num으로도 표현 가능하므로, -&gt;는 문법적 설탕이라고 할 수 있다.</span><span class='footnote-list'><span class='target' id='fn-30'></span><a href='#rfn-30'>&#91;30&#93;</a> 컬렉션(Collection)의 이터레이터를 확장해서 처리할 수 있는 개념으로, 이터레이터의 원소를 필터링해서 원하는 원소만 뽑거나, 원소갯수를 줄여버리고, 이렇게 다시 뽑혀진 원소들로 갖가지 처리를 만드는 등 &#39;함수적인(functional)&#39; 기능을 제공한다.</span><span class='footnote-list'><span class='target' id='fn-31'></span><a href='#rfn-31'>&#91;31&#93;</a> 정작 람다 표현식의 추가는 Java 진영 내에서 논란이 있다. 람다 식이 뒤늦게 추가된 것도 코드 리딩이 어려워진다고 싫어하는 개발자가 많아서였다.</span><span class='footnote-list'><span class='target' id='fn-32'></span><a href='#rfn-32'>&#91;32&#93;</a> 멀리 갈 것 없이, C언어의 stdio.h와 자바의 System.out을 비교해보자. Java는 직관적으로 &#39;시스템&#39;에서 뭔가가 &#39;나온다&#39;는 것을 쉽게 인식할 수 있지만, stdio.h를 봤을 때 직관적으로 뭘 떠올릴까? 저걸 처음 보고 STanDard Input and Output을 떠올릴 사람이 얼마나 있을까? <del>물론 C를 하다 보면 언어 기능 자체가 적어 파악하기가 쉬운 건 함정이다</del> </span><span class='footnote-list'><span class='target' id='fn-33'></span><a href='#rfn-33'>&#91;33&#93;</a> 실제로 Java에서 기본 제공하는 정렬 기능은 Collections 클래스의 정적 메소드인 sort(array)를 호출하도록 작성되어 있다.</span><span class='footnote-list'><span class='target' id='fn-34'></span><a href='#rfn-34'>&#91;34&#93;</a> JSP의 목적이 HTML 페이지를 동적으로 만들어내는 것이다. JSP 소스는 Java 서블릿 코드로 변환되어 서버에서 실행되고, 서버는 이 HTML 결과를 브라우저에 보여준다. JSP 페이지는 HTML 페이지에 Java 코드가 포함되어 있는 식으로 되어 있는 경우가 많고, 이 점은 <a class='wiki-link-internal' href='/w/PHP' title='PHP'>PHP</a>, <a class='wiki-link-internal' href='/w/ASP' title='ASP'>ASP.NET</a> 등과 비슷한 편이다. 반면 Java 서블릿은 서버 쪽에서 하는 일에 관심이 많지만 출력에 대한 관심은 적다. 필요하다면 브라우저에 출력을 전혀 안 보낼 수도 있다. 최근에는 Server side script language로 HTML 페이지를 동적으로 만드는 식으로는 프로그래밍을 하지 않는다. JSP, PHP와 같은 Server side script language로는 서버에 있는 자원의 접근을 주로 하고(DB 연산, File 연산 등등) 화면에 보여주는 UI는 HTML/CSS/JavaScript로만 한다. 따라서 Client side와 Server side 간에 통신이 필요한데 이는 XHR(XML HTTP Request)를 이용한다. 이러한 프로그래밍 기법을 나타내는 표현이 REST 내지는 Open API이다.</span><span class='footnote-list'><span class='target' id='fn-35'></span><a href='#rfn-35'>&#91;35&#93;</a> Java는 현용 프로그래밍 언어 중에서는 가장 Verbose한(장황한) 언어로 꼽힌다. 즉, 같은 의미인데 많은 타이핑이 필요하다.</span><span class='footnote-list'><span class='target' id='fn-36'></span><a href='#rfn-36'>&#91;36&#93;</a> Java는 버전 10에서 와서야 이와 같은 타입 추론 기능이 가능해졌다.</span><span class='footnote-list'><span class='target' id='fn-37'></span><a href='#rfn-37'>&#91;37&#93;</a> 안드로이드의 Java 라이선스 무단 사용으로 구글이 오라클과 법정 싸움을 한 여파로 보인다.</span><span class='footnote-list'><span class='target' id='fn-38'></span><a href='#rfn-38'>&#91;38&#93;</a> 기초적인 C-문법의 일부인 if문, while문 등을 제외하면 공통점이 많지 않다.</span><span class='footnote-list'><span class='target' id='fn-ES6'></span><a href='#rfn-39'>&#91;ES6&#93;</a> ECMAScript 6에서 Class가 생겼다! 그래도 여전히 Java의 클래스와는 겉보기에만 비슷할 뿐 열어보면 다르다. ES6에서 나온 클래스는 기존에 있던 prototype 객체지향 프로그래밍을 조금 더 쉽게 하게 해주는 문법적 설탕이다.</span><span class='footnote-list'><span class='target' id='fn-40'></span><a href='#rfn-40'>&#91;40&#93;</a> 다만 인도네시아의 어원은 인도와 관련이 <strong>있다</strong>. 인도네시아라는 이름은 &#39;<a class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84%EC%96%91' title='인도양'>인도양</a>의 섬&#39;들이라는 <a class='wiki-link-internal' href='/w/%EA%B7%B8%EB%A6%AC%EC%8A%A4%EC%96%B4' title='그리스어'>그리스어</a>·<a class='wiki-link-internal' href='/w/%EB%9D%BC%ED%8B%B4%EC%96%B4' title='라틴어'>라틴어</a>식 표현이기 때문. 이런 인도네시아와 인도의 관계는, JavaScript가 Java와 별 관련은 없어도 그 이름을 빌려 왔다는 점에서 왠지 흡사하다.</span><span class='footnote-list'><span class='target' id='fn-41'></span><a href='#rfn-41'>&#91;41&#93;</a> 각 언어 프로그래머들의 자신의 언어에 대한 자부심은 가히 종교의 신앙과 비견할 만한 것이다.</span><span class='footnote-list'><span class='target' id='fn-42'></span><a href='#rfn-42'>&#91;42&#93;</a> 원래 <a class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'>아파치 소프트웨어 재단</a>이 &#39;자카르타&#39;라는 이름의 Java 오픈 소스 프로젝트(현재는 종료)를 소유하고 있었으나, 해당 명칭을 사용해도 된다고 허가하였다.</span><span class='footnote-list'><span class='target' id='fn-43'></span><a href='#rfn-43'>&#91;43&#93;</a> Java가 <a class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'>안드로이드</a>의 기반이 되는 언어라는 점을 생각하면 아이러니...</span><span class='footnote-list'><span class='target' id='fn-44'></span><a href='#rfn-44'>&#91;44&#93;</a> 사실 애플은 독자적인 JDK를 제공하는지라 Java 개발자들을 매우 피곤하게 하는 회사이기도 하다.</span><span class='footnote-list'><span class='target' id='fn-45'></span><a href='#rfn-45'>&#91;45&#93;</a> 단지 징역을 살지는 않고 FBI에서 1년 근무하는 것으로 퉁쳤다.</span><span class='footnote-list'><span class='target' id='fn-46'></span><a href='#rfn-46'>&#91;46&#93;</a> 이 부분은 대학의 <strong>교육용</strong> 언어로서의 이야기다. 산업용으로서는 같은 기능을 개발하기 위한 언어는 쉬우면 쉬울수록 좋은 것이 당연하다. 물론 성능과 생산성 사이에서 적절한 균형을 잡아야 하겠지만.</span><span class='footnote-list'><span class='target' id='fn-47'></span><a href='#rfn-47'>&#91;47&#93;</a> Java 상임 위원회에는 <a class='wiki-link-internal' href='/w/%EC%9D%B8%ED%85%94' title='인텔'>인텔</a>, <a class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'>오라클</a>, <a class='wiki-link-internal' href='/w/JetBrains' title='JetBrains'>JetBrains</a>, <a class='wiki-link-internal' href='/w/%EB%A0%88%EB%93%9C%ED%96%87' title='레드햇'>레드햇</a>, <a class='wiki-link-internal' href='/w/ARM%20Holdings' title='ARM Holdings'>ARM Holdings</a> 등이 속해 있다. 모두 각자의 분야에서 내로라하는 기업들이다.</span><span class='footnote-list'><span class='target' id='fn-48'></span><a href='#rfn-48'>&#91;48&#93;</a> &#39;.&#39;은 Java 클래스 파일이 위치한 해당 디렉토리를 의미한다.</span><span class='footnote-list'><span class='target' id='fn-49'></span><a href='#rfn-49'>&#91;49&#93;</a> CAFEDEAD를 0xCA 0xFE 0xDE 0xAD로 바꿨을 때의 얘기인 듯하다.</span><span class='footnote-list'><span class='target' id='fn-50'></span><a href='#rfn-50'>&#91;50&#93;</a> 그때 필요한 매직넘버는 2개였다. 하나는 오브젝트 파일이고, 또 다른 하나는 클래스 파일 매직넘버였다.</span></div></div> <!----></div> <!----></div> <!----></div> <div data-v-0111d0e0 data-v-21f1cc50><div class="p" data-v-0111d0e0><iframe src="//arca.live/static/ad/powerlink_pc.html?v=19" width="100%" height="100" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" data-v-0111d0e0></iframe></div> <div class="m" data-v-0111d0e0><iframe src="//arca.live/static/ad/powerlink_mobile.html?v=19" width="100%" height="175" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" data-v-0111d0e0></iframe></div></div> <footer data-v-21f1cc50><p data-v-21f1cc50><img alt="크리에이티브 커먼즈 라이선스" style="border-width: 0;" src="/img/cc-by-nc-sa-2.0-88x31.png"><br>
이 저작물은 <a rel="license" href="//creativecommons.org/licenses/by-nc-sa/2.0/kr/">CC BY-NC-SA 2.0 KR</a>에 따라 이용할 수 있습니다. (단, 라이선스가 명시된 일부 문서 및 삽화 제외)<br>
기여하신 문서의 저작권은 각 기여자에게 있으며, 각 기여자는 기여하신 부분의 저작권을 갖습니다.
<br>
<br>
나무위키는 백과사전이 아니며 검증되지 않았거나, 편향적이거나, 잘못된 서술이 있을 수 있습니다.<br>
나무위키는 위키위키입니다. 여러분이 직접 문서를 고칠 수 있으며, 다른 사람의 의견을 원할 경우 직접 토론을 발제할 수 있습니다.</p></footer></article></div> <div data-v-21b51625 data-v-832c58d0><div id="tchika10623f2f" data-v-700aa36e data-v-832c58d0><h5 data-v-700aa36e>최근 변경</h5> <ul data-v-700aa36e><a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> <a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> <a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> <a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> <a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> <a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> <a data-v-700aa36e><span data-v-700aa36e>00:00</span>갱신중...</a> </ul> <a href="/RecentChanges" data-v-700aa36e>[더 보기]</a></div> <div data-v-7c14d624 data-v-832c58d0><h5 data-v-7c14d624>나무뉴스</h5> <ul data-v-7c14d624><li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> <li data-v-7c14d624>갱신중...</li> </ul> <a href="//namu.news/" rel="noopener" target="_blank" data-v-7c14d624>[더 보기]</a></div> <div id="tchika021fec9a" class="ab" data-v-21b51625 data-v-832c58d0><div id="tchikafd272151" data-v-832c58d0></div></div> <footer data-v-4ea1cb37 data-v-832c58d0><p data-v-4ea1cb37 data-v-832c58d0>namu.wiki<span data-v-269a4367 data-v-832c58d0></span><a href="mailto:support@namu.wiki" data-v-4ea1cb37 data-v-832c58d0>Contáctenos</a><span data-v-269a4367 data-v-832c58d0></span><a href="/Policy" data-v-832c58d0>Términos de uso</a><span data-v-269a4367 data-v-832c58d0></span>Operado por umanle S.R.L.<span data-v-269a4367 data-v-832c58d0></span>Hecho con &lt;3 en Asunción, República del Paraguay</p> <p data-v-4ea1cb37 data-v-832c58d0>Su zona horaria es <span data-v-4ea1cb37 data-v-832c58d0>GMT</span><span data-v-269a4367 data-v-832c58d0></span>Impulsado por <i data-v-4ea1cb37 data-v-832c58d0>the seed engine</i></p></footer></div> <ul data-v-5a2e7ca9 data-v-832c58d0><li data-v-5a2e7ca9><a href="#" data-v-5a2e7ca9><span class="ion-ios-cog" data-v-5a2e7ca9></span></a></li> <li data-v-5a2e7ca9><a href="#" data-v-5a2e7ca9><span class="ion-ios-arrow-up" data-v-5a2e7ca9></span></a></li> <li data-v-5a2e7ca9><a href="#" data-v-5a2e7ca9><span class="ion-ios-arrow-down" data-v-5a2e7ca9></span></a></li></ul> <!----> <!----></div><!----></div><script>window.INITIAL_STATE={"config":{"hash":"9e69d56478171dea2f901eca3a46d8ac","wiki.force_recaptcha_public":"6LeuueQUAAAAANjuKHp7L92aqpF1pOyEKTb9-53m","wiki.recaptcha_public":"6LcUt7kUAAAAAI-n3Y-xhmhy0IvAJE26ltQes6md","wiki.editagree_text":"문서 편집을 \u003Cstrong\u003E저장\u003C/strong\u003E하면 당신은 기여한 내용을 \u003Cstrong\u003ECC-BY-NC-SA 2.0 KR\u003C/strong\u003E으로 배포하고 기여한 문서에 대한 하이퍼링크나 URL을 이용하여 저작자 표시를 하는 것으로 충분하다는 데 동의하는 것입니다. 이 \u003Cstrong\u003E동의는 철회할 수 없습니다.\u003C/strong\u003E","wiki.front_page":"나무위키:대문","wiki.site_name":"나무위키","wiki.copyright_url":"//creativecommons.org/licenses/by-nc-sa/2.0/kr/","wiki.canonical_url":"https://namu.wiki","wiki.copyright_text":"\u003Cimg alt=\"크리에이티브 커먼즈 라이선스\" style=\"border-width: 0;\" src=\"/img/cc-by-nc-sa-2.0-88x31.png\"\u003E\u003Cbr\u003E\r\n이 저작물은 \u003Ca rel=\"license\" href=\"//creativecommons.org/licenses/by-nc-sa/2.0/kr/\"\u003ECC BY-NC-SA 2.0 KR\u003C/a\u003E에 따라 이용할 수 있습니다. (단, 라이선스가 명시된 일부 문서 및 삽화 제외)\u003Cbr\u003E\r\n기여하신 문서의 저작권은 각 기여자에게 있으며, 각 기여자는 기여하신 부분의 저작권을 갖습니다.\r\n\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n나무위키는 백과사전이 아니며 검증되지 않았거나, 편향적이거나, 잘못된 서술이 있을 수 있습니다.\u003Cbr\u003E\r\n나무위키는 위키위키입니다. 여러분이 직접 문서를 고칠 수 있으며, 다른 사람의 의견을 원할 경우 직접 토론을 발제할 수 있습니다.","wiki.sitenotice":null,"wiki.logo_url":"/img/icon.png"},"localConfig":{},"page":{"title":"Java","viewName":"wiki","data":{"rev":null,"redirect":null,"document":{"namespace":"문서","title":"Java","forceShowNamespace":false},"date":1598938634,"content":"\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%2B%EC%9C%A0%EB%8F%84.png' title='파일:나무위키+유도.png' rel='nofollow'\u003E\u003Cspan class='wiki-image-align-left' style='width:21px;'\u003E\u003Cspan class='wiki-image-wrapper' style='width: 100%;'\u003E\u003Cimg class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='\u003E\u003Cimg class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='36499' data-src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'\u003E\u003Cnoscript\u003E\u003Cimg class='wiki-image' width='100%' src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'\u003E\u003C/noscript\u003E\u003C/span\u003E\u003C/span\u003E\u003C/a\u003E   \u003Cdiv style=\"display:inline;display:none\"\u003E\u003Cstrong\u003E\u003C/strong\u003E은(는) 여기로 연결됩니다. \u003C/div\u003E동음이의어에 대한 내용은 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94' title='자바'\u003E자바\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94#s-' title='자바'\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94' title='자바'\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i1-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E 참조하십시오.\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%2B%EC%9C%A0%EB%8F%84.png' title='파일:나무위키+유도.png' rel='nofollow'\u003E\u003Cspan class='wiki-image-align-left' style='width:21px;'\u003E\u003Cspan class='wiki-image-wrapper' style='width: 100%;'\u003E\u003Cimg class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='\u003E\u003Cimg class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='36499' data-src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'\u003E\u003Cnoscript\u003E\u003Cimg class='wiki-image' width='100%' src='//w.namu.la/s/e2d4341053370ae1322528d26f7be82fdd8e47a09eb6a6504ae3e5856c06f4406b9558cbb467b65af43c1d396ba8fb6966ea9aa16ab6df16207ed4e9c9b01c66193b9b704f3c20b3891268f8cf8398e7e6432d3dcac91b131134b7fbaf439d0a' alt='파일:나무위키+유도.png'\u003E\u003C/noscript\u003E\u003C/span\u003E\u003C/span\u003E\u003C/a\u003E   \u003Cdiv style=\"display:inline;display:none\"\u003E\u003Cstrong\u003E\u003C/strong\u003E은(는) 여기로 연결됩니다. \u003C/div\u003E인간어에 대한 내용은 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%EC%96%B4' title='자바어'\u003E자바어\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%EC%96%B4#s-' title='자바어'\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%EC%96%B4' title='자바어'\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, 에 대한 내용은 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='#i2-s-' title=''\u003E\u003C/a\u003E 문단을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E 부분을\u003C/div\u003E\u003C/div\u003E 참조하십시오.\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%2B%ED%95%98%EC%9C%84%EB%AC%B8%EC%84%9C.png' title='파일:나무위키+하위문서.png' rel='nofollow'\u003E\u003Cspan class='wiki-image-align-left' style='width:21px;'\u003E\u003Cspan class='wiki-image-wrapper' style='width: 100%;'\u003E\u003Cimg class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='\u003E\u003Cimg class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='11402' data-src='//w.namu.la/s/e7fa4fff2b0926b0190ccc1cdfd51123f98b2c5fdf7524ee5057f1b216a33084a71f9dabcb4c0e17daada6747a0acb61e6ba8993f66acfb7a77148109599828648f22881abe596ac0f39910306ffd1a830d21287861456f90b0ff8f99bc1c669' alt='파일:나무위키+하위문서.png'\u003E\u003Cnoscript\u003E\u003Cimg class='wiki-image' width='100%' src='//w.namu.la/s/e7fa4fff2b0926b0190ccc1cdfd51123f98b2c5fdf7524ee5057f1b216a33084a71f9dabcb4c0e17daada6747a0acb61e6ba8993f66acfb7a77148109599828648f22881abe596ac0f39910306ffd1a830d21287861456f90b0ff8f99bc1c669' alt='파일:나무위키+하위문서.png'\u003E\u003C/noscript\u003E\u003C/span\u003E\u003C/span\u003E\u003C/a\u003E   하위 문서: \u003Ca class='wiki-link-internal' href='/w/Java/%EB%B2%84%EC%A0%84%20%EC%A0%95%EB%B3%B4' title='Java/버전 정보'\u003EJava/버전 정보\u003C/a\u003E\u003Cdiv style=\"display:inline\"\u003E, \u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'\u003EJava/문법\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E, \u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003Ca class='wiki-self-link' href='' title=''\u003E\u003C/a\u003E\u003C/div\u003E\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cdiv style=\"word-break:keep-all\"\u003E\u003Cdiv class='wiki-table-wrap table-center' style='width:100%'\u003E\u003Ctable class='wiki-table' style='background-color:white; width:100%; border:2px solid deepskyblue;' data-dark-style='background-color:#222;'\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd colspan='10' style='background-color:deepskyblue; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E\u003Cspan class='wiki-color' style='color:white'\u003E\u003Ca class='wiki-link-external' href='http://www.tiobe.com/tiobe_index' target='_blank' rel='nofollow noopener' title='http://www.tiobe.com/tiobe_index'\u003E\u003Cspan class='wiki-color' style='color:#FFF'\u003ETIOBE\u003C/span\u003E\u003C/a\u003E에서 선정한 2020년 8월 기준 검색어 점유율 상위 20개 \u003Ca class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'\u003E\u003Cspan class='wiki-color' style='color:white'\u003E프로그래밍 언어\u003C/span\u003E\u003C/a\u003E\u003C/span\u003E\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='width:5%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E1\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:15%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/C%EC%96%B8%EC%96%B4' title='C언어'\u003EC\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:5%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E2\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:15%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-self-link' href='/w/Java' title='Java'\u003EJava\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:5%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E3\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:15%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:5%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E4\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:15%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:5%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E5\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='width:15%; text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/C%23' title='C#'\u003EC#\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E6\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Visual%20Basic%20.NET' title='Visual Basic .NET'\u003EVisual Basic .NET\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E7\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E8\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/R(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='R(프로그래밍 언어)'\u003ER\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E9\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/PHP' title='PHP'\u003EPHP\u003C/a\u003E \u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E10\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Structured%20Query%20Language' title='Structured Query Language'\u003ESQL\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E11\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Go(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Go(프로그래밍 언어)'\u003EGo\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E12\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Swift(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Swift(프로그래밍 언어)'\u003ESwift\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E13\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Perl' title='Perl'\u003EPerl\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E14\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4' title='어셈블리어'\u003E어셈블리어\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E15\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Ruby' title='Ruby'\u003ERuby\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E16\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/MATLAB' title='MATLAB'\u003EMATLAB\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E17\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Visual%20Basic' title='Visual Basic'\u003EVisual Basic\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E18\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Groovy' title='Groovy'\u003EGroovy\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E19\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Objective-C' title='Objective-C'\u003EObjective-C\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E20\u003C/strong\u003E\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Rust' title='Rust'\u003ERust\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003C/tbody\u003E\u003C/table\u003E\u003C/div\u003E\u003C/div\u003E\u003Cbr\u003E\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cdiv class='wiki-table-wrap table-right' style='width:400px'\u003E\u003Ctable class='wiki-table' style='width:100%;'\u003E\u003Ctbody\u003E\u003Ctr\u003E\u003Ctd colspan='2' style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E\u003Cspan class='wiki-size size-up-1'\u003E자바\u003C/span\u003E\u003C/strong\u003E\u003Cbr\u003EJava\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd colspan='2' style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:java%20%EB%A1%9C%EA%B3%A0.png' title='파일:java 로고.png' rel='nofollow'\u003E\u003Cspan class='wiki-image-align-normal' style='width:25%;'\u003E\u003Cspan class='wiki-image-wrapper' style='width: 100%;'\u003E\u003Cimg class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjYyIiBoZWlnaHQ9IjQ4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='\u003E\u003Cimg class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjYyIiBoZWlnaHQ9IjQ4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='15934' data-src='//w.namu.la/s/d307e68a02cda1962f70371be5ba91c330d1ea6a281c20c89ec4af389f4652a65376506adf9cc76b4c3810632469645ff3a71b7e9202809da711adf1d7d89478e7cc47530e38520a3a321ef22822f57ebc6420d7cc89d79e7b4d7d1840500081' alt='파일:java 로고.png'\u003E\u003Cnoscript\u003E\u003Cimg class='wiki-image' width='100%' src='//w.namu.la/s/d307e68a02cda1962f70371be5ba91c330d1ea6a281c20c89ec4af389f4652a65376506adf9cc76b4c3810632469645ff3a71b7e9202809da711adf1d7d89478e7cc47530e38520a3a321ef22822f57ebc6420d7cc89d79e7b4d7d1840500081' alt='파일:java 로고.png'\u003E\u003C/noscript\u003E\u003C/span\u003E\u003C/span\u003E\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E개발\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:left;'\u003E\u003Cdiv class='wiki-paragraph'\u003E오라클\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E버전\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:left;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cspan class='wiki-size size-up-1'\u003E\u003Cstrong\u003E14\u003C/strong\u003E\u003C/span\u003E\u003Cbr\u003E\u003Ca class='wiki-link-external' href='http://www.aitimes.kr/news/articleView.html?idxno=15716' target='_blank' rel='nofollow noopener' title='http://www.aitimes.kr/news/articleView.html?idxno=15716'\u003E2020년 3월 18일 업데이트\u003C/a\u003E\u003Cbr\u003E\u003Cspan class='wiki-size size-up-1'\u003E15\u003C/span\u003E\u003Cbr\u003E2020년 9월 출시 예정\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003Ctr\u003E\u003Ctd style='text-align:center;'\u003E\u003Cdiv class='wiki-paragraph'\u003E웹사이트\u003C/div\u003E\u003C/td\u003E\u003Ctd style='text-align:left;'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-external' href='https://www.oracle.com/java/' target='_blank' rel='nofollow noopener' title='https://www.oracle.com/java/'\u003E홈페이지\u003C/a\u003E\u003C/div\u003E\u003C/td\u003E\u003C/tr\u003E\u003C/tbody\u003E\u003C/table\u003E\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Cdiv class='wiki-macro-toc' id='toc'\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-1'\u003E1\u003C/a\u003E. 개요\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-2'\u003E2\u003C/a\u003E. 어원\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-3'\u003E3\u003C/a\u003E. 분류\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4'\u003E4\u003C/a\u003E. 역사\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.1'\u003E4.1\u003C/a\u003E. JDK 1.0a\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.2'\u003E4.2\u003C/a\u003E. JDK 1.0a2\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.3'\u003E4.3\u003C/a\u003E. JDK 1.0\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.4'\u003E4.4\u003C/a\u003E. JDK 1.1\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.5'\u003E4.5\u003C/a\u003E. J2SE 1.2\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.6'\u003E4.6\u003C/a\u003E. J2SE 1.3\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.7'\u003E4.7\u003C/a\u003E. J2SE 1.4\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.8'\u003E4.8\u003C/a\u003E. J2SE 5\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.9'\u003E4.9\u003C/a\u003E. Java SE 6\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.10'\u003E4.10\u003C/a\u003E. Java SE 7\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.11'\u003E4.11\u003C/a\u003E. Java SE 8\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.12'\u003E4.12\u003C/a\u003E. Java SE 9\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.13'\u003E4.13\u003C/a\u003E. Java SE 10\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.14'\u003E4.14\u003C/a\u003E. Java SE 11\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.15'\u003E4.15\u003C/a\u003E. Java SE 12\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.16'\u003E4.16\u003C/a\u003E. Java SE 13\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.17'\u003E4.17\u003C/a\u003E. Java SE 14\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-4.18'\u003E4.18\u003C/a\u003E. Java SE 15\u003C/span\u003E\u003C/div\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-5'\u003E5\u003C/a\u003E. \u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'\u003E문법\u003C/a\u003E\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-6'\u003E6\u003C/a\u003E. C, C++와의 비교\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7'\u003E7\u003C/a\u003E. 특징\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.1'\u003E7.1\u003C/a\u003E. 장점\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.1.1'\u003E7.1.1\u003C/a\u003E. 수많은 개발자와 레퍼런스\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.1.2'\u003E7.1.2\u003C/a\u003E. 비교적 높은 생산성\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.1.3'\u003E7.1.3\u003C/a\u003E. 기기 호환성\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.1.4'\u003E7.1.4\u003C/a\u003E. 안정성\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.1.5'\u003E7.1.5\u003C/a\u003E. 소스 코드 가독성\u003C/span\u003E\u003C/div\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2'\u003E7.2\u003C/a\u003E. 단점\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.1'\u003E7.2.1\u003C/a\u003E. 속도 문제\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.1.1'\u003E7.2.1.1\u003C/a\u003E. JVM 로딩 속도 문제\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.1.2'\u003E7.2.1.2\u003C/a\u003E. 가상 머신 바이트코드 실행 속도 문제\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.1.3'\u003E7.2.1.3\u003C/a\u003E. 가비지 컬렉션에 의한 실행 지연 문제\u003C/span\u003E\u003C/div\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.2'\u003E7.2.2\u003C/a\u003E. 불편한 \u003Ca class='wiki-link-internal' href='/w/%EC%98%88%EC%99%B8%20%EC%B2%98%EB%A6%AC' title='예외 처리'\u003E예외 처리\u003C/a\u003E\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.3'\u003E7.2.3\u003C/a\u003E. 소스 코드 길이\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.4'\u003E7.2.4\u003C/a\u003E. 언어적 불편함\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.4.1'\u003E7.2.4.1\u003C/a\u003E. 명사형 사고를 강제\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-7.2.4.2'\u003E7.2.4.2\u003C/a\u003E. \u003Ca class='wiki-link-internal' href='/w/%ED%81%B4%EB%A1%9C%EC%A0%80' title='클로저'\u003E클로저\u003C/a\u003E 미지원\u003C/span\u003E\u003C/div\u003E\u003C/div\u003E\u003C/div\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-8'\u003E8\u003C/a\u003E. 개발환경, JVM 언어\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-8.1'\u003E8.1\u003C/a\u003E. 개발환경\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-8.2'\u003E8.2\u003C/a\u003E. \u003Ca class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'\u003EJVM\u003C/a\u003E 언어\u003C/span\u003E\u003Cdiv class='toc-indent'\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-8.2.1'\u003E8.2.1\u003C/a\u003E. 유명한 JVM 언어 목록\u003C/span\u003E\u003C/div\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-8.3'\u003E8.3\u003C/a\u003E. 혼동하기 쉬운 것들\u003C/span\u003E\u003C/div\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-9'\u003E9\u003C/a\u003E. 구글 vs. 오라클: Java 저작권 분쟁\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-10'\u003E10\u003C/a\u003E. 점유율\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-11'\u003E11\u003C/a\u003E. 불투명한 미래?\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-12'\u003E12\u003C/a\u003E. 도서\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-13'\u003E13\u003C/a\u003E. 여담\u003C/span\u003E\u003Cspan class='toc-item'\u003E\u003Ca href='#s-14'\u003E14\u003C/a\u003E. 관련 문서\u003C/span\u003E\u003C/div\u003E\u003C/div\u003E\u003Cbr\u003E\u003Cdiv style='clear:both'\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-1' href='#toc'\u003E1.\u003C/a\u003E \u003Cspan id='개요'\u003E개요\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=1' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003E\u003Cspan class=\"syntax-keyword\"\u003Epackage\u003C/span\u003E wiki.namu.test;\n\n\u003Cspan class=\"syntax-keyword\"\u003Epublic\u003C/span\u003E \u003Cspan class=\"syntax-keyword\"\u003Eclass\u003C/span\u003E HelloWorld {\n    \u003Cspan class=\"syntax-keyword\"\u003Epublic\u003C/span\u003E \u003Cspan class=\"syntax-keyword\"\u003Estatic\u003C/span\u003E \u003Cspan class=\"syntax-keyword\"\u003Evoid\u003C/span\u003E main(String[] args) {\n        System.out.println(\u003Cspan class=\"syntax-literal\"\u003E\"Hello, world!\"\u003C/span\u003E);\n    }\n}\u003C/code\u003E\u003C/pre\u003E\u003Cbr\u003E\u003Ca class='wiki-link-internal' href='/w/%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88' title='썬 마이크로시스템즈'\u003E썬 마이크로시스템즈\u003C/a\u003E에서 1995년에 개발한 \u003Ca class='wiki-link-internal' href='/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D' title='객체 지향 프로그래밍'\u003E객체 지향\u003C/a\u003E \u003Ca class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'\u003E프로그래밍 언어\u003C/a\u003E. 창시자는 \u003Ca class='wiki-link-internal' href='/w/%EC%A0%9C%EC%9E%84%EC%8A%A4%20%EA%B3%A0%EC%8A%AC%EB%A7%81' title='제임스 고슬링'\u003E제임스 고슬링\u003C/a\u003E이다. 2010년에 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'\u003E오라클\u003C/a\u003E이 \u003Ca class='wiki-link-internal' href='/w/%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88' title='썬 마이크로시스템즈'\u003E썬 마이크로시스템즈\u003C/a\u003E을 인수하면서 Java의 저작권을 소유하였다. 현재는 OpenJDK는 GPL2이나 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'\u003E오라클\u003C/a\u003E이 배포하는 Oracle JDK는 상업라이선스로 \u003Cdel\u003E오라클이 돈독 올랐는지\u003C/del\u003E 2019년 1월부터 유료화정책을 강화하고 있다. Java EE는 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'\u003E이클립스\u003C/a\u003E 재단의 소유이다. Java 언어는 J2SE 1.4부터는 Java Community Process (JCP)에서 개발을 주도하고 있다.\u003Cbr\u003E\u003Cbr\u003E\u003Ca class='wiki-link-internal' href='/w/C%23' title='C#'\u003EC#\u003C/a\u003E과 문법적 성향이 굉장히 비슷하며\u003Ca class='wiki-fn-content' title='당장 저기서 package문을 using문으로 System.out.println를 Console.WriteLine으로 바꾸기만 해도 완벽한 C# 코드가 된다.(...)' href='#fn-1'\u003E\u003Cspan class='target' id='rfn-1'\u003E\u003C/span\u003E&#91;1&#93;\u003C/a\u003E\u003Ca class='wiki-fn-content' title='그도 그럴 것이, 원래 C#이 MS에서 Java의 기본적인 성질은 가져가지만, 각종 문제들을 해결한 언어이기 때문이다.' href='#fn-2'\u003E\u003Cspan class='target' id='rfn-2'\u003E\u003C/span\u003E&#91;2&#93;\u003C/a\u003E, 그에 비해 2019년 Q3에서 가장 많이 이용하는 언어로 뽑혔다. \u003Cstrong\u003EJavascript와는 다르다.\u003C/strong\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-2' href='#toc'\u003E2.\u003C/a\u003E \u003Cspan id='어원'\u003E어원\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=2' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E처음엔 고슬링 사무실 앞에 있는 \u003Ca class='wiki-link-internal' href='/w/%EC%B0%B8%EB%82%98%EB%AC%B4' title='참나무'\u003E참나무\u003C/a\u003E에서 따와 OAK로 지었다가 그대로 \u003Ca class='wiki-link-internal' href='/w/%EC%83%81%ED%91%9C%EA%B6%8C' title='상표권'\u003E상표로 등록\u003C/a\u003E하기엔 문제가 생겨서\u003Ca class='wiki-fn-content' title='일반명사나 이미 널리 알려진 표현 등은 상표로 등록 못한다. 물론 상표 등록을 못해도 제품이나 서비스 이름으로 못 쓰는 건 아니지만 해당 이름에 대해 배타적·독점적 권리를 확보하지 못한 상태가 돼서, 남들이 따라 해도 거기에 법적으로 태클을 걸 수가 없다.' href='#fn-3'\u003E\u003Cspan class='target' id='rfn-3'\u003E\u003C/span\u003E&#91;3&#93;\u003C/a\u003E 컨설턴트가 극단적인 방법을 도입, 오후에 개발진들을 회의실에 \u003Ca class='wiki-link-internal' href='/w/%ED%86%B5%EC%A1%B0%EB%A6%BC(%EC%9D%80%EC%96%B4)' title='통조림(은어)'\u003E가둬서\u003C/a\u003E(...) \u003Ca class='wiki-link-internal' href='/w/%EB%B8%8C%EB%A0%88%EC%9D%B8%EC%8A%A4%ED%86%A0%EB%B0%8D' title='브레인스토밍'\u003E브레인스토밍\u003C/a\u003E을 시켰다. &quot;기분이 어떤가요&quot;(Excited!), &quot;무엇이 당신 기분을 좋게 만드나요?&quot;(Java coffee!) 같은 연상적인 작용을 거쳐 여러가지 이름을 정하고, 그 중에서 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%90%EB%B0%94%20%EC%84%AC' title='자바 섬'\u003E자바\u003C/a\u003E \u003Ca class='wiki-link-internal' href='/w/%EC%BB%A4%ED%94%BC' title='커피'\u003E커피\u003C/a\u003E의 Java를 선택했다. Java는 랭킹 중 네 번째. 리스트의 첫 번째 이름은 Silk였고 고슬링이 가장 좋아했던 이름은 Lyrics, 세 번째에 올라왔던 이름이라고.\u003Cbr\u003E\u003Cbr\u003E개발진이 자바산 커피를 좋아해서 그랬다는 설도 있다. 아이콘도 커피잔 모양. 또는 개발자의 이름인 \u003Cstrong\u003EJ\u003C/strong\u003Eames Gosling, \u003Cstrong\u003EA\u003C/strong\u003Erthur \u003Cstrong\u003EV\u003C/strong\u003Ean Hoff, \u003Cstrong\u003EA\u003C/strong\u003Endy Bechtolsheim의 머릿글자를 따온 것이라는 설도 있고, 그냥 사전을 펼쳤는데 눈에 들어온 이름이었다는 설도 있다. 그런데 막 지은 것 치고는 크게 흥하여 썬이 자사의 \u003Ca class='wiki-link-internal' href='/w/%EB%82%98%EC%8A%A4%EB%8B%A5' title='나스닥'\u003E나스닥\u003C/a\u003E 코드를 SUNW에서 JAVA로 바꾸었을 정도로 이제는 썬의 상징이자, \u003Cdel\u003E근데 그 썬이 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'\u003E오라클\u003C/a\u003E에 인수돼서 사라진 건 함정\u003C/del\u003E 세계적으로도 널리 알려진 단어가 되었다. \u003Ca class='wiki-link-external' href='http://www.javaworld.com/community/node/6242' target='_blank' rel='nofollow noopener' title='http://www.javaworld.com/community/node/6242'\u003E출처\u003C/a\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-3' href='#toc'\u003E3.\u003C/a\u003E \u003Cspan id='분류'\u003E분류\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=3' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava는 크게 다음과 같은 4가지 에디션으로 나뉜다.\u003Cbr\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJava SE(Java Standard Edition / J2SE)\u003Cbr\u003E대부분의 사람들이 가장 많이 접하는 표준 에디션. Java의 핵심 API와 기능들을 제공한다. \u003Ca class='wiki-link-internal' href='/w/JDK' title='JDK'\u003EJDK\u003C/a\u003E 항목도 참고.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJakarta EE, 구 Java EE(Java Enterprise Edition / J2EE)\u003Cbr\u003E기업에서 운영하는 서버 페이지에 특화된 에디션이다. \u003Ca class='wiki-link-internal' href='/w/JSP' title='JSP'\u003EJSP\u003C/a\u003E와 서블릿을 비롯한 웹 애플리케이션 서버에 관련된 기술들이 포함되어 있다.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJava ME(Java Micro Edition / J2ME)\u003Cbr\u003EPDA나 셋톱박스, 센서 등의 \u003Ca class='wiki-link-internal' href='/w/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%EC%8B%9C%EC%8A%A4%ED%85%9C' title='임베디드 시스템'\u003E임베디드 시스템\u003C/a\u003E 환경에 특화된 에디션이다.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJavaFX\u003Cbr\u003E데스크톱 애플리케이션 개발 및 배포를 위한 에디션으로, 크로스플랫폼 이식과 \u003Ca class='wiki-link-internal' href='/w/GUI' title='GUI'\u003EGUI\u003C/a\u003E 라이브러리를 제공한다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-4' href='#toc'\u003E4.\u003C/a\u003E \u003Cspan id='역사'\u003E역사\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=4' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E버전 정보와 날짜만 확인한다면, \u003Ca class='wiki-link-internal' href='/w/Java/%EB%B2%84%EC%A0%84%20%EC%A0%95%EB%B3%B4' title='Java/버전 정보'\u003EJava/버전 정보\u003C/a\u003E 문서 참조.\u003Cbr\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.1' href='#toc'\u003E4.1.\u003C/a\u003E \u003Cspan id='JDK 1.0a'\u003EJDK 1.0a\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=5' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E1994년 발표.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.2' href='#toc'\u003E4.2.\u003C/a\u003E \u003Cspan id='JDK 1.0a2'\u003EJDK 1.0a2\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=6' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E1995년 5월 23일 발표. 언어 자체가 정식으로 발표된 날이기도 하다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.3' href='#toc'\u003E4.3.\u003C/a\u003E \u003Cspan id='JDK 1.0'\u003EJDK 1.0\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=7' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E1996년 1월 23일 발표. 발표 이전에 불렸던 이름은 Oak였으며, 안정화 작업을 거친 1.0.2 버전에서 Java로 이름이 바뀌었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.4' href='#toc'\u003E4.4.\u003C/a\u003E \u003Cspan id='JDK 1.1'\u003EJDK 1.1\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=8' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E1997년 2월 19일 발표. 이너 클래스, JavaBeans, RMI, 리플렉션, \u003Ca class='wiki-link-internal' href='/w/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C' title='유니코드'\u003E유니코드\u003C/a\u003E 지원, 국제화(Internationalization) 등이 추가되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.5' href='#toc'\u003E4.5.\u003C/a\u003E \u003Cspan id='J2SE 1.2'\u003EJ2SE 1.2\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=9' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E1998년 12월 8일 발표. 일반 지원은 2003년 11월에 종료되었다. 새로운 GUI, JIT, CORBA 등의 굵직한 기능이 추가되면서 2 부터 약칭을 J2SE(Java 2 Standard Edition) 로 표기하기 시작했으며, 이 표기는 5 까지 사용된다. strictfp, Swing GUI, \u003Ca class='wiki-link-internal' href='/w/JIT' title='JIT'\u003EJIT\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Java%20Applet' title='Java Applet'\u003EJava Applet\u003C/a\u003E을 구동하는 웹 브라우저 플러그인, CORBA, Collections 등이 추가되었다. 1999년에 업데이트를 통해 HotSpot JVM이 첫 선을 보인다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.6' href='#toc'\u003E4.6.\u003C/a\u003E \u003Cspan id='J2SE 1.3'\u003EJ2SE 1.3\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=10' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2000년 3월 8일 발표. 일반 지원은 2006년 11월에 종료되었다. HotSpot JVM, JNDI, JPDA, JavaSound 등이 추가되었다. RMI가 CORBA를 지원하도록 변경되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.7' href='#toc'\u003E4.7.\u003C/a\u003E \u003Cspan id='J2SE 1.4'\u003EJ2SE 1.4\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=11' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2002년 2월 6일 발표. 일반 지원\u003Ca class='wiki-fn-content' title='Premier Support. 오라클에 비용을 내고 기술 지원을 받는 서비스이다.' href='#fn-4'\u003E\u003Cspan class='target' id='rfn-4'\u003E\u003C/span\u003E&#91;4&#93;\u003C/a\u003E은 2008년 10월, 연장 지원\u003Ca class='wiki-fn-content' title='Extended Support. 일반 지원이 종료된 후 추가적인 비용을 지불하여 기술 지원을 더 받을 수 있는 기간이다.' href='#fn-5'\u003E\u003Cspan class='target' id='rfn-5'\u003E\u003C/span\u003E&#91;5&#93;\u003C/a\u003E은 2013년 2월에 종료되었다. assert, \u003Ca class='wiki-link-internal' href='/w/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D' title='정규표현식'\u003E정규표현식\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/IPv6' title='IPv6'\u003EIPv6\u003C/a\u003E, Non-Blocking IO, XML API, JCE, JSSE, JAAS, Java Web Start 등이 추가되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.8' href='#toc'\u003E4.8.\u003C/a\u003E \u003Cspan id='J2SE 5'\u003EJ2SE 5\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=12' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2004년 9월 30일 발표. 일반 지원은 2009년 9월, 연장 지원은 2015년 5월에 종료되었다. J2SE 5.0까지 Windows 9x와 Windows NT 4.0이 지원되었다. 이 때부터 버젼 중 앞의 1을 빼버리고 표기하기 시작했다. 그러나 내부적으로는 여전히 1.5, 1.6, 1.7 등으로 데이터가 들어있다. Generics, Annotation, Auto Boxing/Unboxing, Enumeration, 가변 길이 파라미터, Static Import, 새로운 Concurrency API 등이 추가되었다. Java는 표준 입력(stdin) 지원이 시원찮았는데, J2SE 5에 들어서 java.util.Scanner가 추가되면서 이전보다 편하게 표준 입력을 사용할 수 있게 되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.9' href='#toc'\u003E4.9.\u003C/a\u003E \u003Cspan id='Java SE 6'\u003EJava SE 6\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=13' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2006년 12월 11일 발표. 일반 지원은 2013년 2월에 종료되었으며, 연장 지원은 2018년 12월에 종료되었다. 이 때부터 표기가 J2SE에서 Java SE로 바뀌었다. Scripting Language Support, JDBC 4.0, Java Compiler API, Pluggable Annotation 등이 추가되었다. 스크립팅 언어 지원과 함께 Rhino \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E 엔진이 기본으로 탑재되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.10' href='#toc'\u003E4.10.\u003C/a\u003E \u003Cspan id='Java SE 7'\u003EJava SE 7\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=14' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2011년 7월 7일 발표. 일반 지원은 2015년 4월에 종료되었으며, 연장 지원은 2022년 7월에 종료될 예정이다. Dynamic Language 지원, switch문에서 String 사용, try문에서 자동 자원 관리, Diamond Operator &lt;&gt;, 이진수 리터럴, 숫자 리터럴에 _ 지원, 새로운 Concurrency API, 새로운 File NIO 라이브러리, Elliptic Curve Cryptography, Java2D를 위한 XRender, Upstream, Java Deployment Ruleset 등이 추가되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.11' href='#toc'\u003E4.11.\u003C/a\u003E \u003Cspan id='Java SE 8'\u003EJava SE 8\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=15' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2014년 3월 18일 발표. 일반 지원은 2019년 1월에 종료되었고, 연장 지원은 2023년 9월에 종료될 예정이다. Lambda Expression, Rhino 대신 Nashorn JavaScript 엔진 탑재, Annotation on Java Types, Unsigned Integer 계산, Repeating Annotation, 새로운 날짜와 시간 API(사실상 \u003Ca class='wiki-link-external' href='http://www.joda.org/joda-time/' target='_blank' rel='nofollow noopener' title='http://www.joda.org/joda-time/'\u003EJodaTime\u003C/a\u003E이라고 보면 된다), Static Link JNI Library, Interface Default Method, PermGen 영역 삭제, Stream API 등이 추가되었다. 본래 일반 지원은 2017년 9월 종료 예정이었으나 Java 9 발표의 지연 때문에 2018년 9월로 연장되었다가, 이후 라이선스 이관 문제로 인해 2019년 1월로 다시 연장되었다.\u003Cbr\u003E\u003Cbr\u003E32비트를 지원하는 마지막 공식 Java 버전으로, 이후 버전의 32비트 지원은 오직 서드파티를 통해서만 지원된다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.12' href='#toc'\u003E4.12.\u003C/a\u003E \u003Cspan id='Java SE 9'\u003EJava SE 9\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=16' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2017년 9월 21일 발표. 일반 지원은 2018년 3월에 종료되었다.\u003Cbr\u003E\u003Cbr\u003EProject Jigsaw 기반으로 런타임이 모듈화된 것이 가장 큰 특징. 이에 따라 대부분의 콘솔 프로그램 개발에는 더 이상 AWT나 Swing 같은 불필요한 라이브러리를 끌어쓸 필요도 없이, 최상위 모듈인 Base만 사용해도 된다. 더불어 특정 프로그램에 최적화된 최소 런타임을 제작할 수 있게 되면서 패키징 역시 간편해졌다.\u003Cbr\u003E\u003Cbr\u003E여기에 Java를 인터프리터 언어 셸처럼 사용할 수 있는 JShell이 추가되었으며, Java 바이트코드를 기계어로 미리 번역하는 선행 컴파일(Ahead-Of-Time Compilation) 역시 실험 기능으로 추가되었다.\u003Ca class='wiki-fn-content' title='GCC 계열 Java 컴파일러인 GCJ에서는 이미 지원하고 있던 기능이다.(현재는 출시 중단)' href='#fn-6'\u003E\u003Cspan class='target' id='rfn-6'\u003E\u003C/span\u003E&#91;6&#93;\u003C/a\u003E 또한 Deprecated 표시에는 해당 버전과 제거 예정 여부를 표시할 수 있게 되었다. 그 외에 구조적 불변 컬렉션, 통합 로깅, HTTP/2, private 인터페이스 메소드, HTML5 Javadoc 등도 지원되며, 프로퍼티 파일에 \u003Ca class='wiki-link-internal' href='/w/UTF-8' title='UTF-8'\u003EUTF-8\u003C/a\u003E이 지원됨에 따라 더 이상 인코딩 문제로 삽질할 필요가 없어졌다. 또한 \u003Ca class='wiki-link-internal' href='/w/Java%20Applet' title='Java Applet'\u003EJava Applet\u003C/a\u003E 기능은 지원이 종료된다.\u003Cbr\u003E\u003Cbr\u003E새로 적용된 버저닝 정책에 따라 이 버전부터는 더 이상 1.x 버전으로 내놓지 않고, 대신 \u003Cstrong\u003E9.0\u003C/strong\u003E으로 급속한 판올림이 일어났다. 또한 제거 예정인 Deprecated API는 \u003Cstrong\u003E다음 버전인 Java SE 10부터 완전 삭제 예정\u003C/strong\u003E이므로 해당 API를 쓰는 프로그램은 더 이상 이후의 버전에서 컴파일조차 불가능하게 된다. 그리고 Java SE 9부터는 6개월마다 새로운 버전이 업데이트된다.\u003Cbr\u003E\u003Cbr\u003E본래는 2016년 발표 예정이었으나 2번이나 연기되어 2017년 7월 27일 발표 예정, 그나마도 한번 더 연기되어 9월 21일에 발표되었다. 가장 큰 원인은 역시 Project Jigsaw의 개발 난이도였다. 런타임의 모듈화는 하위 호환성을 어느 정도 포기하고 성능을 추구한 것이기에 아직 현장에서는 Java 9로 넘어가는 것을 꺼리는 분위기다.\u003Cbr\u003E\u003Cbr\u003E이 버전부터 64비트 버전만 출시되었으며, 32비트 버전은 더 이상 공식적으로 나오지 않는다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.13' href='#toc'\u003E4.13.\u003C/a\u003E \u003Cspan id='Java SE 10'\u003EJava SE 10\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=17' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2018년 3월 20일 발표. 일반 지원은 2018년 9월에 종료되었다. var 키워드를 이용한 지역 변수 타입 추론\u003Ca class='wiki-fn-content' title='C#의 var와 똑같은 기능이다.' href='#fn-7'\u003E\u003Cspan class='target' id='rfn-7'\u003E\u003C/span\u003E&#91;7&#93;\u003C/a\u003E, 병렬 처리 가비지 컬렉션, 개별 쓰레드로 분리된 Stop-The-World, 루트 CA 목록 등이 추가되었다. 또한 JDK의 레포지토리가 하나로 통합되었으며, JVM 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당할 수 있게 되었다. 실험 기능으로 Java 기반의 JIT 컴파일러가 추가되었고, 이전 버전에서 Deprecated 처리된 API는 Java SE 10에서 모두 삭제되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.14' href='#toc'\u003E4.14.\u003C/a\u003E \u003Cspan id='Java SE 11'\u003EJava SE 11\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=18' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2018년 9월 25일 발표. 일반 지원은 2023년 9월, 연장 지원은 2026년 9월에 종료될 예정이다. \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'\u003E이클립스\u003C/a\u003E 재단으로 넘어간 Java EE가 JDK에서 삭제되고, JavaFX도 JDK에서 분리되어 별도의 모듈로 제공된다. \u003Ca class='wiki-link-external' href='https://www.infoworld.com/article/3261066/java/javafx-will-be-removed-from-the-java-jdk.html' target='_blank' rel='nofollow noopener' title='https://www.infoworld.com/article/3261066/java/javafx-will-be-removed-from-the-java-jdk.html'\u003E#\u003C/a\u003E\u003Ca class='wiki-fn-content' title='따라서 이전 버전과 호환이 안 될 가능성도 있다. 이전 버전에서는 그냥 내부 메소드 쓰듯이 JavaFX를 갖다 썼다면, 이제는 라이브러리를 따로 인클루드해서 배포해야 하기 때문.' href='#fn-8'\u003E\u003Cspan class='target' id='rfn-8'\u003E\u003C/span\u003E&#91;8&#93;\u003C/a\u003E Gloun이라는 업체가 JavaFX를 유지보수 중이므로 \u003Ca class='wiki-link-external' href='https://gluonhq.com/products/javafx/' target='_blank' rel='nofollow noopener' title='https://gluonhq.com/products/javafx/'\u003E이곳\u003C/a\u003E에서 다운로드받으면 된다. 람다 파라미터에 대한 지역 변수 문법\u003Ca class='wiki-fn-content' title='&#39;@Nonnull var x, @Nullable var y&#39;를 &#39;x.process(y)&#39;로 간략화할 수 있게 되었다.' href='#fn-9'\u003E\u003Cspan class='target' id='rfn-9'\u003E\u003C/span\u003E&#91;9&#93;\u003C/a\u003E, 엡실론 가비지 컬렉터, HTTP 클라이언트 표준화 등의 기능이 추가되었다.\u003Cbr\u003E\u003Cbr\u003E가장 커다란 변화는 바로 라이선스 부분. Java SE 11부터 Oracle JDK의 독점 기능이 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%20%EC%86%8C%EC%8A%A4' title='오픈 소스'\u003E오픈 소스\u003C/a\u003E 버전인 OpenJDK에 이식된다. 이는 다시 말해 Oracle JDK와 OpenJDK가 완전히 \u003Cstrong\u003E동일\u003C/strong\u003E해진다는 뜻이다. Oracle JDK는 Java SE 11부터 LTS(장기 지원) 버전으로 3년마다 출시되는데, 출시 후 5년 동안 오라클의 기술 지원이 제공되고 최대 3년까지 지원 기간을 연장할 수 있다. Oracle JDK는 이제 3년에 한 번 출시되니 Java의 실질적인 버전 업을 담당하는 것은 OpenJDK가 된 셈이다. OpenJDK는 기업들을 위한 기술 지원은 없고, 새로운 버전이 나오면 이전 버전에 대한 마이너 업데이트와 보안 업데이트는 중단된다.\u003Cbr\u003E\u003Cbr\u003E그리고 Java 11과 함께 발표된 또 다른 소식은 바로 \u003Cstrong\u003EOracle JDK가 구독형 유료 모델로 전환된다는 점\u003C/strong\u003E이다. \u003Ca class='wiki-link-external' href='http://www.ddaily.co.kr/news/article.html?no=171602' target='_blank' rel='nofollow noopener' title='http://www.ddaily.co.kr/news/article.html?no=171602'\u003E#\u003C/a\u003E 2019년 1월부터 오라클이 제공하는 모든 Oracle JDK는 유료화되며, 구독권을 구입하지 않으면 Oracle JDK에 접근 자체가 금지된다. 기존의 일반/연장 지원 서비스는 구독권에 포함되므로 별도의 서비스로는 제공되지 않는다. \u003Cstrong\u003E개인 사용자는 2021년 1월부터 비용을 지불해야 한다.\u003C/strong\u003E 이 때문에 많은 기업들이 Oracle JDK에서 발을 빼고 있으며, OpenJDK를 기반으로 한 다른 서드파티 JDK가 대안으로 떠오르고 있다. 대표적인 예로 Azul Systems에서 개발한 \u003Ca class='wiki-link-external' href='https://www.azul.com/downloads/zulu/' target='_blank' rel='nofollow noopener' title='https://www.azul.com/downloads/zulu/'\u003EZulu JDK\u003C/a\u003E가 있는데, Zulu JDK는 오라클의 TCK(Technology Certification Kit) 인증을 받은 구현체이다. 개인과 기업 모두 무료로 사용할 수 있고, 기술 지원에 한해서만 유료 서비스가 제공된다. 또 다른 대안으로는 \u003Ca class='wiki-link-external' href='https://adoptopenjdk.net/' target='_blank' rel='nofollow noopener' title='https://adoptopenjdk.net/'\u003EAdoptOpenJDK\u003C/a\u003E가 있는데, AdoptOpenJDK는 HotSpot VM 대신 Eclipse OpenJ9을 탑재한 버전도 같이 제공하고 있다. 다만 아직 TCK 인증을 받지 않았기에 주의가 필요하다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.15' href='#toc'\u003E4.15.\u003C/a\u003E \u003Cspan id='Java SE 12'\u003EJava SE 12\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=19' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2019년 3월 19일 공개. 특징 중 하나로 문법적으로 Switch문을 확장한 것이 있다.(\u003Ca class='wiki-link-external' href='https://openjdk.java.net/jeps/325' target='_blank' rel='nofollow noopener' title='https://openjdk.java.net/jeps/325'\u003E출처\u003C/a\u003E)\u003C/div\u003E\u003Cdiv class='wiki-indent'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003E\u003Cspan class=\"syntax-keyword\"\u003Eswitch\u003C/span\u003E (day) {\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E MONDAY:\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E FRIDAY:\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E SUNDAY:\n        System.out.println(\u003Cspan class=\"syntax-literal\"\u003E6\u003C/span\u003E);\n        \u003Cspan class=\"syntax-keyword\"\u003Ebreak\u003C/span\u003E;\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E TUESDAY:\n        System.out.println(\u003Cspan class=\"syntax-literal\"\u003E7\u003C/span\u003E);\n        \u003Cspan class=\"syntax-keyword\"\u003Ebreak\u003C/span\u003E;\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E THURSDAY:\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E SATURDAY:\n        System.out.println(\u003Cspan class=\"syntax-literal\"\u003E8\u003C/span\u003E);\n        \u003Cspan class=\"syntax-keyword\"\u003Ebreak\u003C/span\u003E;\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E WEDNESDAY:\n        System.out.println(\u003Cspan class=\"syntax-literal\"\u003E9\u003C/span\u003E);\n        \u003Cspan class=\"syntax-keyword\"\u003Ebreak\u003C/span\u003E;\n}\u003C/code\u003E\u003C/pre\u003E\u003Cbr\u003E예전에는 이렇게 써야 했던 Switch문을 아래와 같은 형식으로도 쓸 수 있게 되었다.\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003E\u003Cspan class=\"syntax-keyword\"\u003Eswitch\u003C/span\u003E (day) {\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(\u003Cspan class=\"syntax-literal\"\u003E6\u003C/span\u003E);\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E TUESDAY                -&gt; System.out.println(\u003Cspan class=\"syntax-literal\"\u003E7\u003C/span\u003E);\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E THURSDAY, SATURDAY     -&gt; System.out.println(\u003Cspan class=\"syntax-literal\"\u003E8\u003C/span\u003E);\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E WEDNESDAY              -&gt; System.out.println(\u003Cspan class=\"syntax-literal\"\u003E9\u003C/span\u003E);\n}\u003C/code\u003E\u003C/pre\u003E\u003C/div\u003E\u003C/div\u003E\u003Cdiv class='wiki-paragraph'\u003E이외에 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선의 변경점이 있다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.16' href='#toc'\u003E4.16.\u003C/a\u003E \u003Cspan id='Java SE 13'\u003EJava SE 13\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=20' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2019년 9월 17일 공개. java 12에서의 스위치 개선을 이어 yield 라는 예약어가 추가되었다.\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003E\u003Cspan class=\"syntax-keyword\"\u003Evar\u003C/span\u003E a = \u003Cspan class=\"syntax-keyword\"\u003Eswitch\u003C/span\u003E (day) {\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E MONDAY, FRIDAY, SUNDAY -&gt; yield \u003Cspan class=\"syntax-literal\"\u003E6\u003C/span\u003E;\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E TUESDAY                -&gt; yield \u003Cspan class=\"syntax-literal\"\u003E7\u003C/span\u003E;\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E THURSDAY, SATURDAY     -&gt; yield \u003Cspan class=\"syntax-literal\"\u003E8\u003C/span\u003E;\n    \u003Cspan class=\"syntax-keyword\"\u003Ecase\u003C/span\u003E WEDNESDAY              -&gt; yield \u003Cspan class=\"syntax-literal\"\u003E9\u003C/span\u003E;\n};\u003C/code\u003E\u003C/pre\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.17' href='#toc'\u003E4.17.\u003C/a\u003E \u003Cspan id='Java SE 14'\u003EJava SE 14\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=21' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2020년 3월 18일 공개. 프리뷰 기능으로 instanceof의 패턴 매칭과 record라는 데이터 오브젝트 선언이 추가되었다. 그 외에 인큐베이터라는 패키징 툴(OS에 맞춘 실행파일 생성기능) 추가 등이 있다.\u003Cbr\u003E\u003Cbr\u003Einstanceof 패턴 매칭\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003E\u003Cspan class=\"syntax-keyword\"\u003Eif\u003C/span\u003E (!(obj \u003Cspan class=\"syntax-keyword\"\u003Einstanceof\u003C/span\u003E String s)) {\n    .. s.contains(..) ..\n} \u003Cspan class=\"syntax-keyword\"\u003Eelse\u003C/span\u003E {\n    .. s.contains(..) ..\n}\u003C/code\u003E\u003C/pre\u003E\u003Cbr\u003E\u003Cbr\u003Erecord\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003Erecord Point(\u003Cspan class=\"syntax-keyword\"\u003Eint\u003C/span\u003E x, \u003Cspan class=\"syntax-keyword\"\u003Eint\u003C/span\u003E y) { }\u003C/code\u003E\u003C/pre\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-4.18' href='#toc'\u003E4.18.\u003C/a\u003E \u003Cspan id='Java SE 15'\u003EJava SE 15\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=22' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E2020년 9월 공개 예정.\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-5' href='#toc'\u003E5.\u003C/a\u003E \u003Cspan id='문법'\u003E\u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'\u003E문법\u003C/a\u003E\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=23' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%8C%8C%EC%9D%BC:%EB%82%98%EB%AC%B4%EC%9C%84%ED%82%A4%EC%83%81%EC%84%B8%EB%82%B4%EC%9A%A9.png' title='파일:나무위키상세내용.png' rel='nofollow'\u003E\u003Cspan class='wiki-image-align-left' style='width:21px;'\u003E\u003Cspan class='wiki-image-wrapper' style='width: 100%;'\u003E\u003Cimg class='wiki-image-space' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4='\u003E\u003Cimg class='wiki-image wiki-image-loading' width='100%' src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48L3N2Zz4=' data-filesize='50826' data-src='//w.namu.la/s/7ada8e25f0e5a43b01ab96c3a2c3bb02c994664e3fd7da42de7482f13ef25356afcdf908e8312492cc5230ce8e38b0eeb434abf222bab4c4ad68ecd8c9ee2c90c163a0b9ce63ed49e1b7f0942e8efef2aafa70bdd0315e2ae2db231690ecd21e' alt='파일:나무위키상세내용.png'\u003E\u003Cnoscript\u003E\u003Cimg class='wiki-image' width='100%' src='//w.namu.la/s/7ada8e25f0e5a43b01ab96c3a2c3bb02c994664e3fd7da42de7482f13ef25356afcdf908e8312492cc5230ce8e38b0eeb434abf222bab4c4ad68ecd8c9ee2c90c163a0b9ce63ed49e1b7f0942e8efef2aafa70bdd0315e2ae2db231690ecd21e' alt='파일:나무위키상세내용.png'\u003E\u003C/noscript\u003E\u003C/span\u003E\u003C/span\u003E\u003C/a\u003E  자세한 내용은 \u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'\u003EJava/문법\u003C/a\u003E 문서\u003Cdiv style=\"display:none;display:inline\"\u003E를\u003C/div\u003E\u003Cdiv style=\"display:none;display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95#s-' title='Java/문법'\u003E번째 문단\u003C/a\u003E을\u003C/div\u003E\u003Cdiv style=\"display:inline;display:none\"\u003E의 \u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'\u003E\u003C/a\u003E\u003Ca class='wiki-link-internal' href='/w/Java/%EB%AC%B8%EB%B2%95' title='Java/문법'\u003E\u003C/a\u003E 부분을\u003C/div\u003E 참고하십시오.\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-6' href='#toc'\u003E6.\u003C/a\u003E \u003Cspan id='C, C++와의 비교'\u003EC, C++와의 비교\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=24' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E기존의 \u003Ca class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'\u003EC\u003C/a\u003E에 객체지향 기능을 추가하다 보니, 언어의 사용에 있어 저수준과 고수준의 개념이 충돌하는 부분이 많았던 \u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E과는 다르게 아예 처음부터 \u003Ca class='wiki-link-internal' href='/w/OOP' title='OOP'\u003E객체지향\u003C/a\u003E 언어로 개발되었다. 다만 많은 사람들이 착각하는 부분인데, Java는 엄밀히 말하면 완벽한 객체지향 언어가 아니다. 원시(Primitive) 타입은 객체로 취급하지 않기 때문. 모든 것을 객체로 취급하는 언어를 순수 객체지향(Pure object-oriented)이라 하며, 이를 지원하는 언어로는 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Ruby' title='Ruby'\u003ERuby\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Smalltalk' title='Smalltalk'\u003ESmalltalk\u003C/a\u003E등이 있다.\u003Cbr\u003E\u003Cbr\u003EC, C++, Java의 차이점을 말하자면, C는 포인터 등을 활용한 저수준 시스템 프로그래밍에\u003Ca class='wiki-fn-content' title='리눅스 커널, 하드웨어 프로그래밍' href='#fn-10'\u003E\u003Cspan class='target' id='rfn-10'\u003E\u003C/span\u003E&#91;10&#93;\u003C/a\u003E 강점을 가지며, C++는 C의 그런 강점을 거의 그대로 가져오면서 거기에 객체 지향이나 일반화 프로그래밍과 같은 멀티 패러다임을 지원하고자 하는 시도\u003Ca class='wiki-fn-content' title='3D 게임, 그래픽 프로그래밍' href='#fn-11'\u003E\u003Cspan class='target' id='rfn-11'\u003E\u003C/span\u003E&#91;11&#93;\u003C/a\u003E에서 탄생하였다. 이렇게 고수준과 저수준의 개념을 모두 포함하려다 보니 다른 언어에 비해서 상당히 복잡해졌다. 게다가 최신 프로그래밍 환경을 지원하기 위해 지속적으로 개정되고 있는 모던 C++는 변화의 폭이 커서, 새로운 기능을 전부 제대로 다룰 줄 아는 프로그래머는 비교적 적다는 평이 널리 받아들여지고 있다. 이와는 대조적으로 Java는 C++의 초기 발전 방향과는 달리 안정성을 위해 포인터라는 강력한 로우 레벨 기능을 포기하고 가비지 컬렉터를 내장하며, 고수준의 객체지향 부분을 잘 구현하는 것에 집중하는 방식으로 언어가 복잡해지는 것을 방지하였다.\u003Cbr\u003E\u003Cbr\u003E수많은 \u003Ca class='wiki-link-external' href='https://en.wikipedia.org/wiki/List_of_C-family_programming_languages' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/List_of_C-family_programming_languages'\u003EC계열 프로그래밍 언어\u003C/a\u003E가 그렇듯이, C/C++와 비슷한 문법 구조를 가지고 있다. 그러면서도 Java가 C/C++보다 훨씬 더 널리 쓰이는 분야가 많이 존재한다. 웹 애플리케이션 백엔드와 \u003Ca class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'\u003E안드로이드\u003C/a\u003E 앱이 대표적인 사례. 또한 \u003Ca class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'\u003E아파치 소프트웨어 재단\u003C/a\u003E에서 개발하는 수많은 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%20%EC%86%8C%EC%8A%A4' title='오픈 소스'\u003E오픈 소스\u003C/a\u003E 소프트웨어들이 Java로 만들어졌다. 하지만 Java 프로그램에서 속도가 매우 중요시되는 부분은 따로 떼어서 C/C++로 개발하기도 한다. 제작하고자 하는 프로그램의 생산성과 성능을 적절히 고려하여 선택하는 것이 현명하다.\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-7' href='#toc'\u003E7.\u003C/a\u003E \u003Cspan id='특징'\u003E특징\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=25' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava의 가장 큰 특징은 플랫폼에 독립적인 언어라는 점이다. 소스 코드를 기계어로 직접 컴파일하여 링크하는 C/C++의 컴파일러와 달리 자바 컴파일러는 바이트코드인 클래스 파일(.class)을 생성하고, 이 파일의 바이트코드를 읽은 뒤 기계어로 바꾸어 실행하는 것은 \u003Ca class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'\u003EJava Virtual Machine\u003C/a\u003E(JVM)이다.\u003Cbr\u003E\u003Cbr\u003E예를 들어 C 계열 언어들은 \u003Ca class='wiki-link-internal' href='/w/Microsoft%20Windows' title='Microsoft Windows'\u003E윈도우\u003C/a\u003E에서 빌드한 프로그램을 그대로 \u003Ca class='wiki-link-internal' href='/w/%EB%A6%AC%EB%88%85%EC%8A%A4' title='리눅스'\u003E리눅스\u003C/a\u003E나 \u003Ca class='wiki-link-internal' href='/w/macOS' title='macOS'\u003EmacOS\u003C/a\u003E에서 실행하려 하면 일반적으로 오류가 나지만 Java로 작성 된 프로그램은 플랫폼에 맞는 JVM만 설치되어 있다면 문제 없이 동작한다. 이는 Java 코드 자체가 플랫폼이 아닌 \u003Ca class='wiki-link-internal' href='/w/%EA%B0%80%EC%83%81%EB%A8%B8%EC%8B%A0' title='가상머신'\u003E가상머신\u003C/a\u003E에 종속적이라는 점, 그리고 프로그램 실행의 주체가 운영체제가 아닌 JVM이라는 점 때문이며 이러한 점을 통틀어 Java는 플랫폼 종속성이 낮은 언어라고 표현한다.\u003Cbr\u003E\u003Cbr\u003EJVM 기반의 프로젝트에서는 하나의 언어만을 고집하지 않는다. 함수형 언어가 유리(최근 유행하는 빅데이터 등)한 부분은 \u003Ca class='wiki-link-internal' href='/w/Scala' title='Scala'\u003EScala\u003C/a\u003E로 작업하며, 견고한 인터페이스와 대규모 통합이 필요한 곳은 Java로 작업한 뒤 이들을 서로 합쳐서 운영하는 게 가능하다. (Java에서 만든 객체를 Scala에서 그대로 사용할 수 있다.) \u003Ca class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'\u003E안드로이드\u003C/a\u003E 쪽에서는 크리티컬하지 않은 부분부터 \u003Ca class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'\u003EKotlin\u003C/a\u003E으로 코드를 교체하는 경우도 많아지고 있다.\u003Cbr\u003E\u003Cbr\u003E실제 현업에서는 Java를 비롯한 여러가지 인기 언어가 자주 사용되므로 장단점을 잘 알아두는게 좋다. 다른 언어에 대해 맹목적으로 찬양/비판하는 태도보다는 환경이나 주어진 작업의 특성에 따라 적합한 언어를 선택할 수 있는 노하우가 필요하다.\u003Cbr\u003E\u003Cbr\u003EPC에서 자바 런너 업데이트를 할 때 뜨는 창에 &#39;30억개 기기에서 Java 사용&#39;이라는 문구가 나온다.\u003Cbr\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-7.1' href='#toc'\u003E7.1.\u003C/a\u003E \u003Cspan id='장점'\u003E장점\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=26' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.1.1' href='#toc'\u003E7.1.1.\u003C/a\u003E \u003Cspan id='수많은 개발자와 레퍼런스'\u003E수많은 개발자와 레퍼런스\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=27' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E나온지도 오래 되었고, 다른 최신 언어에 비해서 여러가지로 욕을 먹는 Java가 그래도 항상 상위권을 유지하는 이유는 바로 수많은 개발자와 레퍼런스를 보유하고 있다는 점이다. 타 언어를 전문적으로 사용하는 개발자들도 Java 정도는 할 줄 안다고 할 정도로 배우기 쉽고 대중적이다. 대중적인 언어라서 참고 자료나 오픈 소스가 많고, 그러한 자료들을 바탕으로 수많은 대형 프로젝트들이 진행되어왔기 때문에 많은 부분에서 안정성이 입증되었다. 즉, 안정적인 인력풀을 유지하면서, 알려진 위협을 제거하고 운영 노하우를 극대화시킬 수 있는 검증된 언어라는 것.\u003Cbr\u003E\u003Cbr\u003E하지만 검증되었다는 건 반대로 말하자면 오래되었다는 뜻이기도 하다. 최근에는 Java에 대한 개발자들의 불만이 누적된 탓인지 \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E나 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E 같은 다른 언어를 선호하는 경향이 강하다. 국내에서는 \u003Ca class='wiki-link-internal' href='/w/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%91%9C%EC%A4%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC' title='전자정부표준프레임워크'\u003E전자정부표준프레임워크\u003C/a\u003E의 존재 때문인지 아직도 신규 프로젝트의 주 언어로 Java를 선호하는 경향이 강하지만, 세계적으로는 신규 프로젝트에서 Java를 선호하는 비중은 높지 않은 편이다.\u003Ca class='wiki-fn-content' title='특히 웹 개발 분야에서 해외의 경우 Java는 도태되는 추세고, Node.js 덕분에 서버와 프론트엔드 양 쪽에서 쓸 수 있는 JavaScript와 Django를 통하여 쉽고 빠르게 백엔드 구축이 가능한 Python의 사용률이 늘어나고 있다.' href='#fn-12'\u003E\u003Cspan class='target' id='rfn-12'\u003E\u003C/span\u003E&#91;12&#93;\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E국내에서의 언어 외적인 장점은 바로 개발자 구인의 용이성이다. 국내에서 Java 개발자의 인력풀이 타 언어보다 더 큰 이유는 앞서 말했던 전자정부표준프레임워크의 존재 때문이기도 하고, 그 때문에 Java 개발자를 정부에서 국비지원으로 대거 양성했기 때문이기도 하다. 상당수의 정부 하청 프로젝트가 Java와 전자정부표준프레임워크로 개발되었다. 이런 이유 때문에 굳이 정부 프로젝트가 아니더라도 Java 개발자를 구인하기 쉬웠고, 더 많은 프로젝트가 Java로 개발되었다. 그리고 그렇게 만들어진 프로젝트를 유지보수하기 위해서 더 많은 Java 개발자가 필요하므로 더 많은 인력이 유입되는 일종의 선순환 효과가 있다. 취업 사이트를 확인해보면 다른 분야보다 Java 개발자를 구인하는 경우가 많은 건 이 때문이다. 사람을 구하기도 쉽고, 직장을 구하기도 쉽다. 영어권 국가에 비해 공유되는 자료가 비교적 부족한 국내에서도 \u003Ca class='wiki-link-internal' href='/w/JSP' title='JSP'\u003EJSP\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Spring(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)' title='Spring(프레임워크)'\u003ESpring\u003C/a\u003E에 관한 자료만큼은 높은 퀄리티를 보여주는 경우가 많다. 그러나 반대로 할 줄 아는 사람들이 너무 많아 경쟁력이 떨어지는 면도 있다. \u003Ca class='wiki-link-internal' href='/w/SI' title='SI'\u003E몇몇 회사\u003C/a\u003E에서는 Java 개발자에 대한 보수나 기타 대우가 좋지 않은 경우도 많다. 개발자가 많다는 것은 취업이나 구인 면에서는 장점이지만, 다른 측면에서는 단점이 될 수도 있다. \u003Cdel\u003E버스 기사는 어디에서나 써먹을수 있으며 각계각층에 필요하고 수요와 공급 모두 많고 구직도 쉽고 구인도 쉽고 어쨌든 실업자는 안 되고 어찌됐든 밥벌이는 할 수 있지만 많은 사람들이 하지 않으려는 이유와 대강 비슷하다.\u003C/del\u003E\u003Cbr\u003E\u003Cbr\u003E기존의 Java로 만들어진 프로젝트를 재사용하기 위해 Java가 쓰인 대표적인 사례는 카카오뱅크가 있다. 한정된 시간 때문에 Java 코드를 재사용해야 했던 경우다.\u003Ca class='wiki-link-external' href='https://byline.network/2017/08/8-2/' target='_blank' rel='nofollow noopener' title='https://byline.network/2017/08/8-2/'\u003E#\u003C/a\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.1.2' href='#toc'\u003E7.1.2.\u003C/a\u003E \u003Cspan id='비교적 높은 생산성'\u003E비교적 높은 생산성\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=28' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E오늘날 프로그램의 덩치와 다루는 것들이 크고 복잡해지면서 생산성과 퍼포먼스 문제가 생기게 되었는데, \u003Ca class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'\u003EC\u003C/a\u003E/\u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E 같은 언어는 생산성이 너무 떨어지고 관리도 힘들어서 프로그램이 커지면 커질수록 작업이 힘들어지게 된다. 그리고 아무리 컴퓨터 하드웨어가 발달한다고 해도 성능이 더 좋아지면 점점 더 복잡한 것을 다루고, 그것이 새로운 표준이 되면서 하드웨어의 속도 향상이 무색해지기 때문이다.\u003Cbr\u003E\u003Cbr\u003E그런데, 그 와중에 나타난 게 바로 Java다. C/C++와 비슷한 문법으로 진입 장벽도 낮고, 객체 지향을 적극적으로 사용하며, 로우 레벨 작업들을 자동으로 처리해 주는 하이 레벨 언어이면서, 퍼포먼스도 다른 하이 레벨 언어들에 비해 빠른 편이다. 거기에 호환성까지! 등장하자마자 순식간에 대세가 된 것도 무리는 아니다. 객체지향 등이 일반화되면서 프로그래밍 환경도 점차 중요한 개념을 언어 안으로 숨기고 사용자에겐 그것을 간편히 다룰 수 있는 인터페이스만 제공하는 추세로 흘러가고 있는데, Java는 여기에 정확하게 부합하는 언어였던 것. 다만 최근 인기를 끌고 있는 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E이나 \u003Ca class='wiki-link-internal' href='/w/Go(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Go(프로그래밍 언어)'\u003EGo\u003C/a\u003E 같은 언어에 비하면 Java의 생산성은 상대적으로 낮은 편이다.\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.1.3' href='#toc'\u003E7.1.3.\u003C/a\u003E \u003Cspan id='기기 호환성'\u003E기기 호환성\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=29' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E장점으로는, 해당 \u003Ca class='wiki-link-internal' href='/w/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C' title='운영체제'\u003E운영체제\u003C/a\u003E에 \u003Ca class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'\u003EJava Virtual Machine(JVM)\u003C/a\u003E을 설치하면 Java로 만든 프로그램은 어떤 컴퓨터에서도 완벽히 똑같이 동작한다. \u003Ca class='wiki-link-internal' href='/w/%EA%B0%80%EC%83%81%EB%A8%B8%EC%8B%A0' title='가상머신'\u003E가상머신\u003C/a\u003E이 각각의 운영체제에 맞춰서 결과적으로 완벽히 똑같이 돌아갈 수 있도록 제작되는 덕. 가상머신 없는 운영체제라면 아예 Java 프로그램을 사용하지 못하겠지만, 썬 마이크로시스템즈는 주요 OS용의 가상 머신을 발표하고 있고, \u003Ca class='wiki-link-internal' href='/w/IBM(%EA%B8%B0%EC%97%85)' title='IBM(기업)'\u003EIBM\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/%ED%9C%B4%EB%A0%9B%ED%8C%A9%EC%BB%A4%EB%93%9C' title='휴렛팩커드'\u003E휴렛팩커드\u003C/a\u003E 등의 회사는 직접 자사 운영체제용 JDK/JVM을 제작하여 발표하며, 이들과 상관없이 독립적으로 특화된 성능향상 기능을 가진 JVM을 만들어서 발표하는 회사도 존재한다. 그래서 이 부분은 보통 단점으로 꼽히지 않는다. 오히려 여러 운영체제에 발 벌리는 업체라면 윈도우용, 맥용 등을 따로 제작할 필요 따위가 없이 &quot;그냥 하나 만들면 끝!&quot;이라고 Java 초창기에 홍보되었다.\u003Cbr\u003E\u003Cbr\u003E그러나 다른 크로스 플랫폼 언어들과 마찬가지로 각 플랫폼마다 미묘하게 기능이나 작동에 차이가 있는 부분이 결국은 존재하기 때문에, 이러한 부분을 고려하지 않고 작성된 프로그램을 그대로 다른 데에서 돌릴 때에 문제가 발생할 가능성이 존재한다. JVM의 장점은 그나마 이런 부분들이 다른 언어에 비해서 매우 적은 편이라는 점이다. 이런 경우, 대부분 크로스 플랫폼으로 작성된 코드가 그러하듯 타겟 플랫폼을 인지하여 특정 플랫폼에서는 다르게 동작하게 하는 식으로 코딩을 하게 된다. 주로 java.nio 패키지에 속한 API 에서 이러한 경우를 발견할 수 있으며, \u003Ca class='wiki-link-internal' href='/w/OS%20X' title='OS X'\u003EOS X\u003C/a\u003E 에서만 일부 특이하게 동작하는 MIDI 관련 API 또한 이러한 경우에 속한다. Java의 모토는 Write once, run  everywhere(한 번 짜서, 어디서나 실행하라)인데 프로그래머들은 이를 비꼬아 Write once, \u003Cstrong\u003Etest everywhere\u003C/strong\u003E(한 번 짜서, 모든 플랫폼에서 테스트하라)라고 말하곤 한다.\u003Cbr\u003E\u003Cbr\u003EC나 C++에서도 크로스 플랫폼 형태로 소스코드를 작성하는 것이 가능하기는 했지만, 개발자가 타겟 플랫폼과 해당 플랫폼용 바이너리 코드를 생성하는 컴파일러에 대해서 잘 이해하고 나서 #define, #if 등 전처리기를 써서 각 타겟 플랫폼에 맞게 동작하도록 코드를 직접 작성해줘야 했다. 이와 달리, Java는 단일 소스코드를 컴파일하여 생성된 바이트코드 클래스 파일을 JVM이 존재하는 환경이라면 어디서나 (대부분은) 추가 컴파일이나 수정작업 없이 그대로 똑같이 실행할 수 있다는 점이 차이점이다. 기업 입장에서 컴파일된 \u003Cstrong\u003E바이너리\u003C/strong\u003E가 크로스 플랫폼을 보장해주는 Java는 매력적인 언어였다.\u003Cbr\u003E\u003Cbr\u003EJVM 위에서 구동 가능한 언어는 Java 외에도 존재하는데, 이 언어들을 사용하면 Java와 동일한 수준의 호환성을 구현할 수 있다.\u003Ca class='wiki-fn-content' title='JVM 위에서 구동 가능한 언어에 대해서는 영문 위키피디아의 List of JVM languages 참고.' href='#fn-13'\u003E\u003Cspan class='target' id='rfn-13'\u003E\u003C/span\u003E&#91;13&#93;\u003C/a\u003E 구글에서 안드로이드 개발의 차세대 언어로 밀어주는 \u003Ca class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'\u003EKotlin\u003C/a\u003E이 대표적인 케이스다. Java의 개발 주체인 Oracle에서 개발하는 GraalVM이라는 \u003Cdel\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%95%9C%EA%B5%AD%EC%96%B4' title='한국어'\u003E한국어\u003C/a\u003E에서 자주 쓰이는 \u003Ca class='wiki-link-internal' href='/w/%EC%A7%80%EB%9E%84' title='지랄'\u003E어떤 욕설\u003C/a\u003E과 관계 없다\u003C/del\u003E 프레임워크도 있다. 이 프레임워크에서는 \u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E도 JVM 위에서 실행하는 것이 가능하다.\u003Cbr\u003E\u003Cbr\u003E요즘은 하드웨어와 밀접하게 연동되어야 하는 프로그램이 아니라면, 또는 메인 로직은 서버에서 돌아가고 클라이언트에서는 인터페이스만 제공해주면 되는 경우라면 JVM보다는 웹 기술을 이용한 방식이 더 주목받고 있다. 아예 어디에서나 동일한 동작을 보증하는 웹 사이트의 형식으로 서비스를 하거나, 네이티브 앱의 UI가 필요한 경우에는 \u003Ca class='wiki-link-internal' href='/w/React(%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)' title='React(라이브러리)'\u003EReact Native\u003C/a\u003E 또는 \u003Ca class='wiki-link-internal' href='/w/Flutter(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)' title='Flutter(프레임워크)'\u003EFlutter\u003C/a\u003E 등의 프레임워크를 이용하는 경우가 많다. 전자는 웹 개발에서 주로 쓰이는 \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E를 이용하고, 후자는 구글에서 웹 프로그래밍의 용도로 만든 \u003Ca class='wiki-link-internal' href='/w/Dart(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='Dart(프로그래밍 언어)'\u003EDart\u003C/a\u003E라는 언어를 이용한다. 이 외에 게임이나 3D 렌더링이 필요한 앱의 경우 \u003Ca class='wiki-link-internal' href='/w/%EA%B2%8C%EC%9E%84%20%EC%97%94%EC%A7%84' title='게임 엔진'\u003E게임 엔진\u003C/a\u003E을 이용한다.\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.1.4' href='#toc'\u003E7.1.4.\u003C/a\u003E \u003Cspan id='안정성'\u003E안정성\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=30' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E다른 언어에 비해 높은 안정성을 꼽고 있다. 우선 C나 C++에 안정성 문제가 제기되는 포인터 연산자\u003Ca class='wiki-fn-content' title='정말로 포인터를 써야 할 경우 Unsafe 클래스를 쓰면 된다. 다만 팩토리 메소드가 막혀있어 리플렉션을 사용해야만 이용할 수 있다.' href='#fn-14'\u003E\u003Cspan class='target' id='rfn-14'\u003E\u003C/span\u003E&#91;14&#93;\u003C/a\u003E 및 메모리 직접접근 함수들을 지원하지 않는다. 여기에 C++과는 다르게 다중 \u003Ca class='wiki-link-internal' href='/w/%EC%83%81%EC%86%8D(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)' title='상속(프로그래밍)'\u003E상속\u003C/a\u003E을 허용하지 않는다. 이는 객체지향의 특성 중 하나인 &#39;상속&#39;의 자유도를 확 떨어트리는 것이기에 언뜻 보기에는 객체지향적 관점에 위배되는 것처럼 보일 수 있으나, 반대로 오히려 이게 더 객체지향적이라고 볼 수도 있다. 객체지향의 목적 자체가 재사용을 통한 생산성의 향상과 관리 상의 이점인데, 다중 상속은 잘못 사용할 시 극도로 복잡하게 꼬인 프로그램을 만들 위험성을 갖고 있다. 물론 코드 관리의 측면에서도 다중상속에 의해 발생하는 문제는 좋지 않다. 수준 높은 프로그래머라면 이 문제도 잘 해결할 수 있지만, Java는 아예 미연에 방지하기 위해 다중상속을 언어 스펙에서 제거하는 방법을 택했다.\u003Ca class='wiki-fn-content' title='어차피 Java에서는 다중 상속을 포기함으로써 생기는 문제를 interface를 다중 구현할 수 있도록 하여 어느 정도 해결하기도 했다.' href='#fn-15'\u003E\u003Cspan class='target' id='rfn-15'\u003E\u003C/span\u003E&#91;15&#93;\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E메모리를 대용량으로 사용하는 프로그램에서 상대적으로 C/C++보다 안정적인 모습을 보일 때도 있는데, 이런 경우에 \u003Ca class='wiki-link-internal' href='/w/JVM' title='JVM'\u003EJVM\u003C/a\u003E이 시작될 때 필요한 메모리를 먼저 통으로 잡아버리기 때문이다. 메모리를 자주 할당하거나 해제하는 C/C++ 프로그램은 오히려 Java보다 성능이 느릴 수 있다. 다만 이는 메모리 할당자 없이 매번 힙 영역 메모리를 운영체제로부터 할당받는 경우에 해당하는 말이고\u003Ca class='wiki-fn-content' title='쉽게 생각하면 배열 1000개를 할당받기 위해 운영체제에 1번 호출하여 한꺼번에 할당받지 않고, 1000번 호출하여 각각 할당받는 것이다. 기본적으로, 동적 메모리 할당은 운영체제에서 처리하기 때문에 속도가 느리다. 어떤 언어에서라도, 운영체제의 메모리 할당 횟수를 줄이는 것이 성능에 도움이 된다.' href='#fn-16'\u003E\u003Cspan class='target' id='rfn-16'\u003E\u003C/span\u003E&#91;16&#93;\u003C/a\u003E, 실제 C/C++ 프로젝트에서는 jemalloc 등 메모리 할당자 라이브러리를 사용하거나 메모리 할당자를 직접 구현하여 이런 문제를 해결하는 것이 일반적이다.\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.1.5' href='#toc'\u003E7.1.5.\u003C/a\u003E \u003Cspan id='소스 코드 가독성'\u003E소스 코드 가독성\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=31' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E고급 프로그래밍 언어가 만들어진 첫째 목적은 &#39;좀 더 인간 친화적인&#39; 코드의 작성을 돕는 데 있다. \u003Ca class='wiki-link-internal' href='/w/%EA%B8%B0%EA%B3%84%EC%96%B4' title='기계어'\u003E기계어\u003C/a\u003E가 \u003Ca class='wiki-link-internal' href='/w/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4' title='어셈블리어'\u003E어셈블리어\u003C/a\u003E로 진화하고 그것이 \u003Ca class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'\u003EC언어\u003C/a\u003E로 진화한 배경에는 &#39;사람이 더 쉽게 읽고 이해할 수 있는 코드&#39;가 있다. Java는 동시기에 발표된 다른 언어에 비해 코드가 명료하고 가독성이 뛰어났다. \u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E은 어려운 문법으로 인해 코드가 이리저리 꼬이는 경우가 많고, 특히 연산자 오버로딩과 \u003Ca class='wiki-link-internal' href='/w/%ED%85%9C%ED%94%8C%EB%A6%BF' title='템플릿'\u003E템플릿\u003C/a\u003E 기반의 \u003Ca class='wiki-link-internal' href='/w/C%2B%2B#s-4' title='C++'\u003E일반화 프로그래밍(Generic Programming)\u003C/a\u003E 개념이 코드 난독화에 결정타를 날렸는데 Java는 연산자 오버로딩을 배제하고 오로지 \u003Cstrong\u003E\u003Ca class='wiki-link-internal' href='/w/%EB%A9%94%EC%86%8C%EB%93%9C' title='메소드'\u003E메소드\u003C/a\u003E\u003C/strong\u003E를 통해서만 객체의 조작을 허용함으로써 코드의 일관성을 지켜냈다.\u003Ca class='wiki-fn-content' title='하지만 연산자 오버로딩은 분명 제네릭 프로그래밍에 도움을 준다. 가령 제네릭 클래스 내에서 주어진 타입의 변수 두 개를 더하는 연산을 하고 싶다면? 더하는 연산 등 여러 일반적인 작업들은 Java의 primitive 타입에만 필요한 것은 아니다. 행렬 등이 그런 대표적인 예다. 이러한 측면에서 본다면 프로그래머의 작업에 있어서의 일관성은 훼손됐다고 볼 수도 있다.' href='#fn-17'\u003E\u003Cspan class='target' id='rfn-17'\u003E\u003C/span\u003E&#91;17&#93;\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%85%9C%ED%94%8C%EB%A6%BF#s-6' title='템플릿'\u003EC++ 템플릿\u003C/a\u003E 프로그래밍의 주 사용 용도인 일반화 프로그래밍도 \u003Cstrong\u003E제네릭\u003C/strong\u003E이라는 더 쉬운 개념을 도입해서(Java 5부터 지원) 코드의 가독성을 해치지 않고 일반화 프로그래밍을 성공적으로 도입했다.\u003Ca class='wiki-fn-content' title='다만 제네릭은 Type Erasure를 사용하기 때문에 개념적으로 C++의 템플릿과 다르며, 할 수 있는 일도 거의 일반화 프로그래밍 자체로만 한정돼 있다.' href='#fn-18'\u003E\u003Cspan class='target' id='rfn-18'\u003E\u003C/span\u003E&#91;18&#93;\u003C/a\u003E\u003Ca class='wiki-fn-content' title='기존에 앞 문단 서술에 사용되었던 용어인 &quot;템플릿 메타 프로그래밍&quot;은 개념을 오해하여 사용한 것이므로 &quot;일반화 프로그래밍&quot;으로 대체하였다. 일반화 프로그래밍(Generic Programming)은 Java나 C#에도 &quot;제네릭&quot;이라는 형태로 구현되어 있다. 그러나 템플릿 메타 프로그래밍(Template Meta-Programming)은 Java나 C#에서 전혀 구현되지 않는 별도의 개념이다. 아마도 C++에서 쓰는 &quot;템플릿&quot;이라는 용어와 Java의 &quot;제네릭&quot;이라는 용어가 같은 것을 지칭한다고 착각해서 나온 결과로 추정된다. C++ 템플릿 프로그래밍 = &quot;일반화 프로그래밍 + 템플릿 메타 프로그래밍&quot;, Java/C# 제네릭 = &quot;일반화 프로그래밍&quot;으로 이해하면 쉽다. &quot;템플릿 메타 프로그래밍&quot;은 C++, D 등 극소수의 언어만 지원한다.' href='#fn-19'\u003E\u003Cspan class='target' id='rfn-19'\u003E\u003C/span\u003E&#91;19&#93;\u003C/a\u003E 키워드에 약어 사용을 자제한 점도 코드 가독성 상승에 기여했다.\u003Cbr\u003E\u003Cbr\u003E하지만 Java가 로우레벨 언어인 C나 C++보다 읽기 쉽다고 해서\u003Ca class='wiki-fn-content' title='이 부분은 주관적인 것으로 C/C++가 Java보다 가독성이 좋지 않다는 것에 대해 동의하지 않는 시각도 많다는 점을 알려둔다.' href='#fn-20'\u003E\u003Cspan class='target' id='rfn-20'\u003E\u003C/span\u003E&#91;20&#93;\u003C/a\u003E 일반적인 시각에서 보기에 가독성이 좋은 언어는 아닌데, 그 이유는 단점 항목에서 언급된 소스 코드의 길이 문제 때문이다. 일반적으로 개발자들 사이에서 Java가 가독성이 좋은 언어로 통용되지는 않는다. \u003Ca class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'\u003EKotlin\u003C/a\u003E이 구글에 의해 Java의 대체 언어로 선정된 이유는 오라클과의 저작권 관련 분쟁 때문도 있지만, Java 문법의 장황함과 가독성의 불편함에서 기인한 것이기도 하다. 비유를 하자면 Java는 입문 장벽을 낮춘 대신 이런저런 제약을 울타리처럼 둘러친 언어이고, C/C++는 프로그래머에게 자유도를 부여한 대신 입문 장벽을 높여버린 언어라고 할 수 있다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-7.2' href='#toc'\u003E7.2.\u003C/a\u003E \u003Cspan id='단점'\u003E단점\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=32' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.2.1' href='#toc'\u003E7.2.1.\u003C/a\u003E \u003Cspan id='속도 문제'\u003E속도 문제\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=33' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E여기서 잠시 유의할 점은, 느리다는 내용은 대부분 C/C++, Pascal, Fortran 같은 네이티브 바이너리 코드를 만드는 언어와 비교했을 때의 이야기이다. Java가 C/C++보다 2~3배 느리다고 하지만 다른 고수준 언어들에 비해서는 그리 떨어지지 않는다.\u003Ca class='wiki-fn-content' title='Java는 JIT 컴파일을 기본적으로 사용하기 때문이다. C#이나 PHP 7와 같은 고수준 언어도 해당사항이다. ' href='#fn-21'\u003E\u003Cspan class='target' id='rfn-21'\u003E\u003C/span\u003E&#91;21&#93;\u003C/a\u003E 특히 인터프리터/스크립트 언어는 구조적으로 Java에 비해서도 훨씬 느리다는 것을 기억하자. 예를 들어 요즘 인기있는 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E은 C보다 수십 배 느리다. 그나마 빠르다고 하는 \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E도 Java에 비해서 2배 정도 느리다.\u003Cbr\u003E\u003Cbr\u003E또한 속도 관련 문제는 하드웨어의 성능이 점점 좋아지고 메모리 가격이 떨어지면서 희석되고 있다. 처음 Java가 나왔을 때인 1995년만 하더라도, 느린 성능 때문에 그다지 많이 쓰이지는 않을 것이라고 예상했지만 현재 Java가 가장 많이 사용되는 곳 중 하나는 안정성과 일정 수준 이상의 성능이 요구되는 서버다. Java가 네이티브 코드보다 느리지만 대부분의 상황에서는 큰 문제가 되지 않는다.\u003Cbr\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch5 class='wiki-heading'\u003E\u003Ca id='s-7.2.1.1' href='#toc'\u003E7.2.1.1.\u003C/a\u003E \u003Cspan id='JVM 로딩 속도 문제'\u003EJVM 로딩 속도 문제\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=34' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h5\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava의 심각한 단점 중 하나는, 실행하는 과정에서 \u003Ca class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'\u003EJava Virtual Machine\u003C/a\u003E이 \u003Cstrong\u003E반드시\u003C/strong\u003E 완벽하게 로딩되어야 하기 때문에 프로그램의 초기 시작 시간이 완전한 이진 코드로 컴파일된 프로그램을 실행하는 것에 비해 오래 걸리는 것이다.  단적인 예로, 아무것도 안하고 콘솔 화면에 달랑 &quot;Hello, World!&quot; 라고 찍기만 하는 프로그램이 실행되는 데에도 thread가 10개 쯤 뜬다. 특히 그 프로그램에 AWT, Swing, SQL 같이 불필요한 기능을 끌어들이는 것은 매우 심각한 문제이다. 이 문제는 런타임 자체가 아직 모듈화되지 않았다는 점에서 기인한다.\u003Cbr\u003E\u003Cbr\u003E하지만 요즘 같은 고사양 컴퓨터에서는 아주 많은 라이브러리를 끌어오는 것이 아니라면 체감상 차이는 크게 나지 않는다. 또한 Java 9부터는 드디어 \u003Cstrong\u003E런타임 라이브러리를 모듈화\u003C/strong\u003E하고 있으므로, 필요한 모듈만 끌어서 프로그램을 짤 수 있다.\u003C/div\u003E\u003C/div\u003E\u003Ch5 class='wiki-heading'\u003E\u003Ca id='s-7.2.1.2' href='#toc'\u003E7.2.1.2.\u003C/a\u003E \u003Cspan id='가상 머신 바이트코드 실행 속도 문제'\u003E가상 머신 바이트코드 실행 속도 문제\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=35' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h5\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EC/C++, Pascal, Fortran과 같은 언어와 달리, Java는 \u003Ca class='wiki-link-internal' href='/w/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C' title='바이트코드'\u003E바이트코드\u003C/a\u003E로 된 프로그램을 실행하기 위해 운영체제와 프로그램 사이에 \u003Ca class='wiki-link-internal' href='/w/JVM' title='JVM'\u003EJVM\u003C/a\u003E이라는 두꺼운 계층이 하나 더 자리잡게 된다. 그리고 바이트코드는 실시간으로 각 타겟 플랫폼용 기계어로 번역되어 실행된다. 이로 인해 네이티브 바이너리 코드를 출력하는 언어와 비교하여 실행속도와 성능에 일정 부분 손실이 발생할 수밖에 없다. AWT, Swing 같은 GUI 라이브러리를 사용할 때도 심각하게 느린 것을 체감할 수 있다. 이런 문제점을 썬 마이크로시스템즈도 곧 깨달았고, 최초 발표에서 2년 후인 1998년부터 \u003Ca class='wiki-link-internal' href='/w/JIT' title='JIT'\u003EJIT\u003C/a\u003E 컴파일러를 JVM에 내장하여 성능이 상당 부분 개선되었다. 하지만, 그만큼 \u003Ca class='wiki-link-internal' href='/w/%EB%A9%94%EB%AA%A8%EB%A6%AC' title='메모리'\u003E메모리\u003C/a\u003E가 뒷받침해줘야 한다. 현재는 보통 같은 기능/알고리즘을 실행하는 데 C++보다 2~3배 정도의 시간이 더 필요하다고 알려져 있다. 이 부분은 꽤 초기부터 지속적으로 개선되어 왔기 때문에 현재 실행속도 자체에 대한 이슈는 예전에 비해 많이 줄어든 편이다.\u003Cbr\u003E\u003Cbr\u003E이 문제는 Java 9에서 &#39;선행 컴파일&#39;이라는 이름으로 개선될 예정이다. JIT 컴파일로 실행과 동시에 컴파일을 하는 게 아니라 기존의 정적 컴파일처럼 바이트코드를 미리 기계어로 번역하면, 컴파일 속도는 다소 느려지지만 실행 속도는 빨라지게 된다. 물론 컴파일 한 번으로 여러 플랫폼에서 동일하게 실행시키는 건 불가능해진다.\u003C/div\u003E\u003C/div\u003E\u003Ch5 class='wiki-heading'\u003E\u003Ca id='s-7.2.1.3' href='#toc'\u003E7.2.1.3.\u003C/a\u003E \u003Cspan id='가비지 컬렉션에 의한 실행 지연 문제'\u003E가비지 컬렉션에 의한 실행 지연 문제\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=36' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h5\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EC%93%B0%EB%A0%88%EA%B8%B0%20%EC%88%98%EC%A7%91' title='쓰레기 수집'\u003E가비지 컬렉션\u003C/a\u003E에 의한 메모리 프리징 현상\u003Ca class='wiki-fn-content' title='메모리를 훑으면서 순간적으로 프로그램이 얼어붙어 멈추는 현상.' href='#fn-22'\u003E\u003Cspan class='target' id='rfn-22'\u003E\u003C/span\u003E&#91;22&#93;\u003C/a\u003E이 초반부터 지속적으로 Java를 괴롭혔다. 멀쩡하게 동작해야 할 프로그램이 순간적으로 뚝 뚝 끊기는 듯한 현상이 발생하는 것. 오늘날 Java의 문제는 바이트코드 변환으로 인한 속도 저하보다 이 가비지 컬렉션의 영향이 더 크다고 할 수 있다. 이러한 문제점은 가비지 컬렉션을 지원하는 다른 프로그래밍 언어들도 마찬가지이긴 하지만 실행속도와 함께 Java 초기부터 꾸준히 문제로 꼽혀온 것으로, 버전이 올라갈 때마다 다양하게 개선되어 왔다.\u003Cbr\u003E\u003Cbr\u003EJava 8부터는 메모리 누수를 일으키던 메소드 영역의 PermGen Area를 제거하여 static 인스턴스와 리터럴 문자열도 GC의 대상이 되도록 바뀌었으며, 클래스, 메소드, 배열의 메타 정보는 동적 리사이징이 가능한 Metaspace로 이동시켜 시스템 힙 영역에 저장된다. 덕분에 JVM 힙 영역의 공간이 늘어나고 PermGen Area를 스캔/삭제할 필요가 없어져 GC의 성능이 대폭 향상되었다.\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.2.2' href='#toc'\u003E7.2.2.\u003C/a\u003E \u003Cspan id='불편한 예외 처리'\u003E불편한 \u003Ca class='wiki-link-internal' href='/w/%EC%98%88%EC%99%B8%20%EC%B2%98%EB%A6%AC' title='예외 처리'\u003E예외 처리\u003C/a\u003E\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=37' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E다른 객체지향 언어들처럼, Java 역시 try~catch문으로 대표되는 예외 처리를 할 수 있다. 대부분의 언어에서 차용하고 있는 좋은 기능이지만... 유독 Java는 다른 언어와는 달리 프로그래머의 검사가 필요한 예외(Exception을 직접 상속하는 예외 클래스)가 등장한다면 무조건 프로그래머가 선언을 해줘야 한다. 그렇지 않으면 \u003Cstrong\u003E컴파일조차 거부한다.\u003C/strong\u003E 원래 의도는 철저한 예외 처리를 하니까 만약에 발생할 수 있는 모든 상황에 안정성을 확보할 수 있겠지...였으나, 결국 대부분의 경우엔 \u003Cstrong\u003E귀찮다\u003C/strong\u003E는 이유로, 가장 일반적인 예외인 Exception \u003Cdel\u003E더 막나가면 Throwable\u003C/del\u003E 하나만 써서 넘어가버리고\u003Ca class='wiki-fn-content' title='이를 gotta catch &#39;em all 패턴이라고 한다.' href='#fn-23'\u003E\u003Cspan class='target' id='rfn-23'\u003E\u003C/span\u003E&#91;23&#93;\u003C/a\u003E 폭탄 돌리듯 넘기기만 하거나(예외 던지기만 하고 try~catch 안하면 메소드를 돌고 돌다가 콰광!), 예외 나든 말든 무시해 버리는 경우가 가장 흔하다.\u003Ca class='wiki-fn-content' title='물론 이렇게 짜면 안되지만 구조적으로 강요받는 형편.' href='#fn-24'\u003E\u003Cspan class='target' id='rfn-24'\u003E\u003C/span\u003E&#91;24&#93;\u003C/a\u003E 이런 코드가 너무 흔해 빠진 나머지 이딴 식으로 쓸 거면 왜 넣었냐고 까는 사람도 많다. 그런데 선언이 필요없는, \u003Cstrong\u003E검사 안하는\u003C/strong\u003E 예외도 Java에 많다(...).\u003Ca class='wiki-fn-content' title='이쪽은 RuntimeException 계열의 예외로, 이것을 던지는 메소드가 throws에 명시적으로 던진다고 선언하지 않았을 경우 검사를 하지 않아도 된다.' href='#fn-25'\u003E\u003Cspan class='target' id='rfn-25'\u003E\u003C/span\u003E&#91;25&#93;\u003C/a\u003E 그리고 C++이나 C# 같이 예외가 있는 언어라도 Java처럼 예외를 쓰는 경우는 별로 없다. 두 언어는 모든 예외가 \u003Cstrong\u003E검사 안하는\u003C/strong\u003E 예외이다. 사실 예외 처리를 한다는 것은 귀차니즘과 견고함을 맞바꾸는 일인데, \u003Ca class='wiki-link-internal' href='/w/%EB%82%B4%EB%A0%A4%EA%B0%88%20%ED%8C%80%EC%9D%80%20%EB%82%B4%EB%A0%A4%EA%B0%84%EB%8B%A4' title='내려갈 팀은 내려간다'\u003E안할 사람은 문법으로 강제해도 안한다\u003C/a\u003E는 것을 보여준다.\u003Cbr\u003E\u003Cbr\u003E대부분의 다른 언어에서는 원하는 에러만 try-catch문으로 뽑아내고 그렇지 않은 경우에는 그냥 아무 처리를 해주지 않아도 된다. 이러한 언어를 접하던 사람이 Java를 접하면 그 특유의 경직된 예외처리에 불편해하기도 한다. 오히려 명시적으로 예외처리를 할 수 없는 경우도 존재하는데, 인터페이스를 상속받을 때 인터페이스에 선언된 예외가 아니면 구현 클래스에서 그 예외를 던질 수 없다! 특히, Java에서 제공하는 Iterator 인터페이스에는 throws 선언 따위는 없기 때문에 Iterator를 구현받았을 때 명시적으로 예외를 던질 수 없다. 이 상황을 해결하려면 RuntimeException 계열을 쓸 수밖에 없는 상황이 펼쳐진다.\u003Cbr\u003E\u003Cbr\u003E다만, 상기의 내용은 실무적 접근에 의한 내용이고, 실제로는 이는 장점으로도 취급되기도 한다. Assert문을 자유자재로 쓰면서 예외처리를 하거나 코딩과 동시에 발생할 수 있는 각종 예외들을 인지하고 처리해주는 걸 잊어먹는 경우에 대한 대처가 가능하다.\u003Ca class='wiki-fn-content' title='대한민국에 국한되는 경향이 강하긴 하지만 현재 한국에서 이러한 예외처리를 코딩하는 순간에 인지하는 개발자는 드물다. 국비지원 학원을 막 졸업한 신입들은 말 할 것도 없으며 현업 몇년 한 초중급 경력자들 역시 이를 인지하지 못하는 경우가 허다하기 때문에, 어찌보면 대한민국 IT계의 버그처리와 예외처리에 있어서만큼은 장점으로 볼 수도 있다.' href='#fn-26'\u003E\u003Cspan class='target' id='rfn-26'\u003E\u003C/span\u003E&#91;26&#93;\u003C/a\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.2.3' href='#toc'\u003E7.2.3.\u003C/a\u003E \u003Cspan id='소스 코드 길이'\u003E소스 코드 길이\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=38' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava는 소스 코드의 길이가 다른 언어에 비해 상당히 긴 편이다. 같은 기능을 하는 코드를 짠다고 했을 때 다른 언어에 비해 타이핑해야 할 양이 많다. 구체적으로 말하자면 일명 Boilerplate라고 부르는, 기본적인 구조를 짜기 위해서 무조건 의무적으로 작성해 주어야만 하는 서식과 코드의 분량이 많다.\u003Cbr\u003E\u003Cbr\u003E인터프리터 언어에서는 puts(&quot;Hello&quot;) 정도로 끝났을 일을 Java에서는\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"java\"\u003E\u003Cspan class=\"syntax-keyword\"\u003Epackage\u003C/span\u003E wiki.namu.test;\n\n\u003Cspan class=\"syntax-keyword\"\u003Epublic\u003C/span\u003E \u003Cspan class=\"syntax-keyword\"\u003Eclass\u003C/span\u003E HelloWorld {\n    \u003Cspan class=\"syntax-keyword\"\u003Epublic\u003C/span\u003E \u003Cspan class=\"syntax-keyword\"\u003Estatic\u003C/span\u003E \u003Cspan class=\"syntax-keyword\"\u003Evoid\u003C/span\u003E main(String[] args) {\n        System.out.println(\u003Cspan class=\"syntax-literal\"\u003E\"Hello\"\u003C/span\u003E);\n    }\n}\u003C/code\u003E\u003C/pre\u003E\u003Cbr\u003E이만큼을 써야 한다. 같은 일을 하는 \u003Ca class='wiki-link-internal' href='/w/C(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4)' title='C(프로그래밍 언어)'\u003EC\u003C/a\u003E언어 코드는\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"cpp\"\u003E#include &lt;stdio.h&gt;\n\n\u003Cspan class=\"syntax-keyword\"\u003Eint\u003C/span\u003E main() { \n    puts(\u003Cspan class=\"syntax-literal\"\u003E\"Hello\"\u003C/span\u003E);\n}\u003C/code\u003E\u003C/pre\u003E\u003Ca class='wiki-fn-content' title='사실 C(C++이 아니다)는 C99기준 stdio.h를 포함하지 않아도 puts, printf 등을 사용할 수 있다. C, C++ 공통으로는(C++11기준) main에 int를 붙이지 않아도 콤파일이 된다. 따라서 더 짧게 쓴다면 main() {　　puts(&quot;Hello&quot;);}이 된다.' href='#fn-27'\u003E\u003Cspan class='target' id='rfn-27'\u003E\u003C/span\u003E&#91;27&#93;\u003C/a\u003E\u003Cbr\u003E파이썬의 경우\u003Cbr\u003E\u003Cpre\u003E\u003Ccode class=\"syntax\" data-language=\"python\"\u003Eprint(\u003Cspan class=\"syntax-literal\"\u003E\"Hello\"\u003C/span\u003E)\u003C/code\u003E\u003C/pre\u003E\u003Cbr\u003E\u003Cdel\u003E이걸 브라우저 콘솔에 치면 인쇄 창이 나온다\u003C/del\u003E\u003Cbr\u003E\u003Cdel\u003E\u003Ca class='wiki-link-internal' href='/w/HQ9%2B' title='HQ9+'\u003EHQ9+\u003C/a\u003E의 경우 H\u003C/del\u003E\u003Cbr\u003E위키책에 있는 Hello World 프로그램의 \u003Ca class='wiki-link-external' href='https://en.wikibooks.org/wiki/Computer_Programming/Hello_world' target='_blank' rel='nofollow noopener' title='https://en.wikibooks.org/wiki/Computer_Programming/Hello_world'\u003E목록\u003C/a\u003E이나, 나무위키 내의 \u003Ca class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4/%EC%98%88%EC%A0%9C' title='프로그래밍 언어/예제'\u003E프로그래밍 언어/예제\u003C/a\u003E 문서를 보면 하이레벨 언어 중에서는 코드량이 긴 편인 걸 알 수 있다.\u003Cbr\u003E\u003Cbr\u003E오죽하면 \u003Ca class='wiki-link-external' href='https://medium.com/@webseanhickey/the-evolution-of-a-software-engineer-db854689243' target='_blank' rel='nofollow noopener' title='https://medium.com/@webseanhickey/the-evolution-of-a-software-engineer-db854689243'\u003E이런\u003C/a\u003E 포스트가 만들어질까. 물론 이건 Java의 문제가 아니고 마세라티 문제\u003Ca class='wiki-fn-content' title='그 마세라티가 맞다. 자신이 탈수나 있을지도 모르는 마세라티를 타면 어떻게 해야 될까... 라는 쓸데없는 고민을 하는 것을 비유하는 문제로, 당장에 쓸데없는 기능을 위해 과도하게 투자하는 것을 의미한다.' href='#fn-28'\u003E\u003Cspan class='target' id='rfn-28'\u003E\u003C/span\u003E&#91;28&#93;\u003C/a\u003E라고 알려진 프로그래머의 과욕이 부른 참상이지만 코드에 유연성을 조금 추가하기 위해 써 넣어야 할 코드의 길이가 기하급수로 증가한다는 하나의 예시로 볼 수 있다. 참고로 저 포스트의 5년차 코드는 \u003Ca class='wiki-link-internal' href='/w/Spring(%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC)' title='Spring(프레임워크)'\u003ESpring\u003C/a\u003E의 패러디다. Java 이후에 나온 차세대 언어들은 같은 수준의 유연성을 확보하기 위해 들여야 할 노력의 양이 훨씬 적다.\u003Cbr\u003E\u003Cbr\u003E이렇게 의도적인 장황함(verbosity)을 추구하는 언어 설계와 커뮤니티의 문화가 아이러니하게도 위에서 언급한 장점이 무색하게 가독성을 저해하는 요인이 되기도 한다. 같은 기능을 하더라도 수십 줄의 보일러플레이트 코드를 가지는 Java 코드보다 다른 언어의 코드가 보통은 더 읽기 쉽기 때문. \u003Cbr\u003E\u003Cbr\u003E게다가 다른 하이레벨 언어(C#, Python, Ruby 등)에 비해 문법적 설탕(Syntactic sugar)\u003Ca class='wiki-fn-content' title='프로그래밍 언어를 좀 더 쉽게 표현할 수 있도록 하는 보조문법. C에서 구조체 포인터를 쓸 때 (*ptr).num은 ptr-&gt;num으로도 표현 가능하므로, -&gt;는 문법적 설탕이라고 할 수 있다.' href='#fn-29'\u003E\u003Cspan class='target' id='rfn-29'\u003E\u003C/span\u003E&#91;29&#93;\u003C/a\u003E이 적어 이쪽에서 넘어오면 꽤 불편해하는 편. 하지만 최근 Java 8로 넘어오면서 람다 표현식, 스트림\u003Ca class='wiki-fn-content' title='컬렉션(Collection)의 이터레이터를 확장해서 처리할 수 있는 개념으로, 이터레이터의 원소를 필터링해서 원하는 원소만 뽑거나, 원소갯수를 줄여버리고, 이렇게 다시 뽑혀진 원소들로 갖가지 처리를 만드는 등 &#39;함수적인(functional)&#39; 기능을 제공한다.' href='#fn-30'\u003E\u003Cspan class='target' id='rfn-30'\u003E\u003C/span\u003E&#91;30&#93;\u003C/a\u003E 등을 지원하는 식으로 문법적 편리함을 늘려가는 추세다. 이 흐름은 다음 Java 9에서 더욱 강화될 것으로 보는 추세.\u003Ca class='wiki-fn-content' title='정작 람다 표현식의 추가는 Java 진영 내에서 논란이 있다. 람다 식이 뒤늦게 추가된 것도 코드 리딩이 어려워진다고 싫어하는 개발자가 많아서였다.' href='#fn-31'\u003E\u003Cspan class='target' id='rfn-31'\u003E\u003C/span\u003E&#91;31&#93;\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E그러나 무조건 타이핑의 양이 많다고 해서 나쁜 것만 있는 것이 아니다. 일단 Java는 명색이 클래스 지향적이기 때문에 어쩔 수 없는 부분이고, 커다란 프로젝트 단위에서 봤을 땐 오히려 클래스와 메소드, 변수의 소속이 확실하기 때문에 코드를 금방 파악할 수 있다. 축약어의 사용을 최대한 자제하는 방향으로 만들었기 때문에 그렇다.\u003Ca class='wiki-fn-content' title='멀리 갈 것 없이, C언어의 stdio.h와 자바의 System.out을 비교해보자. Java는 직관적으로 &#39;시스템&#39;에서 뭔가가 &#39;나온다&#39;는 것을 쉽게 인식할 수 있지만, stdio.h를 봤을 때 직관적으로 뭘 떠올릴까? 저걸 처음 보고 STanDard Input and Output을 떠올릴 사람이 얼마나 있을까? 물론 C를 하다 보면 언어 기능 자체가 적어 파악하기가 쉬운 건 함정이다 ' href='#fn-32'\u003E\u003Cspan class='target' id='rfn-32'\u003E\u003C/span\u003E&#91;32&#93;\u003C/a\u003E Python이나 JavaScript 같은 동적 타입 언어들은 소규모 프로젝트에는 좋겠지만 대형 프로젝트에서는 불편할 수도 있다.\u003Cbr\u003E\u003Cbr\u003EJetBrains에서 개발한 \u003Ca class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'\u003EKotlin\u003C/a\u003E은 바로 이 Java의 언어적 불편함을 최소화하려고 나온 새 프로그래밍 언어이며, \u003Ca class='wiki-link-internal' href='/w/%EC%B9%B4%EC%B9%B4%EC%98%A4(%EA%B8%B0%EC%97%85)' title='카카오(기업)'\u003E카카오\u003C/a\u003E에서도 카카오톡 메시징 서버에 Kotlin을 도입하는 등(\u003Ca class='wiki-link-external' href='https://byline.network/2018/09/5-20/' target='_blank' rel='nofollow noopener' title='https://byline.network/2018/09/5-20/'\u003E#\u003C/a\u003E) Java를 Kotlin으로 대체하려는 움직임이 조금씩 나타나고 있다.\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-7.2.4' href='#toc'\u003E7.2.4.\u003C/a\u003E \u003Cspan id='언어적 불편함'\u003E언어적 불편함\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=39' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003C/div\u003E\u003Ch5 class='wiki-heading'\u003E\u003Ca id='s-7.2.4.1' href='#toc'\u003E7.2.4.1.\u003C/a\u003E \u003Cspan id='명사형 사고를 강제'\u003E명사형 사고를 강제\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=40' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h5\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava는 모든 동작이 객체 상위에서 이루어지게 함으로써 명사형으로 생각하는 것을 강제한다. 그 결과로 Java에는 전역 함수가 없고 모든 함수는 어떤 클래스에 종속되어있다. 이 때문에 기능적인 부분을 작성하는데 자잘한 클래스들을 작성해야 한다는 불편함이 있다.\u003Cbr\u003E\u003Cbr\u003E이런 명사 중심적 생각은 확실히 많은 경우 편리하나 동사 중심으로 생각해야 하는 상황도 생각보다 흔하다는 게 문제. 예를 들어서, 퀵소트를 Java에서 엄격하게 의도된 대로 짜려면 quickSort(array)라는 함수 대신 QuickSorter라는 객체의 생성자에 배열을 넣고, 그 생성자를 참조하는 참조변수를 이용해 run()을 호출하여 동작시켜야 하는 것이다.\u003Ca class='wiki-fn-content' title='실제로 Java에서 기본 제공하는 정렬 기능은 Collections 클래스의 정적 메소드인 sort(array)를 호출하도록 작성되어 있다.' href='#fn-33'\u003E\u003Cspan class='target' id='rfn-33'\u003E\u003C/span\u003E&#91;33&#93;\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E\u003Ca class='wiki-link-internal' href='/w/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4' title='디자인 패턴'\u003E디자인 패턴\u003C/a\u003E을 사용해서 어느 정도 동사형 사고방식으로 코드를 작성할 수 있긴 하다. 디자인 패턴에서 핵심적 지위를 차지하는 \u003Cstrong\u003E인터페이스\u003C/strong\u003E라는 놈을 사용하면 상당히 동사적인 관점으로 객체를 다룰 수 있다. Java의 리플렉션 API를 사용하는 방법도 있고. 하지만 애초에 언어가 생겨먹은 것 자체가 명사 기준으로 생각하게 디자인된 건 사실이다. Java의 근간을 이루는 표준 java.lang 클래스와 java.util 클래스를 동사형 사고방식으로 재작성하기 전에는 힘들다. 이 재작성 삽질은 이미 \u003Ca class='wiki-link-internal' href='/w/Scala' title='Scala'\u003EScala\u003C/a\u003E에서 해 놨으므로 Java의 이러한 특징이 싫다면 Scala를 쓰면 된다.\u003C/div\u003E\u003C/div\u003E\u003Ch5 class='wiki-heading'\u003E\u003Ca id='s-7.2.4.2' href='#toc'\u003E7.2.4.2.\u003C/a\u003E \u003Cspan id='클로저 미지원'\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%81%B4%EB%A1%9C%EC%A0%80' title='클로저'\u003E클로저\u003C/a\u003E 미지원\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=41' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h5\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E명사형 생각을 강제한다는 것의 연장선. 버전 7 이하의 Java는 함수를 일급 객체로 취급하지 않는다. 어떤 &#39;동작&#39;을 넘겨야 할 때는 그 동작을 추상화한 인터페이스를 만들고, 그것을 클래스로 구현한 뒤, 객체를 파라미터로 넘겨야 한다. 반면에 클로저를 지원하는 언어는 그냥 함수를 파라미터로 넘기면 된다.\u003Cbr\u003E\u003Cbr\u003EJava의 수많은 디자인 패턴들은 이 클로저 미지원 문제 때문에 만들어졌다. Java라는 언어가 설계될 당시에는 클로저라는 개념 자체가 \u003Ca class='wiki-link-internal' href='/w/LISP' title='LISP'\u003ELISP\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Haskell' title='Haskell'\u003EHaskell\u003C/a\u003E, ML 등의 언어을 사용하거나 프로그래밍 언어를 연구하는 사람들이나 아는 몹시 마이너한 개념이었기 때문에 동시기에 만들어진 다른 많은 프로그래밍 언어들도 클로저를 지원하고 있지는 않았다. 따라서 설계 결함이라고 부를 수는 없고 현대에 들어서 단점으로 부각되기 시작했다는 편이 더 적절하다.\u003Cbr\u003E\u003Cbr\u003EJava 8에서는 람다 표현식을 지원함과 더불어 메소드 참조라는 방식(this::add)을 통해 함수를 다른 함수의 파라미터로 넘길 수 있게 되었다. 이러한 함수 파라미터는 Functional Interface를 이용하여 선언하는데, Functional Interface는 수십여 종이 있으며 인자가 복수개인 것도 당연히 있고, 하나의 추상 메소드를 가진 인터페이스를 새로 만들어서 써도 된다. 다만 자바의 람다식은 바깥에 있는 변수를 참조하려면 그 변수가 final이거나 final을 붙여도 문제가 없는 변수들 뿐이다. 따라서 람다식이 주위에 있는 변수를 &#39;저장&#39;할 수는 있으나 그것의 값을 바꿀수는 없다.\u003Cbr\u003E\u003Cbr\u003Ejava.util.function에 있는 대표적인 함수형 인터페이스 (Functional Interface)와 그에 대응하는 추상 메소드 몇개를 나열하자면 다음과 같다.\u003Cbr\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EPredicate&lt;T&gt; ⇒ boolean test(T)\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EConsumer&lt;T&gt; ⇒ void accept(T)\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003ESupplier&lt;T&gt; ⇒ T get() \u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EFunction&lt;T, U&gt; ⇒ U apply(T)\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EBiFunction&lt;T, U, R&gt; ⇒ R apply(T, U)\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-8' href='#toc'\u003E8.\u003C/a\u003E \u003Cspan id='개발환경, JVM 언어'\u003E개발환경, JVM 언어\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=42' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-8.1' href='#toc'\u003E8.1.\u003C/a\u003E \u003Cspan id='개발환경'\u003E개발환경\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=43' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava에 특정한 라이브러리를 가미해서 웹에서 돌릴 수 있게 한 것이 \u003Ca class='wiki-link-internal' href='/w/Java%20Applet' title='Java Applet'\u003EJava Applet\u003C/a\u003E이다. 애플릿 특유의 제약으로 인해 \u003Ca class='wiki-link-internal' href='/w/ActiveX' title='ActiveX'\u003EActiveX\u003C/a\u003E보다는 훨씬 안전하다는 이유로 물 건너에서는 인터넷 뱅킹이나 결제용도로 사용하기도 한다. 근데 상대적으로 안전하다는 것일 뿐, 애플릿을 사용한 결제시스템도 툭하면 뚫려서 문제가 발생하곤 한다(…). 더군다나 \u003Ca class='wiki-link-internal' href='/w/%EC%95%84%EC%9D%B4%ED%8F%B0' title='아이폰'\u003E아이폰\u003C/a\u003E과 \u003Ca class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C' title='안드로이드'\u003E안드로이드\u003C/a\u003E에서는 되지 않는다. 게다가 크롬과 파이어폭스 등의 브라우저들이 NPAPI 지원 중단 선언을 하고, Java 9부터 애플릿의 개발이 중단되면서 결국 수명이 끝나게 되었다. 이 문제들은 자바 애플릿만이 아닌 다른 대부분의 리치 인터넷 애플리케이션들의 문제점이기도 하다.\u003Cbr\u003E\u003Cbr\u003E웹 애플리케이션 제작을 위해 Java 언어를 사용하는 규격으로 Java 서블릿과 \u003Ca class='wiki-link-internal' href='/w/JSP' title='JSP'\u003EJSP\u003C/a\u003E(Java 서버 페이지)가 있다.\u003Ca class='wiki-fn-content' title='JSP의 목적이 HTML 페이지를 동적으로 만들어내는 것이다. JSP 소스는 Java 서블릿 코드로 변환되어 서버에서 실행되고, 서버는 이 HTML 결과를 브라우저에 보여준다. JSP 페이지는 HTML 페이지에 Java 코드가 포함되어 있는 식으로 되어 있는 경우가 많고, 이 점은 PHP, ASP.NET 등과 비슷한 편이다. 반면 Java 서블릿은 서버 쪽에서 하는 일에 관심이 많지만 출력에 대한 관심은 적다. 필요하다면 브라우저에 출력을 전혀 안 보낼 수도 있다. 최근에는 Server side script language로 HTML 페이지를 동적으로 만드는 식으로는 프로그래밍을 하지 않는다. JSP, PHP와 같은 Server side script language로는 서버에 있는 자원의 접근을 주로 하고(DB 연산, File 연산 등등) 화면에 보여주는 UI는 HTML/CSS/JavaScript로만 한다. 따라서 Client side와 Server side 간에 통신이 필요한데 이는 XHR(XML HTTP Request)를 이용한다. 이러한 프로그래밍 기법을 나타내는 표현이 REST 내지는 Open API이다.' href='#fn-34'\u003E\u003Cspan class='target' id='rfn-34'\u003E\u003C/span\u003E&#91;34&#93;\u003C/a\u003E 주로 기업에서 사용한다. 개인 웹호스팅에서는 이를 지원하는 경우는 많지 않다. 그러나 최근 Java를 지원하는 여러 \u003Ca class='wiki-link-internal' href='/w/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EC%BB%B4%ED%93%A8%ED%8C%85' title='클라우드 컴퓨팅'\u003E클라우드 컴퓨팅\u003C/a\u003E 서비스가 싼 가격에 등장하고 있고, Java 뿐만이 아닌 JVM 언어를 이러한 환경에서 구동하는 사례가 늘고 있다.\u003Cbr\u003E\u003Cbr\u003EJava Development Kit(Java 개발 도구)을 설치하면 javac라는 컴파일러가 제공된다. 하지만 \u003Ca class='wiki-link-internal' href='/w/%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD' title='통합 개발 환경'\u003E통합 개발 환경\u003C/a\u003E은 제공해 주지 않기 때문에, 반드시 별도의 개발용 프로그램을 써야 한다. 대표적으로 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'\u003E이클립스\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/%EB%84%B7%EB%B9%88%EC%A6%88' title='넷빈즈'\u003E넷빈즈\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/IntelliJ%20IDEA' title='IntelliJ IDEA'\u003EIntelliJ IDEA\u003C/a\u003E 등이 있다. 만약 이것들을 안 쓰겠다고 한다면, 당신에게는 메모장과 javac.exe가 있을 뿐이다. 그리고 Java는 \u003Ca class='wiki-link-internal' href='/w/%EB%82%A0%EC%BD%94%EB%94%A9' title='날코딩'\u003EIDE 없이 타이핑만으로 짜기엔\u003C/a\u003E 굉장히 불편한 언어라는 것을 명심하자.\u003Ca class='wiki-fn-content' title='Java는 현용 프로그래밍 언어 중에서는 가장 Verbose한(장황한) 언어로 꼽힌다. 즉, 같은 의미인데 많은 타이핑이 필요하다.' href='#fn-35'\u003E\u003Cspan class='target' id='rfn-35'\u003E\u003C/span\u003E&#91;35&#93;\u003C/a\u003E 실전 Java 개발을 할 때 프로젝트에 필요한 라이브러리 관리나 프로젝트 결과물 배포 등 프로젝트 빌드 관리를 위한 도구로는 \u003Ca class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'\u003E아파치 소프트웨어 재단\u003C/a\u003E에서 만든 Ant와 \u003Ca class='wiki-link-internal' href='/w/Maven' title='Maven'\u003EMaven\u003C/a\u003E, 그 중에서도 Maven이 많이 사용되고 있다. 최근에는 이 두 가지의 단점을 보완한 Gradle이 각광을 받고 있으나 아직 Maven보다 많이 쓰이지는 않고 있다.\u003Cbr\u003E\u003Cbr\u003E\u003Ca class='wiki-link-internal' href='/w/%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%A3%BC%EB%8F%84%20%EA%B0%9C%EB%B0%9C' title='테스트 주도 개발'\u003ETDD\u003C/a\u003E 개발을 위한 방법으로는 \u003Ca class='wiki-link-internal' href='/w/Jenkins' title='Jenkins'\u003EJenkins\u003C/a\u003E를 통한 CI 관리, SonarQube를 통한 코드 분석, \u003Ca class='wiki-link-internal' href='/w/Maven' title='Maven'\u003EMaven\u003C/a\u003E을 통한 빌드 관리, \u003Ca class='wiki-link-internal' href='/w/JaCoCo' title='JaCoCo'\u003EJaCoCo\u003C/a\u003E를 통한 Code Coverage 관리 등이 있다.\u003C/div\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-8.2' href='#toc'\u003E8.2.\u003C/a\u003E \u003Cspan id='JVM 언어'\u003E\u003Ca class='wiki-link-internal' href='/w/Java%20Virtual%20Machine' title='Java Virtual Machine'\u003EJVM\u003C/a\u003E 언어\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=44' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E이외에 Java와 똑같이 Java 바이트 코드를 생성하지만 언어 규격이 다른 \u003Ca class='wiki-link-internal' href='/w/Scala' title='Scala'\u003EScala\u003C/a\u003E와 \u003Ca class='wiki-link-internal' href='/w/Clojure' title='Clojure'\u003EClojure\u003C/a\u003E라는 언어들도 있다. \u003Ca class='wiki-link-internal' href='/w/Scala' title='Scala'\u003EScala\u003C/a\u003E는 &#39;Scalable Language&#39;에서 따왔는데, Java와 비슷한 부분이 많으며 Java API를 그대로 가져다 쓸 수도 있다. 또한, syntactic sugar가 많고 함수형 프로그래밍의 여러 가지 요소들을 가져와서 Java에 비해 생산성도 높다. 일례로 일일히 타입을 명시하지 않고 var x === 1.5와 같이 넣으면 알아서 float 형으로 추론해준다.\u003Ca class='wiki-fn-content' title='Java는 버전 10에서 와서야 이와 같은 타입 추론 기능이 가능해졌다.' href='#fn-36'\u003E\u003Cspan class='target' id='rfn-36'\u003E\u003C/span\u003E&#91;36&#93;\u003C/a\u003E 또, switch-case의 확장판이라 할 수 있는 패턴 매칭을 지원하며 클로저도 지원된다. 단점으로는 이런 고수준-고생산성의 언어에서 많이 볼 수 있듯이 같은 Java 코드에 비해 약간 느리다. \u003Ca class='wiki-link-internal' href='/w/Clojure' title='Clojure'\u003EClojure\u003C/a\u003E는 Java 플랫폼에서 동작하는 \u003Ca class='wiki-link-internal' href='/w/LISP' title='LISP'\u003ELISP\u003C/a\u003E의 방언으로 설계되었으며 Common Lisp와 Scheme과 함께 주요 LISP 방언 중 하나로 꼽힌다. 이 언어도 마찬가지로 Java API를 가져다 쓸 수 있다.\u003Cbr\u003E\u003Cbr\u003EJava 6부터 Scripting API라는 것이 추가되었다. JVM 언어 구현체에서 javax.scripting 관련 API를 제공하면 Java 코드에서 동적으로 인터프리터를 생성하고 연동하여 사용할 수 있게 해주는 표준 API이다.\u003Cbr\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch4 class='wiki-heading'\u003E\u003Ca id='s-8.2.1' href='#toc'\u003E8.2.1.\u003C/a\u003E \u003Cspan id='유명한 JVM 언어 목록'\u003E유명한 JVM 언어 목록\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=45' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h4\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E아래에 나열된 언어들이 유명하며, Common \u003Ca class='wiki-link-internal' href='/w/LISP' title='LISP'\u003ELISP\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Scheme' title='Scheme'\u003EScheme\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/Pascal' title='Pascal'\u003EPascal\u003C/a\u003E 등 여러 다양한 언어들이 구현되어 있다.\u003Cbr\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Clojure' title='Clojure'\u003EClojure\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Groovy' title='Groovy'\u003EGroovy\u003C/a\u003E: Java에 Python, Ruby, SmallTalk 등의 특징을 버무린 동적 타입 언어. 2003년에 등장했다.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJRuby: \u003Ca class='wiki-link-internal' href='/w/Ruby' title='Ruby'\u003ERuby\u003C/a\u003E의 대부분을 Java로 구현한 언어 구현체. 역시 Java와 호환된다.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJython: 파이썬의 Java 구현체. JVM 위에서 동작하며, 따라서 Python 모듈과 함께 Java 클래스, JAR 사용이 가능하다. 참고로 로고는 Java의 커피 컨셉과 Python의 뱀 컨셉을 섞어서 커피잔에서 \u003Ca class='wiki-link-internal' href='/w/%EB%B1%80' title='뱀'\u003E뱀\u003C/a\u003E이 연기처럼 피어나오는 로고다(...)\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Kotlin' title='Kotlin'\u003EKotlin\u003C/a\u003E : \u003Ca class='wiki-link-internal' href='/w/IntelliJ%20IDEA' title='IntelliJ IDEA'\u003EIntelliJ IDEA\u003C/a\u003E를 만든 \u003Ca class='wiki-link-internal' href='/w/JetBrains' title='JetBrains'\u003EJetBrains\u003C/a\u003E에서 개발한 JVM 언어. Google I/O 2017에서 \u003Ca class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'\u003E안드로이드\u003C/a\u003E의 공식 언어로 지정되었다.\u003Ca class='wiki-fn-content' title='안드로이드의 Java 라이선스 무단 사용으로 구글이 오라클과 법정 싸움을 한 여파로 보인다.' href='#fn-37'\u003E\u003Cspan class='target' id='rfn-37'\u003E\u003C/span\u003E&#91;37&#93;\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003ERhino: JVM으로 돌아가는 JavaScript 엔진으로, 모질라 재단이 100% Java로 개발했다. JavaScript와 Java의 API를 동시에 사용해 개발할 수 있다. Java 7 에 내장되어 있다.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003ENashorn: 또 다른 JVM 위에서 돌아가는 JavaScript 엔진이다. Java 8과 함께 등장했다. 참고로 Nashorn 은 Rhino(코뿔소)의 독일어다.\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/Scala' title='Scala'\u003EScala\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003C/div\u003E\u003Ch3 class='wiki-heading'\u003E\u003Ca id='s-8.3' href='#toc'\u003E8.3.\u003C/a\u003E \u003Cspan id='혼동하기 쉬운 것들'\u003E혼동하기 쉬운 것들\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=46' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h3\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003E\u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003E자바스크립트(JavaScript)\u003C/a\u003E\u003C/strong\u003E\u003Cbr\u003EJavaScript는 Java와는 \u003Cstrong\u003E아무\u003C/strong\u003E 상관도 없다. 넷스케이프사에서 Mocha, LiveScript로 개발하던 스크립트 언어를 1996년 전후 열풍이던 Java의 유명세에 묻어가기위해 Sun에서 상표권을 라이선스해 JavaScript라고 이름붙였을 뿐이다. 이름 하나 생각없이 잘못 붙여서 여러 사람을 지금도 헷갈리게 만드는 대표적인 케이스.\u003Cbr\u003E이름을 제외한 연관성은 희박한 편이여서 공통점이 아닌 차이점을 나열하는게 훨씬 빠를 정도다. 같은 C-족 언어이긴 하지만 문법조차 별로 비슷하지도 않으며\u003Ca class='wiki-fn-content' title='기초적인 C-문법의 일부인 if문, while문 등을 제외하면 공통점이 많지 않다.' href='#fn-38'\u003E\u003Cspan class='target' id='rfn-38'\u003E\u003C/span\u003E&#91;38&#93;\u003C/a\u003E, 사용되는 라이브러리나 개념 또한 많이 다르다. 기초 패러다임상 당연한 요소들을 제외하고 나면 둘의 유사점은 오직 객체지향 뿐인데 그 마저도 JavaScript는 프로토타입 베이스라 클래스를 쓰는 Java와 많이 다르다 \u003Ca class='wiki-fn-content' title='ECMAScript 6에서 Class가 생겼다! 그래도 여전히 Java의 클래스와는 겉보기에만 비슷할 뿐 열어보면 다르다. ES6에서 나온 클래스는 기존에 있던 prototype 객체지향 프로그래밍을 조금 더 쉽게 하게 해주는 문법적 설탕이다.' href='#fn-ES6'\u003E\u003Cspan class='target' id='rfn-39'\u003E\u003C/span\u003E&#91;ES6&#93;\u003C/a\u003E. 또한 Java는 정적 타입 언어인데 반해 JavaScript는 동적 타입 언어다. \u003Ca class='wiki-link-internal' href='/w/%EC%9B%B9%20%EC%84%9C%EB%B2%84' title='웹 서버'\u003E웹 서버\u003C/a\u003E용 파생 규격 역시 \u003Ca class='wiki-link-internal' href='/w/JSP' title='JSP'\u003EJSP\u003C/a\u003E와 \u003Ca class='wiki-link-internal' href='/w/Node.js' title='Node.js'\u003ENode.js\u003C/a\u003E로 다르다.\u003Cbr\u003E떠도는 말로 &#39;Java와 \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E의 차이는 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84' title='인도'\u003E인도\u003C/a\u003E와 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84%EB%84%A4%EC%8B%9C%EC%95%84' title='인도네시아'\u003E인도네시아\u003C/a\u003E의 차이와 같다&#39;라고도 한다. 왜냐하면 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84' title='인도'\u003E인도\u003C/a\u003E와 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84%EB%84%A4%EC%8B%9C%EC%95%84' title='인도네시아'\u003E인도네시아\u003C/a\u003E가 이름만 비슷하고 서로 다른 국가이듯이\u003Ca class='wiki-fn-content' title='다만 인도네시아의 어원은 인도와 관련이 있다. 인도네시아라는 이름은 &#39;인도양의 섬&#39;들이라는 그리스어·라틴어식 표현이기 때문. 이런 인도네시아와 인도의 관계는, JavaScript가 Java와 별 관련은 없어도 그 이름을 빌려 왔다는 점에서 왠지 흡사하다.' href='#fn-40'\u003E\u003Cspan class='target' id='rfn-40'\u003E\u003C/span\u003E&#91;40&#93;\u003C/a\u003E Java와 \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E도 다른 프로그래밍 언어이기 때문이다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cstrong\u003EVisual J++/Visual J#\u003C/strong\u003E\u003Cbr\u003EVisual J++은 \u003Ca class='wiki-link-internal' href='/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8' title='마이크로소프트'\u003E마이크로소프트\u003C/a\u003E에서 Java를 변형하여 윈도우 전용으로 만든 언어. 위의 JavaScript는 이름만 바꿨지만 이건 Java 자체를 윈도우에 맞도록 변형한 것이다. 이 때문에 Java 가상머신 없이 윈도우에서 네이티브로 돌아가지만, 다른 플랫폼에서는 전혀 돌아가지 않는다. 거기다 썬 마이크로시스템즈의 허락없이 마구 변형해서 썼기 때문에 소송크리를 먹고 개발이 \u003Ca class='wiki-link-internal' href='/w/%EB%A7%9D%ED%96%88%EC%96%B4%EC%9A%94' title='망했어요'\u003E중단되었다\u003C/a\u003E.\u003Cbr\u003E이후 윈도우의 프로그램이 \u003Ca class='wiki-link-internal' href='/w/.NET%20Framework' title='.NET Framework'\u003E닷넷\u003C/a\u003E으로 넘어가면서 닷넷 기반의 Visual J#도 만들었다. Visual Studio 2005에 포함되었지만 이것도 개발이 중단되었다. 이때는 썬이 소송하지도 않았는데 중단된 것을 보면 시장성이 없었던 듯 하다. 이미 이 때는 C#이 어느 정도 자리를 잡았기 때문일 수도 있고.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-9' href='#toc'\u003E9.\u003C/a\u003E \u003Cspan id='구글 vs. 오라클: Java 저작권 분쟁'\u003E구글 vs. 오라클: Java 저작권 분쟁\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=47' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003EJava를 처음 개발한 \u003Ca class='wiki-link-internal' href='/w/%EC%8D%AC%20%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%A6%88' title='썬 마이크로시스템즈'\u003E썬 마이크로시스템즈\u003C/a\u003E는 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'\u003E오라클\u003C/a\u003E에게 인수되었고, 2010년에 오라클은 \u003Ca class='wiki-link-internal' href='/w/%EA%B5%AC%EA%B8%80' title='구글'\u003E구글\u003C/a\u003E이 \u003Ca class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'\u003E안드로이드\u003C/a\u003E를 개발하면서 Java \u003Ca class='wiki-link-internal' href='/w/API' title='API'\u003EAPI\u003C/a\u003E 37개의 소스 코드를 무단 복제하여 사용했다는 이유로 소송을 제기했다. 오라클은 구글이 Java를 이용해 OS를 개발하려는 상업적 목적을 가지고 있었으므로 사전에 허가를 받았어야 했다는 주장이고, 구글은 Java API가 저작권자의 허락 없이 이용할 수 있는 공정 이용(Fair Use)의 대상이라며 맞섰다. 그리고 2018년, 장시간에 걸친 소송전은 오라클의 승리로 결론났다. \u003Ca class='wiki-link-external' href='http://www.zdnet.co.kr/news/news_view.asp?artice_id=20180328141031' target='_blank' rel='nofollow noopener' title='http://www.zdnet.co.kr/news/news_view.asp?artice_id=20180328141031'\u003E#\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E재판의 흐름을 정리하자면 이렇다. 2012년에 이루어진 &#39;저작권 침해&#39;에 관한 재판 1심에서는 구글이 승소하였고, 2014년 항소심에서는 오라클이 승소하였으며 2015년에는 구글의 상고가 기각되었다. 이후 2016년 &#39;공정 이용&#39;에 관한 재판 1심에서는 구글 측의 주장이 받아들여지며 구글이 승소했지만, 결국 2018년 항소심에서 다시 오라클이 승소하게 된 것이다. \u003Ca class='wiki-link-external' href='http://news.joins.com/article/22482858' target='_blank' rel='nofollow noopener' title='http://news.joins.com/article/22482858'\u003E#\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E항소심 재판부의 결론은 Java API 역시 저작권이 존재하는 엄연한 저작물이라는 것이다. 재판부는 구글이 Java API를 수정 없이 그대로 긁어다가 안드로이드를 만들어 모바일 OS 시장을 점령하였으며, 단순히 어떤 애플리케이션을 개발한 게 아닌 별도의 운영체제와 플랫폼을 무기로 향후 오라클이 Java를 이용하여 모바일 시장에 진출할 가능성을 꺾어버렸기 때문에 Java의 무단 이용은 불공정한 행위라고 판결했다. 현재 구글이 오라클에게 배상해야 할 금액은 약 90억 달러에 달할 것으로 예상되고 있다.\u003Cbr\u003E\u003Cbr\u003E이 판결이 가져다 줄 여파에 대해 안드로이드 생태계가 큰 위기를 맞이했다는 시각이 있지만, 사실 소송기간 동안 안드로이드는 이미 모바일 OS 시장을 \u003Ca class='wiki-link-internal' href='/w/iOS' title='iOS'\u003EiOS\u003C/a\u003E와 함께 5:5로 양분하고 있을 만큼 거대하게 성장했기 때문에 이번 일로 안드로이드가 휘청거릴 일은 단연코 없다. 90억 달러가 작은 돈은 아니지만, 구글은 한창 성장하던 시절인 2006년에 이미 \u003Ca class='wiki-link-internal' href='/w/%EC%9C%A0%ED%8A%9C%EB%B8%8C' title='유튜브'\u003E유튜브\u003C/a\u003E 인수금액으로 16억 5,000만 달러를 한번에 지불해낼 정도였고, 2007년에는 광고 회사인 더블클릭을 31억 달러에 샀을 정도로 현금 창출력이 상당한 기업이다. 그리고 안드로이드는 직접적인 로열티 수입은 없지만 구글 검색과 광고, 구글 플레이와 유튜브 같은 구글 앱에서 나오는 수익만 해도 매년 수백억 달러에 달한다는 평가를 받고 있는데, 모바일 OS 시장 양분 댓가로 90억 달러를 낸다면 구글 입장에선 거저 먹는 것이나 다름없다.\u003Cbr\u003E\u003Cbr\u003E일단 구글은 연방대법원에 상고할 것이라는 의사를 밝혔다. \u003Ca class='wiki-link-external' href='https://news.v.daum.net/v/20180829100830547' target='_blank' rel='nofollow noopener' title='https://news.v.daum.net/v/20180829100830547'\u003E#\u003C/a\u003E 다만 실제로 상고를 신청할지, 신청하더라도 대법원에서 그걸 받아들일지는 나중 문제이다.\u003Cbr\u003E\u003Cbr\u003E구글이 대법원에 오라클의 승소에 대해 다시 검토해줄 것을 요청했고 이와 관련한 첫번째 심리가 오는 2020년 3월 열릴 예정이라고 한다. 최종 판결은 이르면 6월께 나올 것이라고 한다. \u003Ca class='wiki-link-external' href='https://n.news.naver.com/article/293/0000026250' target='_blank' rel='nofollow noopener' title='https://n.news.naver.com/article/293/0000026250'\u003E#\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E하지만 2020년을 강타한 \u003Ca class='wiki-link-internal' href='/w/COVID-19' title='COVID-19'\u003ECOVID-19\u003C/a\u003E의 여파로 2020년도에 예정된 재판들이 줄줄이 2021년도로 연기되면서 첫 변론도 3월에서 9월로 밀렸다.\u003Ca class='wiki-link-external' href='https://www.scotusblog.com/2020/03/justices-postpone-march-argument-session/' target='_blank' rel='nofollow noopener' title='https://www.scotusblog.com/2020/03/justices-postpone-march-argument-session/'\u003E#\u003C/a\u003E\u003Ca class='wiki-link-external' href='https://www.scotusblog.com/case-files/cases/google-llc-v-oracle-america-inc/' target='_blank' rel='nofollow noopener' title='https://www.scotusblog.com/case-files/cases/google-llc-v-oracle-america-inc/'\u003E#\u003C/a\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-10' href='#toc'\u003E10.\u003C/a\u003E \u003Cspan id='점유율'\u003E점유율\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=48' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E세계 \u003Ca class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'\u003E프로그래밍 언어\u003C/a\u003E 중에서 점유율 1위를 \u003Ca class='wiki-link-internal' href='/w/2000%EB%85%84' title='2000년'\u003E2000년\u003C/a\u003E부터 무려 19년 째 1위를 질주중인 \u003Cstrong\u003E\u003Ca class='wiki-link-internal' href='/w/%EB%8F%85%EC%9E%AC%EC%9E%90' title='독재자'\u003E독재자\u003C/a\u003E\u003C/strong\u003E(...)이다. \u003Ca class='wiki-link-internal' href='/w/2007%EB%85%84' title='2007년'\u003E2007년\u003C/a\u003E까지만 해도 전 세계 프로그래밍 언어 점유율 중에 Java 점유율이 \u003Cstrong\u003E35%\u003C/strong\u003E까지도 차지했다. 그러나 \u003Ca class='wiki-link-internal' href='/w/2010%EB%85%84%EB%8C%80' title='2010년대'\u003E2010년대\u003C/a\u003E 들어서 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E 등의 점유율이 급상승하면서 Java의 점유율은 점차 하락하는 추세이다. 1위는 수성하고 있지만 점유율은 급격하게 떨어지고 있다. \u003Ca class='wiki-link-internal' href='/w/2019%EB%85%84' title='2019년'\u003E2019년\u003C/a\u003E 지금은 \u003Ca class='wiki-link-internal' href='/w/C%EC%96%B8%EC%96%B4' title='C언어'\u003EC언어\u003C/a\u003E보다 약간 더 많은 수준으로 17~18% 정도를 차지하고 있다. Java 점유율이 하락한 만큼 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E 비율이 크게 올랐다.\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-11' href='#toc'\u003E11.\u003C/a\u003E \u003Cspan id='불투명한 미래?'\u003E불투명한 미래?\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=49' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E이러한 분쟁과는 별도로, \u003Cstrong\u003E오라클이 Java를 포기하려고 한다\u003C/strong\u003E는 주장이 있다. \u003Ca class='wiki-link-external' href='http://news.softpedia.com/news/oracle-mysteriously-fires-almost-all-of-its-top-java-evangelists-491355.shtml' target='_blank' rel='nofollow noopener' title='http://news.softpedia.com/news/oracle-mysteriously-fires-almost-all-of-its-top-java-evangelists-491355.shtml'\u003E&quot;Oracle Mysteriously Fires Almost All of Its Top Java Evangelists&quot;(Softpedia News)\u003C/a\u003E \u003Ca class='wiki-link-external' href='http://m.zdnet.co.kr/news_view.asp?article_id=20160316170411' target='_blank' rel='nofollow noopener' title='http://m.zdnet.co.kr/news_view.asp?article_id=20160316170411'\u003E자바 에반젤리스트, 오라클 퇴사의 변 &quot;자바 구하려&quot;(ZDNet Korea)\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E자바 에반젤리스트는 Java의 전체적인 업계 내에서의 분위기를 결정지을 수 있는, 비교하자면 \u003Ca class='wiki-link-internal' href='/w/%EB%A6%AC%EB%88%85%EC%8A%A4' title='리눅스'\u003E리눅스\u003C/a\u003E계의 \u003Ca class='wiki-link-internal' href='/w/%EB%A6%AC%EB%88%84%EC%8A%A4%20%ED%86%A0%EB%A5%B4%EB%B0%9C%EC%8A%A4' title='리누스 토르발스'\u003E리누스 토르발스\u003C/a\u003E 같은 사람들인데, \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'\u003E오라클\u003C/a\u003E이 이 사람들을 꾸준히 해고하고 있다는 것이다. 장사를 독하게 하기로 유명한 오라클인지라, Java 자체가 지금은 물론이고 미래에도 그다지 수익성이 좋다고 할 수 없기에 망설임 없이 포기하려는 것이 아니냐라는 관측이 있다.  \u003Ca class='wiki-link-external' href='https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fjames.gosling.96%2Fposts%2F10154181433121328' target='_blank' rel='nofollow noopener' title='https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fjames.gosling.96%2Fposts%2F10154181433121328'\u003E제임스 고슬링도 한마디 했다.\u003C/a\u003E\u003Cbr\u003E\u003Cbr\u003E다만 이 부분은 사람에 따라 극단적으로 반응할 수도 있는 문제이므로\u003Ca class='wiki-fn-content' title='각 언어 프로그래머들의 자신의 언어에 대한 자부심은 가히 종교의 신앙과 비견할 만한 것이다.' href='#fn-41'\u003E\u003Cspan class='target' id='rfn-41'\u003E\u003C/span\u003E&#91;41&#93;\u003C/a\u003E 업계 분위기에 대한 판단은 스스로 하도록 하자. 위에서도 언급했지만 Oracle JDK를 유료로 전환한 걸 보면 포기할 생각은 없는 듯하다.\u003Cbr\u003E\u003Cbr\u003E2017년 8월 17일, 오라클이 Java EE를 포기한다고 발표했다. \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%EC%98%A4%ED%94%BC%EC%8A%A4' title='오픈오피스'\u003E오픈오피스\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/%EB%84%B7%EB%B9%88%EC%A6%88' title='넷빈즈'\u003E넷빈즈\u003C/a\u003E 때와 같이 \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%ED%94%88%20%EC%86%8C%EC%8A%A4' title='오픈 소스'\u003E오픈 소스\u003C/a\u003E 생태계로 보내려 하고 있으며, \u003Ca class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'\u003E아파치 소프트웨어 재단\u003C/a\u003E과 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'\u003E이클립스\u003C/a\u003E 재단이 Java EE를 넘겨받을 유력한 후보로 알려져 있다. \u003Ca class='wiki-link-external' href='https://blogs.oracle.com/theaquarium/opening-up-java-ee' target='_blank' rel='nofollow noopener' title='https://blogs.oracle.com/theaquarium/opening-up-java-ee'\u003EOpening Up Java EE\u003C/a\u003E 결국 이클립스 재단이 맡는 것으로 확정되었으며, Java EE의 오픈 소스화를 위한 9개 프로젝트를 추진한다고 밝혔다. \u003Ca class='wiki-link-external' href='http://www.ciokorea.com/news/35563' target='_blank' rel='nofollow noopener' title='http://www.ciokorea.com/news/35563'\u003E#\u003C/a\u003E\u003Ca class='wiki-link-external' href='http://www.ciokorea.com/news/36380' target='_blank' rel='nofollow noopener' title='http://www.ciokorea.com/news/36380'\u003E#\u003C/a\u003E 다만 오라클이 Java EE라는 상표권까지 넘긴 것은 아니기 때문에, 새로운 이름을 공모하였고 이후 \u003Cstrong\u003E자카르타 EE(Jakarta EE)\u003C/strong\u003E라는 새 명칭이 결정되었다. \u003Ca class='wiki-link-external' href='http://www.itworld.co.kr/news/108348' target='_blank' rel='nofollow noopener' title='http://www.itworld.co.kr/news/108348'\u003E엔터프라이즈 자바의 새 이름 ‘자카르타 EE&#39;\u003C/a\u003E\u003Ca class='wiki-fn-content' title='원래 아파치 소프트웨어 재단이 &#39;자카르타&#39;라는 이름의 Java 오픈 소스 프로젝트(현재는 종료)를 소유하고 있었으나, 해당 명칭을 사용해도 된다고 허가하였다.' href='#fn-42'\u003E\u003Cspan class='target' id='rfn-42'\u003E\u003C/span\u003E&#91;42&#93;\u003C/a\u003E\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-12' href='#toc'\u003E12.\u003C/a\u003E \u003Cspan id='도서'\u003E도서\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=50' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EC%84%9C%EC%A0%90' title='서점'\u003E서점\u003C/a\u003E에 가면 Java \u003Ca class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D' title='프로그래밍'\u003E프로그래밍\u003C/a\u003E 책이 무궁무진하게 많다. \u003Cu\u003EPython, Java, C, SQL 4개는 \u003Ca class='wiki-link-internal' href='/w/%EC%84%9C%EC%A0%90' title='서점'\u003E서점\u003C/a\u003E에 가면 \u003Ca class='wiki-link-internal' href='/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EC%96%B8%EC%96%B4' title='프로그래밍 언어'\u003E프로그래밍 언어\u003C/a\u003E 분야에 별도의 카테고리를 차지\u003C/u\u003E하고 있다.\u003C/div\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-13' href='#toc'\u003E13.\u003C/a\u003E \u003Cspan id='여담'\u003E여담\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=51' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJava의 창시자인 \u003Ca class='wiki-link-internal' href='/w/%EC%A0%9C%EC%9E%84%EC%8A%A4%20%EA%B3%A0%EC%8A%AC%EB%A7%81' title='제임스 고슬링'\u003E제임스 고슬링\u003C/a\u003E 옹은 진성 \u003Ca class='wiki-link-internal' href='/w/%EC%95%B1%EB%93%B1%EC%9D%B4' title='앱등이'\u003E앱등이\u003C/a\u003E다.\u003Ca class='wiki-fn-content' title='Java가 안드로이드의 기반이 되는 언어라는 점을 생각하면 아이러니...' href='#fn-43'\u003E\u003Cspan class='target' id='rfn-43'\u003E\u003C/span\u003E&#91;43&#93;\u003C/a\u003E 집에서 쓰는 IT 기기에 대해 묻는 질문에 폰, 태블릿, 데스크탑, 랩탑 등 거의 모든 IT 기기를 애플사 제품으로 도배해놨음이 밝혀졌다. 가족들도 마찬가지. 정작 \u003Ca class='wiki-link-internal' href='/w/Apple' title='Apple'\u003E애플\u003C/a\u003E은 OS X 레오파드 업데이트 때 Java를 찬밥 취급했지만...\u003Ca class='wiki-fn-content' title='사실 애플은 독자적인 JDK를 제공하는지라 Java 개발자들을 매우 피곤하게 하는 회사이기도 하다.' href='#fn-44'\u003E\u003Cspan class='target' id='rfn-44'\u003E\u003C/span\u003E&#91;44&#93;\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E제임스 고슬링과 Java를 창시할 때 같이 일했던 패트릭 노튼은 1999년 \u003Ca class='wiki-link-internal' href='/w/FBI' title='FBI'\u003EFBI\u003C/a\u003E의 \u003Ca class='wiki-link-internal' href='/w/%EC%95%84%EB%8F%99%ED%8F%AC%EB%A5%B4%EB%85%B8' title='아동포르노'\u003E아동포르노\u003C/a\u003E 함정수사로 인해 체포되었다.\u003Ca class='wiki-fn-content' title='단지 징역을 살지는 않고 FBI에서 1년 근무하는 것으로 퉁쳤다.' href='#fn-45'\u003E\u003Cspan class='target' id='rfn-45'\u003E\u003C/span\u003E&#91;45&#93;\u003C/a\u003E 덤으로 IT 관계자들은 노튼이 \u003Ca class='wiki-link-internal' href='/w/%ED%8F%AC%EB%A5%B4%EB%85%B8' title='포르노'\u003E기업 방화벽을 통과할 수 있는 통신도구를 만드는 일에 관심을 보인 이유\u003C/a\u003E를 일찌감치 짐작했었다고...\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E조엘온 블로그로 유명한 조엘이 엄청나게 싫어하는 언어. 조엘 스폴스키가 Java를 싫어하는 이유로는 성능상의 문제나 문법상 너무 쉽다(...)\u003Ca class='wiki-fn-content' title='이 부분은 대학의 교육용 언어로서의 이야기다. 산업용으로서는 같은 기능을 개발하기 위한 언어는 쉬우면 쉬울수록 좋은 것이 당연하다. 물론 성능과 생산성 사이에서 적절한 균형을 잡아야 하겠지만.' href='#fn-46'\u003E\u003Cspan class='target' id='rfn-46'\u003E\u003C/span\u003E&#91;46&#93;\u003C/a\u003E는 이유도 있지만, Java 자체가 &quot;위원회 기술&quot;이라는 이유도 큰 몫을 차지한다.\u003Ca class='wiki-fn-content' title='Java 상임 위원회에는 인텔, 오라클, JetBrains, 레드햇, ARM Holdings 등이 속해 있다. 모두 각자의 분야에서 내로라하는 기업들이다.' href='#fn-47'\u003E\u003Cspan class='target' id='rfn-47'\u003E\u003C/span\u003E&#91;47&#93;\u003C/a\u003E 사실 이는 Java가 가진 태생적 문제인데 Java라는 언어가 \u003Ca class='wiki-link-internal' href='/w/C%23' title='C#'\u003EC#\u003C/a\u003E처럼 어느 특정 단체나 회사가 주도적으로 끌고가는 물건이 아니다 보니 위원회를 구성하는 각 기업들의 파워게임에 따라 중요한 문제의 해결방안이 빨리 처리되지 않는 경우도 있고 배가 산으로 가는 경우도 있다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJava를 설치하고 환경변수를 설정할 때 CLASSPATH의 디렉토리를 보통 %JAVA_HOME%\\lib로 설정하는데, 이렇게 하면 파일 실행 시 JVM이 무조건 \\lib 경로에서 클래스 파일을 찾기 때문에 해당 파일을 찾거나 로드할 수 없다는 오류 메시지를 뿜게 된다. 매번 실행할 때마다 -classpath . 옵션을 주거나 CLASSPATH 환경변수의 디렉토리 끝에 ;.을 붙이면 해결할 수 있다.\u003Ca class='wiki-fn-content' title='&#39;.&#39;은 Java 클래스 파일이 위치한 해당 디렉토리를 의미한다.' href='#fn-48'\u003E\u003Cspan class='target' id='rfn-48'\u003E\u003C/span\u003E&#91;48&#93;\u003C/a\u003E 물론 대부분의 IDE는 클래스 패스 설정을 자동으로 처리해 주지만, 역으로 그렇기에 클래스 패스에 대한 이해를 제대로 하지 않고 넘어가 버리는 경우가 많다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJava에서 UI를 만들 때도 고려를 해야할 게, Java는 UI를 만들 때 AWT나 Swing 둘 중 하나 혹은 둘 다 선택하여 UI를 만드는 게 가능하다. 조심해야 할 점은, AWT로 생성한 UI는 Swing UI에 가려져버린다. 그래서 멀쩡히 잘 돌아가는 코드인데도 불구하고 배경이 컨트롤(콤보박스라거나)을 가려버리는 일이 있을 수 있다. \u003Cdel\u003E어차피 요즘은 둘 다 안 쓴다\u003C/del\u003E 참고로 JetBrains의 \u003Ca class='wiki-link-internal' href='/w/%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD' title='통합 개발 환경'\u003EIDE\u003C/a\u003E 제품들은 이 Swing UI를 거의 마개조에 가깝게 뜯어고쳐서 쓰고 있다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003EJava 클래스 바이트코드 매직넘버가 \u003Ccode\u003E#xca 0xFE 0xBA 0xBE\u003C/code\u003E다. 이것을 붙이면 CAFEBABE다. CAFEBABE인 이유는, 제임스 고슬링과 다른 연구원들이 St. Michael&#39;s Alley라는 곳에 \u003Ca class='wiki-link-internal' href='/w/%EC%A0%90%EC%8B%AC' title='점심'\u003E점심\u003C/a\u003E을 먹으러 가곤 했다고 한다. 그 지방 전설에 의하면 그곳에서 \u003Ca class='wiki-link-internal' href='/w/%EB%8D%94%20%EA%B7%B8%EB%A0%88%EC%9D%B4%ED%8A%B8%ED%92%80%20%EB%8D%B0%EB%93%9C' title='더 그레이트풀 데드'\u003E더 그레이트풀 데드\u003C/a\u003E라는 \u003Ca class='wiki-link-internal' href='/w/%EB%B0%B4%EB%93%9C' title='밴드'\u003E밴드\u003C/a\u003E가 크게 성장하기 전에 연주하던 곳이라고 했다. 그리고 제임스 고슬링과 연구원들은 그곳을 Cafe Dead라고 불렀다. 그러다 CAFE DEAD가 헥스 넘버인 것을 알아냈다고 한다.\u003Ca class='wiki-fn-content' title='CAFEDEAD를 0xCA 0xFE 0xDE 0xAD로 바꿨을 때의 얘기인 듯하다.' href='#fn-49'\u003E\u003Cspan class='target' id='rfn-49'\u003E\u003C/span\u003E&#91;49&#93;\u003C/a\u003E 그 때 마침 그는 파일 포맷 소스와 매직넘버를 개편하고 있었다.\u003Ca class='wiki-fn-content' title='그때 필요한 매직넘버는 2개였다. 하나는 오브젝트 파일이고, 또 다른 하나는 클래스 파일 매직넘버였다.' href='#fn-50'\u003E\u003Cspan class='target' id='rfn-50'\u003E\u003C/span\u003E&#91;50&#93;\u003C/a\u003E 결국 Object 파일의 매직 넘버는 CAFEDEAD가 되었다. 나머지 하나, 클래스 파일의 매직넘버는 CAFE 다음에 맞을 만한 번호를 정하는 것인데, 그 때 적은 것이 BABE다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E2012년 말에는 Java에 보안 취약점이 발견되어 오라클에서 긴급 보안 패치를 발표했지만 또 다른 취약점이 발견돼버리는 바람에 Java를 계속 써야 하나 말아야 하는 논쟁이 벌어지기도 했다. 지금은 잠잠해진 상태.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E기존의 32bit용은 64bit 웹 브라우저에 사용할 수 없기에 64bit용 Java가 공개되어 있다. 그러나 32bit 웹 브라우저와 64bit 웹 브라우저를 각각 돌아가며 사용해야 할 필요가 있을 경우 둘 다 설치해야 제대로 돌아가기 때문에 번거로운 편이다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E2018년 초부터 자바 설치파일로 위장한 \u003Ca class='wiki-link-internal' href='/w/%EB%9E%9C%EC%84%AC%EC%9B%A8%EC%96%B4' title='랜섬웨어'\u003E랜섬웨어\u003C/a\u003E가 기승을 부리고 있다. 어느날 갑자기 직접 설치파일을 다운받거나 하지도 않았는데 설치파일이 저절로 실행되며, 대부분의 감염자들은 이를 자동 업데이트로 인지하고 그대로 업데이트 해버려서 감염된다고 한다. 심지어 사용하는 운영체제의 언어를 인지하여 해당 언어의 자바 설치파일에 있는 문장과 이미지까지 철저하게 재현되어서 의심할 여지가 없다고 한다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003C/div\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EB%A7%88%EC%9D%B8%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8' title='마인크래프트'\u003E마인크래프트\u003C/a\u003E는 원래 Java로 개발되었는데, 속도 문제 때문인지 \u003Ca class='wiki-link-internal' href='/w/%EB%A7%88%EC%9D%B8%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8/%EB%B2%A0%EB%93%9C%EB%9D%BD%20%EC%97%90%EB%94%94%EC%85%98' title='마인크래프트/베드락 에디션'\u003E게임을 통째로 C++로 다시 짰다.\u003C/a\u003E 그리고 실제로 속도가 10배 가까이 빨라졌다. 다만 기존의 Java 에디션으로 개발된 애드온들이 워낙 많고, 그것들이 베드락 에디션과 호환이 안 돼서 여전히 Java 에디션을 사용하는 유저들이 많다.\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003C/div\u003E\u003Ch2 class='wiki-heading'\u003E\u003Ca id='s-14' href='#toc'\u003E14.\u003C/a\u003E \u003Cspan id='관련 문서'\u003E관련 문서\u003Cspan class='wiki-edit-section'\u003E\u003Ca href='/edit/Java?section=52' rel='nofollow'\u003E&#91;편집&#93;\u003C/a\u003E\u003C/span\u003E\u003C/span\u003E\u003C/h2\u003E\u003Cdiv class='wiki-heading-content'\u003E\u003Cul class='wiki-list'\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/OCJP' title='OCJP'\u003EOCJP\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%91%9C%EC%A4%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC' title='전자정부표준프레임워크'\u003E전자정부표준프레임워크\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D' title='객체 지향 프로그래밍'\u003E객체 지향 프로그래밍\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/IntelliJ%20IDEA' title='IntelliJ IDEA'\u003EIntelliJ IDEA\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003Cli\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Ca class='wiki-link-internal' href='/w/%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4(%ED%86%B5%ED%95%A9%20%EA%B0%9C%EB%B0%9C%20%ED%99%98%EA%B2%BD)' title='이클립스(통합 개발 환경)'\u003E이클립스(통합 개발 환경)\u003C/a\u003E\u003C/div\u003E\u003C/li\u003E\u003C/ul\u003E\u003Cdiv class='wiki-paragraph'\u003E\u003Cbr\u003E\u003C/div\u003E\u003C/div\u003E\u003Cdiv class='wiki-macro-footnote'\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-1'\u003E\u003C/span\u003E\u003Ca href='#rfn-1'\u003E&#91;1&#93;\u003C/a\u003E 당장 저기서 package문을 using문으로 System.out.println를 Console.WriteLine으로 바꾸기만 해도 완벽한 \u003Ca class='wiki-link-internal' href='/w/C%23' title='C#'\u003EC#\u003C/a\u003E 코드가 된다.(...)\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-2'\u003E\u003C/span\u003E\u003Ca href='#rfn-2'\u003E&#91;2&#93;\u003C/a\u003E 그도 그럴 것이, 원래 C#이 \u003Ca class='wiki-link-internal' href='/w/MS' title='MS'\u003EMS\u003C/a\u003E에서 Java의 기본적인 성질은 가져가지만, 각종 문제들을 해결한 언어이기 때문이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-3'\u003E\u003C/span\u003E\u003Ca href='#rfn-3'\u003E&#91;3&#93;\u003C/a\u003E \u003Ca class='wiki-link-internal' href='/w/%EC%9D%BC%EB%B0%98%EB%AA%85%EC%82%AC' title='일반명사'\u003E일반명사\u003C/a\u003E나 이미 널리 알려진 표현 등은 상표로 등록 못한다. 물론 상표 등록을 못해도 제품이나 서비스 이름으로 못 쓰는 건 아니지만 해당 이름에 대해 배타적·독점적 권리를 확보하지 못한 상태가 돼서, 남들이 따라 해도 거기에 법적으로 태클을 걸 수가 없다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-4'\u003E\u003C/span\u003E\u003Ca href='#rfn-4'\u003E&#91;4&#93;\u003C/a\u003E Premier Support. 오라클에 비용을 내고 기술 지원을 받는 서비스이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-5'\u003E\u003C/span\u003E\u003Ca href='#rfn-5'\u003E&#91;5&#93;\u003C/a\u003E Extended Support. 일반 지원이 종료된 후 추가적인 비용을 지불하여 기술 지원을 더 받을 수 있는 기간이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-6'\u003E\u003C/span\u003E\u003Ca href='#rfn-6'\u003E&#91;6&#93;\u003C/a\u003E \u003Ca class='wiki-link-internal' href='/w/GCC' title='GCC'\u003EGCC\u003C/a\u003E 계열 Java 컴파일러인 GCJ에서는 이미 지원하고 있던 기능이다.(현재는 출시 중단)\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-7'\u003E\u003C/span\u003E\u003Ca href='#rfn-7'\u003E&#91;7&#93;\u003C/a\u003E \u003Ca class='wiki-link-internal' href='/w/C%23' title='C#'\u003EC#\u003C/a\u003E의 var와 똑같은 기능이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-8'\u003E\u003C/span\u003E\u003Ca href='#rfn-8'\u003E&#91;8&#93;\u003C/a\u003E 따라서 이전 버전과 호환이 안 될 가능성도 있다. 이전 버전에서는 그냥 내부 메소드 쓰듯이 JavaFX를 갖다 썼다면, 이제는 라이브러리를 따로 인클루드해서 배포해야 하기 때문.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-9'\u003E\u003C/span\u003E\u003Ca href='#rfn-9'\u003E&#91;9&#93;\u003C/a\u003E &#39;@Nonnull var x, @Nullable var y&#39;를 &#39;x.process(y)&#39;로 간략화할 수 있게 되었다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-10'\u003E\u003C/span\u003E\u003Ca href='#rfn-10'\u003E&#91;10&#93;\u003C/a\u003E 리눅스 커널, 하드웨어 프로그래밍\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-11'\u003E\u003C/span\u003E\u003Ca href='#rfn-11'\u003E&#91;11&#93;\u003C/a\u003E 3D 게임, 그래픽 프로그래밍\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-12'\u003E\u003C/span\u003E\u003Ca href='#rfn-12'\u003E&#91;12&#93;\u003C/a\u003E 특히 웹 개발 분야에서 해외의 경우 Java는 도태되는 추세고, \u003Ca class='wiki-link-internal' href='/w/Node.js' title='Node.js'\u003ENode.js\u003C/a\u003E 덕분에 서버와 프론트엔드 양 쪽에서 쓸 수 있는 \u003Ca class='wiki-link-internal' href='/w/JavaScript' title='JavaScript'\u003EJavaScript\u003C/a\u003E와 \u003Ca class='wiki-link-internal' href='/w/Django' title='Django'\u003EDjango\u003C/a\u003E를 통하여 쉽고 빠르게 백엔드 구축이 가능한 \u003Ca class='wiki-link-internal' href='/w/Python' title='Python'\u003EPython\u003C/a\u003E의 사용률이 늘어나고 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-13'\u003E\u003C/span\u003E\u003Ca href='#rfn-13'\u003E&#91;13&#93;\u003C/a\u003E JVM 위에서 구동 가능한 언어에 대해서는 영문 위키피디아의 \u003Ca class='wiki-link-external' href='https://en.wikipedia.org/wiki/List_of_JVM_languages' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/List_of_JVM_languages'\u003EList of JVM languages\u003C/a\u003E 참고.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-14'\u003E\u003C/span\u003E\u003Ca href='#rfn-14'\u003E&#91;14&#93;\u003C/a\u003E 정말로 포인터를 써야 할 경우 Unsafe 클래스를 쓰면 된다. 다만 팩토리 메소드가 막혀있어 리플렉션을 사용해야만 이용할 수 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-15'\u003E\u003C/span\u003E\u003Ca href='#rfn-15'\u003E&#91;15&#93;\u003C/a\u003E 어차피 Java에서는 다중 상속을 포기함으로써 생기는 문제를 interface를 다중 구현할 수 있도록 하여 어느 정도 해결하기도 했다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-16'\u003E\u003C/span\u003E\u003Ca href='#rfn-16'\u003E&#91;16&#93;\u003C/a\u003E 쉽게 생각하면 배열 1000개를 할당받기 위해 운영체제에 1번 호출하여 한꺼번에 할당받지 않고, 1000번 호출하여 각각 할당받는 것이다. 기본적으로, 동적 메모리 할당은 운영체제에서 처리하기 때문에 속도가 느리다. 어떤 언어에서라도, 운영체제의 메모리 할당 횟수를 줄이는 것이 성능에 도움이 된다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-17'\u003E\u003C/span\u003E\u003Ca href='#rfn-17'\u003E&#91;17&#93;\u003C/a\u003E 하지만 연산자 오버로딩은 분명 제네릭 프로그래밍에 도움을 준다. 가령 제네릭 클래스 내에서 주어진 타입의 변수 두 개를 더하는 연산을 하고 싶다면? 더하는 연산 등 여러 일반적인 작업들은 Java의 primitive 타입에만 필요한 것은 아니다. 행렬 등이 그런 대표적인 예다. 이러한 측면에서 본다면 프로그래머의 작업에 있어서의 일관성은 훼손됐다고 볼 수도 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-18'\u003E\u003C/span\u003E\u003Ca href='#rfn-18'\u003E&#91;18&#93;\u003C/a\u003E 다만 제네릭은 Type Erasure를 사용하기 때문에 개념적으로 C++의 템플릿과 다르며, 할 수 있는 일도 거의 일반화 프로그래밍 자체로만 한정돼 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-19'\u003E\u003C/span\u003E\u003Ca href='#rfn-19'\u003E&#91;19&#93;\u003C/a\u003E 기존에 앞 문단 서술에 사용되었던 용어인 &quot;\u003Ca class='wiki-link-internal' href='/w/C%2B%2B#s-4.1' title='C++'\u003E템플릿 메타 프로그래밍\u003C/a\u003E&quot;은 개념을 오해하여 사용한 것이므로 &quot;\u003Ca class='wiki-link-internal' href='/w/C%2B%2B#s-4' title='C++'\u003E일반화 프로그래밍\u003C/a\u003E&quot;으로 대체하였다. 일반화 프로그래밍(\u003Ca class='wiki-link-external' href='https://en.wikipedia.org/wiki/Generic_programming' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/Generic_programming'\u003EGeneric Programming\u003C/a\u003E)은 Java나 C#에도 &quot;제네릭&quot;이라는 형태로 구현되어 있다. 그러나 템플릿 메타 프로그래밍(\u003Ca class='wiki-link-external' href='https://en.wikipedia.org/wiki/Template_metaprogramming' target='_blank' rel='nofollow noopener' title='https://en.wikipedia.org/wiki/Template_metaprogramming'\u003ETemplate Meta-Programming\u003C/a\u003E)은 Java나 C#에서 전혀 구현되지 않는 별도의 개념이다. 아마도 C++에서 쓰는 &quot;\u003Ca class='wiki-link-internal' href='/w/%ED%85%9C%ED%94%8C%EB%A6%BF#s-6' title='템플릿'\u003E템플릿\u003C/a\u003E&quot;이라는 용어와 Java의 &quot;제네릭&quot;이라는 용어가 같은 것을 지칭한다고 착각해서 나온 결과로 추정된다. C++ 템플릿 프로그래밍 = &quot;\u003Ca class='wiki-link-internal' href='/w/C%2B%2B#s-4' title='C++'\u003E일반화 프로그래밍\u003C/a\u003E + \u003Ca class='wiki-link-internal' href='/w/C%2B%2B#s-4.1' title='C++'\u003E템플릿 메타 프로그래밍\u003C/a\u003E&quot;, Java/C# 제네릭 = &quot;일반화 프로그래밍&quot;으로 이해하면 쉽다. &quot;템플릿 메타 프로그래밍&quot;은 \u003Ca class='wiki-link-internal' href='/w/C%2B%2B' title='C++'\u003EC++\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/D%EC%96%B8%EC%96%B4' title='D언어'\u003ED\u003C/a\u003E 등 극소수의 언어만 지원한다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-20'\u003E\u003C/span\u003E\u003Ca href='#rfn-20'\u003E&#91;20&#93;\u003C/a\u003E 이 부분은 주관적인 것으로 C/C++가 Java보다 가독성이 좋지 않다는 것에 대해 동의하지 않는 시각도 많다는 점을 알려둔다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-21'\u003E\u003C/span\u003E\u003Ca href='#rfn-21'\u003E&#91;21&#93;\u003C/a\u003E Java는 \u003Ca class='wiki-link-internal' href='/w/JIT' title='JIT'\u003EJIT\u003C/a\u003E 컴파일을 기본적으로 사용하기 때문이다. C#이나 PHP 7와 같은 고수준 언어도 해당사항이다. \u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-22'\u003E\u003C/span\u003E\u003Ca href='#rfn-22'\u003E&#91;22&#93;\u003C/a\u003E 메모리를 훑으면서 순간적으로 프로그램이 얼어붙어 멈추는 현상.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-23'\u003E\u003C/span\u003E\u003Ca href='#rfn-23'\u003E&#91;23&#93;\u003C/a\u003E 이를 \u003Ca class='wiki-link-internal' href='/w/%ED%95%9C%EC%A7%80%EC%9A%B0' title='한지우'\u003Egotta catch &#39;em all\u003C/a\u003E 패턴이라고 한다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-24'\u003E\u003C/span\u003E\u003Ca href='#rfn-24'\u003E&#91;24&#93;\u003C/a\u003E 물론 이렇게 짜면 안되지만 구조적으로 강요받는 형편.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-25'\u003E\u003C/span\u003E\u003Ca href='#rfn-25'\u003E&#91;25&#93;\u003C/a\u003E 이쪽은 RuntimeException 계열의 예외로, 이것을 던지는 메소드가 throws에 명시적으로 던진다고 선언하지 않았을 경우 검사를 하지 않아도 된다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-26'\u003E\u003C/span\u003E\u003Ca href='#rfn-26'\u003E&#91;26&#93;\u003C/a\u003E 대한민국에 국한되는 경향이 강하긴 하지만 현재 한국에서 이러한 예외처리를 \u003Cstrong\u003E코딩하는 순간에\u003C/strong\u003E 인지하는 개발자는 드물다. 국비지원 학원을 막 졸업한 신입들은 말 할 것도 없으며 현업 몇년 한 초중급 경력자들 역시 이를 인지하지 못하는 경우가 허다하기 때문에, 어찌보면 대한민국 IT계의 버그처리와 예외처리에 있어서만큼은 장점으로 볼 수도 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-27'\u003E\u003C/span\u003E\u003Ca href='#rfn-27'\u003E&#91;27&#93;\u003C/a\u003E 사실 C(C++이 아니다)는 C99기준 stdio.h를 포함하지 않아도 puts, printf 등을 사용할 수 있다. C, C++ 공통으로는(C++11기준) main에 int를 붙이지 않아도 콤파일이 된다. 따라서 더 짧게 쓴다면 \u003Cbr\u003Emain() {\u003Cbr\u003E　　puts(&quot;Hello&quot;);\u003Cbr\u003E}\u003Cbr\u003E이 된다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-28'\u003E\u003C/span\u003E\u003Ca href='#rfn-28'\u003E&#91;28&#93;\u003C/a\u003E 그 \u003Ca class='wiki-link-internal' href='/w/%EB%A7%88%EC%84%B8%EB%9D%BC%ED%8B%B0' title='마세라티'\u003E마세라티\u003C/a\u003E가 맞다. 자신이 탈수나 있을지도 모르는 마세라티를 타면 어떻게 해야 될까... 라는 쓸데없는 고민을 하는 것을 비유하는 문제로, 당장에 쓸데없는 기능을 위해 과도하게 투자하는 것을 의미한다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-29'\u003E\u003C/span\u003E\u003Ca href='#rfn-29'\u003E&#91;29&#93;\u003C/a\u003E 프로그래밍 언어를 좀 더 쉽게 표현할 수 있도록 하는 보조문법. C에서 구조체 포인터를 쓸 때 (*ptr).num은 ptr-&gt;num으로도 표현 가능하므로, -&gt;는 문법적 설탕이라고 할 수 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-30'\u003E\u003C/span\u003E\u003Ca href='#rfn-30'\u003E&#91;30&#93;\u003C/a\u003E 컬렉션(Collection)의 이터레이터를 확장해서 처리할 수 있는 개념으로, 이터레이터의 원소를 필터링해서 원하는 원소만 뽑거나, 원소갯수를 줄여버리고, 이렇게 다시 뽑혀진 원소들로 갖가지 처리를 만드는 등 &#39;함수적인(functional)&#39; 기능을 제공한다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-31'\u003E\u003C/span\u003E\u003Ca href='#rfn-31'\u003E&#91;31&#93;\u003C/a\u003E 정작 람다 표현식의 추가는 Java 진영 내에서 논란이 있다. 람다 식이 뒤늦게 추가된 것도 코드 리딩이 어려워진다고 싫어하는 개발자가 많아서였다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-32'\u003E\u003C/span\u003E\u003Ca href='#rfn-32'\u003E&#91;32&#93;\u003C/a\u003E 멀리 갈 것 없이, C언어의 stdio.h와 자바의 System.out을 비교해보자. Java는 직관적으로 &#39;시스템&#39;에서 뭔가가 &#39;나온다&#39;는 것을 쉽게 인식할 수 있지만, stdio.h를 봤을 때 직관적으로 뭘 떠올릴까? 저걸 처음 보고 STanDard Input and Output을 떠올릴 사람이 얼마나 있을까? \u003Cdel\u003E물론 C를 하다 보면 언어 기능 자체가 적어 파악하기가 쉬운 건 함정이다\u003C/del\u003E \u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-33'\u003E\u003C/span\u003E\u003Ca href='#rfn-33'\u003E&#91;33&#93;\u003C/a\u003E 실제로 Java에서 기본 제공하는 정렬 기능은 Collections 클래스의 정적 메소드인 sort(array)를 호출하도록 작성되어 있다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-34'\u003E\u003C/span\u003E\u003Ca href='#rfn-34'\u003E&#91;34&#93;\u003C/a\u003E JSP의 목적이 HTML 페이지를 동적으로 만들어내는 것이다. JSP 소스는 Java 서블릿 코드로 변환되어 서버에서 실행되고, 서버는 이 HTML 결과를 브라우저에 보여준다. JSP 페이지는 HTML 페이지에 Java 코드가 포함되어 있는 식으로 되어 있는 경우가 많고, 이 점은 \u003Ca class='wiki-link-internal' href='/w/PHP' title='PHP'\u003EPHP\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/ASP' title='ASP'\u003EASP.NET\u003C/a\u003E 등과 비슷한 편이다. 반면 Java 서블릿은 서버 쪽에서 하는 일에 관심이 많지만 출력에 대한 관심은 적다. 필요하다면 브라우저에 출력을 전혀 안 보낼 수도 있다. 최근에는 Server side script language로 HTML 페이지를 동적으로 만드는 식으로는 프로그래밍을 하지 않는다. JSP, PHP와 같은 Server side script language로는 서버에 있는 자원의 접근을 주로 하고(DB 연산, File 연산 등등) 화면에 보여주는 UI는 HTML/CSS/JavaScript로만 한다. 따라서 Client side와 Server side 간에 통신이 필요한데 이는 XHR(XML HTTP Request)를 이용한다. 이러한 프로그래밍 기법을 나타내는 표현이 REST 내지는 Open API이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-35'\u003E\u003C/span\u003E\u003Ca href='#rfn-35'\u003E&#91;35&#93;\u003C/a\u003E Java는 현용 프로그래밍 언어 중에서는 가장 Verbose한(장황한) 언어로 꼽힌다. 즉, 같은 의미인데 많은 타이핑이 필요하다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-36'\u003E\u003C/span\u003E\u003Ca href='#rfn-36'\u003E&#91;36&#93;\u003C/a\u003E Java는 버전 10에서 와서야 이와 같은 타입 추론 기능이 가능해졌다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-37'\u003E\u003C/span\u003E\u003Ca href='#rfn-37'\u003E&#91;37&#93;\u003C/a\u003E 안드로이드의 Java 라이선스 무단 사용으로 구글이 오라클과 법정 싸움을 한 여파로 보인다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-38'\u003E\u003C/span\u003E\u003Ca href='#rfn-38'\u003E&#91;38&#93;\u003C/a\u003E 기초적인 C-문법의 일부인 if문, while문 등을 제외하면 공통점이 많지 않다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-ES6'\u003E\u003C/span\u003E\u003Ca href='#rfn-39'\u003E&#91;ES6&#93;\u003C/a\u003E ECMAScript 6에서 Class가 생겼다! 그래도 여전히 Java의 클래스와는 겉보기에만 비슷할 뿐 열어보면 다르다. ES6에서 나온 클래스는 기존에 있던 prototype 객체지향 프로그래밍을 조금 더 쉽게 하게 해주는 문법적 설탕이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-40'\u003E\u003C/span\u003E\u003Ca href='#rfn-40'\u003E&#91;40&#93;\u003C/a\u003E 다만 인도네시아의 어원은 인도와 관련이 \u003Cstrong\u003E있다\u003C/strong\u003E. 인도네시아라는 이름은 &#39;\u003Ca class='wiki-link-internal' href='/w/%EC%9D%B8%EB%8F%84%EC%96%91' title='인도양'\u003E인도양\u003C/a\u003E의 섬&#39;들이라는 \u003Ca class='wiki-link-internal' href='/w/%EA%B7%B8%EB%A6%AC%EC%8A%A4%EC%96%B4' title='그리스어'\u003E그리스어\u003C/a\u003E·\u003Ca class='wiki-link-internal' href='/w/%EB%9D%BC%ED%8B%B4%EC%96%B4' title='라틴어'\u003E라틴어\u003C/a\u003E식 표현이기 때문. 이런 인도네시아와 인도의 관계는, JavaScript가 Java와 별 관련은 없어도 그 이름을 빌려 왔다는 점에서 왠지 흡사하다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-41'\u003E\u003C/span\u003E\u003Ca href='#rfn-41'\u003E&#91;41&#93;\u003C/a\u003E 각 언어 프로그래머들의 자신의 언어에 대한 자부심은 가히 종교의 신앙과 비견할 만한 것이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-42'\u003E\u003C/span\u003E\u003Ca href='#rfn-42'\u003E&#91;42&#93;\u003C/a\u003E 원래 \u003Ca class='wiki-link-internal' href='/w/%EC%95%84%ED%8C%8C%EC%B9%98%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9E%AC%EB%8B%A8' title='아파치 소프트웨어 재단'\u003E아파치 소프트웨어 재단\u003C/a\u003E이 &#39;자카르타&#39;라는 이름의 Java 오픈 소스 프로젝트(현재는 종료)를 소유하고 있었으나, 해당 명칭을 사용해도 된다고 허가하였다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-43'\u003E\u003C/span\u003E\u003Ca href='#rfn-43'\u003E&#91;43&#93;\u003C/a\u003E Java가 \u003Ca class='wiki-link-internal' href='/w/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C(%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)' title='안드로이드(운영체제)'\u003E안드로이드\u003C/a\u003E의 기반이 되는 언어라는 점을 생각하면 아이러니...\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-44'\u003E\u003C/span\u003E\u003Ca href='#rfn-44'\u003E&#91;44&#93;\u003C/a\u003E 사실 애플은 독자적인 JDK를 제공하는지라 Java 개발자들을 매우 피곤하게 하는 회사이기도 하다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-45'\u003E\u003C/span\u003E\u003Ca href='#rfn-45'\u003E&#91;45&#93;\u003C/a\u003E 단지 징역을 살지는 않고 FBI에서 1년 근무하는 것으로 퉁쳤다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-46'\u003E\u003C/span\u003E\u003Ca href='#rfn-46'\u003E&#91;46&#93;\u003C/a\u003E 이 부분은 대학의 \u003Cstrong\u003E교육용\u003C/strong\u003E 언어로서의 이야기다. 산업용으로서는 같은 기능을 개발하기 위한 언어는 쉬우면 쉬울수록 좋은 것이 당연하다. 물론 성능과 생산성 사이에서 적절한 균형을 잡아야 하겠지만.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-47'\u003E\u003C/span\u003E\u003Ca href='#rfn-47'\u003E&#91;47&#93;\u003C/a\u003E Java 상임 위원회에는 \u003Ca class='wiki-link-internal' href='/w/%EC%9D%B8%ED%85%94' title='인텔'\u003E인텔\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/%EC%98%A4%EB%9D%BC%ED%81%B4(%EA%B8%B0%EC%97%85)' title='오라클(기업)'\u003E오라클\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/JetBrains' title='JetBrains'\u003EJetBrains\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/%EB%A0%88%EB%93%9C%ED%96%87' title='레드햇'\u003E레드햇\u003C/a\u003E, \u003Ca class='wiki-link-internal' href='/w/ARM%20Holdings' title='ARM Holdings'\u003EARM Holdings\u003C/a\u003E 등이 속해 있다. 모두 각자의 분야에서 내로라하는 기업들이다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-48'\u003E\u003C/span\u003E\u003Ca href='#rfn-48'\u003E&#91;48&#93;\u003C/a\u003E &#39;.&#39;은 Java 클래스 파일이 위치한 해당 디렉토리를 의미한다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-49'\u003E\u003C/span\u003E\u003Ca href='#rfn-49'\u003E&#91;49&#93;\u003C/a\u003E CAFEDEAD를 0xCA 0xFE 0xDE 0xAD로 바꿨을 때의 얘기인 듯하다.\u003C/span\u003E\u003Cspan class='footnote-list'\u003E\u003Cspan class='target' id='fn-50'\u003E\u003C/span\u003E\u003Ca href='#rfn-50'\u003E&#91;50&#93;\u003C/a\u003E 그때 필요한 매직넘버는 2개였다. 하나는 오브젝트 파일이고, 또 다른 하나는 클래스 파일 매직넘버였다.\u003C/span\u003E\u003C/div\u003E","category":[{"doc":{"namespace":"분류","title":"프로그래밍 언어"},"exist":true},{"doc":{"namespace":"분류","title":"객체 지향 언어"},"exist":true}],"discuss_progress":false,"star_count":17,"starred":false,"enable_ads":true,"enable_powerlink":true,"body":{}},"meta":null},"session":{"member":null,"ip":"183.101.101.52","identifier":"i:183.101.101.52","menus":[],"hash":"5d03c54fd636b3b991969d04dffca32e"}}</script><script src="/skins/senkawa/manifest.f912fa1fc68aea9c8bcf.js" defer></script><script src="/skins/senkawa/vendor.eef37a8375da62ac81c7.js" defer></script><script src="/skins/senkawa/main.1960bf2496955164048f.js" defer></script></body></html>